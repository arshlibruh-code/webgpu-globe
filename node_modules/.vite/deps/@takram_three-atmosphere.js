import {
  $e,
  $o,
  C,
  Co,
  Eo,
  Fo,
  L,
  Lo,
  Ls,
  Oo,
  Xo,
  b,
  io,
  wo,
  xo,
  yo,
  zo
} from "./chunk-CNPIQBH5.js";
import "./chunk-JPKAUAU7.js";
import {
  AddEquation,
  AlwaysDepth,
  BackSide,
  BasicDepthPacking,
  BufferAttribute,
  BufferGeometry,
  Camera,
  ClampToEdgeWrapping,
  Color,
  CustomBlending,
  Data3DTexture,
  DataTexture,
  DepthTexture,
  DirectionalLight,
  DoubleSide,
  EqualDepth,
  EventDispatcher,
  FloatType,
  FrontSide,
  GLSL3,
  GreaterDepth,
  GreaterEqualDepth,
  HalfFloatType,
  InterleavedBuffer,
  InterleavedBufferAttribute,
  LessDepth,
  LessEqualDepth,
  LightProbe,
  LinearFilter,
  LinearSRGBColorSpace,
  Loader,
  Material,
  Matrix3,
  Matrix4,
  Mesh,
  MeshBasicMaterial,
  NearestFilter,
  NeverDepth,
  NoBlending,
  NoColorSpace,
  NotEqualDepth,
  OneFactor,
  PerspectiveCamera,
  PlaneGeometry,
  REVISION,
  RGBADepthPacking,
  RGBAFormat,
  RawShaderMaterial,
  RedFormat,
  Scene,
  ShaderMaterial,
  Sphere,
  Texture,
  Uniform,
  UnsignedByteType,
  UnsignedIntType,
  Vector2,
  Vector3,
  WebGL3DRenderTarget,
  WebGLRenderTarget
} from "./chunk-GHUIN7QU.js";

// node_modules/postprocessing/build/index.js
var MILLISECONDS_TO_SECONDS = 1 / 1e3;
var fullscreenGeometry = (() => {
  const vertices = new Float32Array([-1, -1, 0, 3, -1, 0, -1, 3, 0]);
  const uvs = new Float32Array([0, 0, 2, 0, 0, 2]);
  const geometry = new BufferGeometry();
  geometry.setAttribute("position", new BufferAttribute(vertices, 3));
  geometry.setAttribute("uv", new BufferAttribute(uvs, 2));
  return geometry;
})();
var Pass = class _Pass {
  /**
   * A shared fullscreen triangle.
   *
   * The screen size is 2x2 units (NDC). A triangle needs to be 4x4 units to fill the screen.
   * @see https://michaldrobot.com/2014/04/01/gcn-execution-patterns-in-full-screen-passes/
   * @type {BufferGeometry}
   * @internal
   */
  static get fullscreenGeometry() {
    return fullscreenGeometry;
  }
  /**
   * Constructs a new pass.
   *
   * @param {String} [name] - The name of this pass. Does not have to be unique.
   * @param {Scene} [scene] - The scene to render. The default scene contains a single mesh that fills the screen.
   * @param {Camera} [camera] - A camera. Fullscreen effect passes don't require a camera.
   */
  constructor(name = "Pass", scene = new Scene(), camera = new Camera()) {
    this.name = name;
    this.renderer = null;
    this.scene = scene;
    this.camera = camera;
    this.screen = null;
    this.rtt = true;
    this.needsSwap = true;
    this.needsDepthTexture = false;
    this.enabled = true;
  }
  /**
   * Sets the render to screen flag.
   *
   * If this flag is changed, the fullscreen material will be updated as well.
   *
   * @type {Boolean}
   */
  get renderToScreen() {
    return !this.rtt;
  }
  set renderToScreen(value) {
    if (this.rtt === value) {
      const material = this.fullscreenMaterial;
      if (material !== null) {
        material.needsUpdate = true;
      }
      this.rtt = !value;
    }
  }
  /**
   * Sets the main scene.
   *
   * @type {Scene}
   */
  set mainScene(value) {
  }
  /**
   * Sets the main camera.
   *
   * @type {Camera}
   */
  set mainCamera(value) {
  }
  /**
   * Sets the renderer
   *
   * @deprecated
   * @param {WebGLRenderer} renderer - The renderer.
   */
  setRenderer(renderer) {
    this.renderer = renderer;
  }
  /**
   * Indicates whether this pass is enabled.
   *
   * @deprecated Use enabled instead.
   * @return {Boolean} Whether this pass is enabled.
   */
  isEnabled() {
    return this.enabled;
  }
  /**
   * Enables or disables this pass.
   *
   * @deprecated Use enabled instead.
   * @param {Boolean} value - Whether the pass should be enabled.
   */
  setEnabled(value) {
    this.enabled = value;
  }
  /**
   * The fullscreen material.
   *
   * @type {Material}
   */
  get fullscreenMaterial() {
    return this.screen !== null ? this.screen.material : null;
  }
  set fullscreenMaterial(value) {
    let screen = this.screen;
    if (screen !== null) {
      screen.material = value;
    } else {
      screen = new Mesh(_Pass.fullscreenGeometry, value);
      screen.frustumCulled = false;
      if (this.scene === null) {
        this.scene = new Scene();
      }
      this.scene.add(screen);
      this.screen = screen;
    }
  }
  /**
   * Returns the current fullscreen material.
   *
   * @deprecated Use fullscreenMaterial instead.
   * @return {Material} The current fullscreen material, or null if there is none.
   */
  getFullscreenMaterial() {
    return this.fullscreenMaterial;
  }
  /**
   * Sets the fullscreen material.
   *
   * @deprecated Use fullscreenMaterial instead.
   * @protected
   * @param {Material} value - A fullscreen material.
   */
  setFullscreenMaterial(value) {
    this.fullscreenMaterial = value;
  }
  /**
   * Returns the current depth texture.
   *
   * @return {Texture} The current depth texture, or null if there is none.
   */
  getDepthTexture() {
    return null;
  }
  /**
   * Sets the depth texture.
   *
   * This method will be called automatically by the {@link EffectComposer}.
   * You may override this method if your pass relies on the depth information of a preceding {@link RenderPass}.
   *
   * @param {Texture} depthTexture - A depth texture.
   * @param {DepthPackingStrategy} [depthPacking=BasicDepthPacking] - The depth packing.
   */
  setDepthTexture(depthTexture, depthPacking = BasicDepthPacking) {
  }
  /**
   * Renders this pass.
   *
   * This is an abstract method that must be overridden.
   *
   * @abstract
   * @throws {Error} An error is thrown if the method is not overridden.
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.
   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.
   */
  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {
    throw new Error("Render method not implemented!");
  }
  /**
   * Sets the size.
   *
   * You may override this method if you want to be informed about the size of the backbuffer/canvas.
   * This method is called before {@link initialize} and every time the size of the {@link EffectComposer} changes.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
  }
  /**
   * Performs initialization tasks.
   *
   * This method is called when this pass is added to an {@link EffectComposer}.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.
   * @param {Number} frameBufferType - The type of the main frame buffers.
   */
  initialize(renderer, alpha, frameBufferType) {
  }
  /**
   * Performs a shallow search for disposable properties and deletes them.
   *
   * The {@link EffectComposer} calls this method when it is being destroyed. You can use it independently to free
   * memory when you're certain that you don't need this pass anymore.
   */
  dispose() {
    for (const key of Object.keys(this)) {
      const property = this[key];
      const isDisposable = property instanceof WebGLRenderTarget || property instanceof Material || property instanceof Texture || property instanceof _Pass;
      if (isDisposable) {
        this[key].dispose();
      }
    }
    if (this.fullscreenMaterial !== null) {
      this.fullscreenMaterial.dispose();
    }
  }
};
var common_default = `varying vec2 vUv;void main(){vUv=position.xy*0.5+0.5;gl_Position=vec4(position.xy,1.0,1.0);}`;
var color = new Color();
var ClearPass = class extends Pass {
  /**
   * Constructs a new clear pass.
   *
   * @param {Boolean} [color=true] - Determines whether the color buffer should be cleared.
   * @param {Boolean} [depth=true] - Determines whether the depth buffer should be cleared.
   * @param {Boolean} [stencil=false] - Determines whether the stencil buffer should be cleared.
   */
  constructor(color2 = true, depth = true, stencil = false) {
    super("ClearPass", null, null);
    this.needsSwap = false;
    this.color = color2;
    this.depth = depth;
    this.stencil = stencil;
    this.overrideClearColor = null;
    this.overrideClearAlpha = -1;
  }
  /**
   * Sets the clear flags.
   *
   * @param {Boolean} color - Whether the color buffer should be cleared.
   * @param {Boolean} depth - Whether the depth buffer should be cleared.
   * @param {Boolean} stencil - Whether the stencil buffer should be cleared.
   */
  setClearFlags(color2, depth, stencil) {
    this.color = color2;
    this.depth = depth;
    this.stencil = stencil;
  }
  /**
   * Returns the override clear color. Default is null.
   *
   * @deprecated Use overrideClearColor instead.
   * @return {Color} The clear color.
   */
  getOverrideClearColor() {
    return this.overrideClearColor;
  }
  /**
   * Sets the override clear color.
   *
   * @deprecated Use overrideClearColor instead.
   * @param {Color} value - The clear color.
   */
  setOverrideClearColor(value) {
    this.overrideClearColor = value;
  }
  /**
   * Returns the override clear alpha. Default is -1.
   *
   * @deprecated Use overrideClearAlpha instead.
   * @return {Number} The clear alpha.
   */
  getOverrideClearAlpha() {
    return this.overrideClearAlpha;
  }
  /**
   * Sets the override clear alpha.
   *
   * @deprecated Use overrideClearAlpha instead.
   * @param {Number} value - The clear alpha.
   */
  setOverrideClearAlpha(value) {
    this.overrideClearAlpha = value;
  }
  /**
   * Clears the input buffer or the screen.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.
   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.
   */
  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {
    const overrideClearColor = this.overrideClearColor;
    const overrideClearAlpha = this.overrideClearAlpha;
    const clearAlpha = renderer.getClearAlpha();
    const hasOverrideClearColor = overrideClearColor !== null;
    const hasOverrideClearAlpha = overrideClearAlpha >= 0;
    if (hasOverrideClearColor) {
      renderer.getClearColor(color);
      renderer.setClearColor(overrideClearColor, hasOverrideClearAlpha ? overrideClearAlpha : clearAlpha);
    } else if (hasOverrideClearAlpha) {
      renderer.setClearAlpha(overrideClearAlpha);
    }
    renderer.setRenderTarget(this.renderToScreen ? null : inputBuffer);
    renderer.clear(this.color, this.depth, this.stencil);
    if (hasOverrideClearColor) {
      renderer.setClearColor(color, clearAlpha);
    } else if (hasOverrideClearAlpha) {
      renderer.setClearAlpha(clearAlpha);
    }
  }
};
var EffectAttribute = {
  NONE: 0,
  DEPTH: 1,
  CONVOLUTION: 2
};
var workaroundEnabled = false;
var OverrideMaterialManager = class {
  /**
   * Constructs a new override material manager.
   *
   * @param {Material} [material=null] - An override material.
   */
  constructor(material = null) {
    this.originalMaterials = /* @__PURE__ */ new Map();
    this.material = null;
    this.materials = null;
    this.materialsBackSide = null;
    this.materialsDoubleSide = null;
    this.materialsFlatShaded = null;
    this.materialsFlatShadedBackSide = null;
    this.materialsFlatShadedDoubleSide = null;
    this.setMaterial(material);
    this.meshCount = 0;
    this.replaceMaterial = (node) => {
      if (node.isMesh) {
        let materials;
        if (node.material.flatShading) {
          switch (node.material.side) {
            case DoubleSide:
              materials = this.materialsFlatShadedDoubleSide;
              break;
            case BackSide:
              materials = this.materialsFlatShadedBackSide;
              break;
            default:
              materials = this.materialsFlatShaded;
              break;
          }
        } else {
          switch (node.material.side) {
            case DoubleSide:
              materials = this.materialsDoubleSide;
              break;
            case BackSide:
              materials = this.materialsBackSide;
              break;
            default:
              materials = this.materials;
              break;
          }
        }
        this.originalMaterials.set(node, node.material);
        if (node.isSkinnedMesh) {
          node.material = materials[2];
        } else if (node.isInstancedMesh) {
          node.material = materials[1];
        } else {
          node.material = materials[0];
        }
        ++this.meshCount;
      }
    };
  }
  /**
   * Clones the given material.
   *
   * @private
   * @param {Material} material - The material.
   * @return {Material} The cloned material.
   */
  cloneMaterial(material) {
    if (!(material instanceof ShaderMaterial)) {
      return material.clone();
    }
    const uniforms = material.uniforms;
    const textureUniforms = /* @__PURE__ */ new Map();
    for (const key in uniforms) {
      const value = uniforms[key].value;
      if (value.isRenderTargetTexture) {
        uniforms[key].value = null;
        textureUniforms.set(key, value);
      }
    }
    const clone = material.clone();
    for (const entry of textureUniforms) {
      uniforms[entry[0]].value = entry[1];
      clone.uniforms[entry[0]].value = entry[1];
    }
    return clone;
  }
  /**
   * Sets the override material.
   *
   * @param {Material} material - The material.
   */
  setMaterial(material) {
    this.disposeMaterials();
    this.material = material;
    if (material !== null) {
      const materials = this.materials = [
        this.cloneMaterial(material),
        this.cloneMaterial(material),
        this.cloneMaterial(material)
      ];
      for (const m22 of materials) {
        m22.uniforms = Object.assign({}, material.uniforms);
        m22.side = FrontSide;
      }
      materials[2].skinning = true;
      this.materialsBackSide = materials.map((m22) => {
        const c22 = this.cloneMaterial(m22);
        c22.uniforms = Object.assign({}, material.uniforms);
        c22.side = BackSide;
        return c22;
      });
      this.materialsDoubleSide = materials.map((m22) => {
        const c22 = this.cloneMaterial(m22);
        c22.uniforms = Object.assign({}, material.uniforms);
        c22.side = DoubleSide;
        return c22;
      });
      this.materialsFlatShaded = materials.map((m22) => {
        const c22 = this.cloneMaterial(m22);
        c22.uniforms = Object.assign({}, material.uniforms);
        c22.flatShading = true;
        return c22;
      });
      this.materialsFlatShadedBackSide = materials.map((m22) => {
        const c22 = this.cloneMaterial(m22);
        c22.uniforms = Object.assign({}, material.uniforms);
        c22.flatShading = true;
        c22.side = BackSide;
        return c22;
      });
      this.materialsFlatShadedDoubleSide = materials.map((m22) => {
        const c22 = this.cloneMaterial(m22);
        c22.uniforms = Object.assign({}, material.uniforms);
        c22.flatShading = true;
        c22.side = DoubleSide;
        return c22;
      });
    }
  }
  /**
   * Renders the scene with the override material.
   *
   * @private
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {Scene} scene - A scene.
   * @param {Camera} camera - A camera.
   */
  render(renderer, scene, camera) {
    const shadowMapEnabled = renderer.shadowMap.enabled;
    renderer.shadowMap.enabled = false;
    if (workaroundEnabled) {
      const originalMaterials = this.originalMaterials;
      this.meshCount = 0;
      scene.traverse(this.replaceMaterial);
      renderer.render(scene, camera);
      for (const entry of originalMaterials) {
        entry[0].material = entry[1];
      }
      if (this.meshCount !== originalMaterials.size) {
        originalMaterials.clear();
      }
    } else {
      const overrideMaterial = scene.overrideMaterial;
      scene.overrideMaterial = this.material;
      renderer.render(scene, camera);
      scene.overrideMaterial = overrideMaterial;
    }
    renderer.shadowMap.enabled = shadowMapEnabled;
  }
  /**
   * Deletes cloned override materials.
   *
   * @private
   */
  disposeMaterials() {
    if (this.material !== null) {
      const materials = this.materials.concat(this.materialsBackSide).concat(this.materialsDoubleSide).concat(this.materialsFlatShaded).concat(this.materialsFlatShadedBackSide).concat(this.materialsFlatShadedDoubleSide);
      for (const m22 of materials) {
        m22.dispose();
      }
    }
  }
  /**
   * Performs cleanup tasks.
   */
  dispose() {
    this.originalMaterials.clear();
    this.disposeMaterials();
  }
  /**
   * Indicates whether the override material workaround is enabled.
   *
   * @type {Boolean}
   */
  static get workaroundEnabled() {
    return workaroundEnabled;
  }
  /**
   * Enables or disables the override material workaround globally.
   *
   * This only affects post processing passes and effects.
   *
   * @type {Boolean}
   */
  static set workaroundEnabled(value) {
    workaroundEnabled = value;
  }
};
var IdManager = class {
  /**
   * Constructs a new ID manager.
   *
   * @param initialId - The first ID.
   */
  constructor(initialId = 0) {
    this.nextId = initialId;
  }
  /**
   * Returns the next unique ID.
   *
   * @return The ID.
   */
  getNextId() {
    return this.nextId++;
  }
  /**
   * Resets the ID counter.
   *
   * @param initialId - The first ID.
   * @return This manager.
   */
  reset(initialId = 0) {
    this.nextId = initialId;
    return this;
  }
};
var idManager = new IdManager(2);
var Selection = class extends Set {
  /**
   * Constructs a new selection.
   *
   * @param {Iterable<Object3D>} [iterable] - A collection of objects that should be added to this selection.
   * @param {Number} [layer] - A dedicated render layer for selected objects. Range is `[2, 31]`. Starts at 2 if omitted.
   */
  constructor(iterable, layer = idManager.getNextId()) {
    super();
    this.exclusive = false;
    this._layer = layer;
    if (this._layer < 1 || this._layer > 31) {
      console.warn("Layer out of range, resetting to 2");
      idManager.reset(2);
      this._layer = idManager.getNextId();
    }
    if (iterable !== void 0) {
      this.set(iterable);
    }
  }
  /**
   * The render layer for selected objects.
   *
   * @type {Number}
   */
  get layer() {
    return this._layer;
  }
  set layer(value) {
    const currentLayer = this._layer;
    for (const object of this) {
      object.layers.disable(currentLayer);
      object.layers.enable(value);
    }
    this._layer = value;
  }
  /**
   * Returns the current render layer for selected objects.
   *
   * The default layer is 2. If this collides with your own custom layers, please change it before rendering!
   *
   * @deprecated Use layer instead.
   * @return {Number} The layer.
   */
  getLayer() {
    return this.layer;
  }
  /**
   * Sets the render layer for selected objects.
   *
   * The current selection will be updated accordingly.
   *
   * @deprecated Use layer instead.
   * @param {Number} value - The layer. Range is [0, 31].
   */
  setLayer(value) {
    this.layer = value;
  }
  /**
   * Indicates whether objects that are added to this selection will be removed from all other layers.
   *
   * @deprecated Use exclusive instead.
   * @return {Number} Whether this selection is exclusive. Default is false.
   */
  isExclusive() {
    return this.exclusive;
  }
  /**
   * Controls whether objects that are added to this selection should be removed from all other layers.
   *
   * @deprecated Use exclusive instead.
   * @param {Number} value - Whether this selection should be exclusive.
   */
  setExclusive(value) {
    this.exclusive = value;
  }
  /**
   * Clears this selection.
   *
   * @return {Selection} This selection.
   */
  clear() {
    const layer = this.layer;
    for (const object of this) {
      object.layers.disable(layer);
    }
    return super.clear();
  }
  /**
   * Clears this selection and adds the given objects.
   *
   * @param {Iterable<Object3D>} objects - The objects that should be selected.
   * @return {Selection} This selection.
   */
  set(objects) {
    this.clear();
    for (const object of objects) {
      this.add(object);
    }
    return this;
  }
  /**
   * An alias for {@link has}.
   *
   * @param {Object3D} object - An object.
   * @return {Number} Returns 0 if the given object is currently selected, or -1 otherwise.
   * @deprecated Added for backward-compatibility.
   */
  indexOf(object) {
    return this.has(object) ? 0 : -1;
  }
  /**
   * Adds an object to this selection.
   *
   * If {@link exclusive} is set to `true`, the object will also be removed from all other layers.
   *
   * @param {Object3D} object - The object that should be selected.
   * @return {Selection} This selection.
   */
  add(object) {
    if (this.exclusive) {
      object.layers.set(this.layer);
    } else {
      object.layers.enable(this.layer);
    }
    return super.add(object);
  }
  /**
   * Removes an object from this selection.
   *
   * @param {Object3D} object - The object that should be deselected.
   * @return {Boolean} Returns true if an object has successfully been removed from this selection; otherwise false.
   */
  delete(object) {
    if (this.has(object)) {
      object.layers.disable(this.layer);
    }
    return super.delete(object);
  }
  /**
   * Removes an existing object from the selection. If the object doesn't exist it's added instead.
   *
   * @param {Object3D} object - The object.
   * @return {Boolean} Returns true if the object is added, false otherwise.
   */
  toggle(object) {
    let result;
    if (this.has(object)) {
      this.delete(object);
      result = false;
    } else {
      this.add(object);
      result = true;
    }
    return result;
  }
  /**
   * Sets the visibility of all selected objects.
   *
   * This method enables or disables render layer 0 of all selected objects.
   *
   * @param {Boolean} visible - Whether the selected objects should be visible.
   * @return {Selection} This selection.
   */
  setVisible(visible) {
    for (const object of this) {
      if (visible) {
        object.layers.enable(0);
      } else {
        object.layers.disable(0);
      }
    }
    return this;
  }
};
var BlendFunction = {
  SKIP: 9,
  SET: 30,
  ADD: 0,
  ALPHA: 1,
  AVERAGE: 2,
  COLOR: 3,
  COLOR_BURN: 4,
  COLOR_DODGE: 5,
  DARKEN: 6,
  DIFFERENCE: 7,
  DIVIDE: 8,
  DST: 9,
  EXCLUSION: 10,
  HARD_LIGHT: 11,
  HARD_MIX: 12,
  HUE: 13,
  INVERT: 14,
  INVERT_RGB: 15,
  LIGHTEN: 16,
  LINEAR_BURN: 17,
  LINEAR_DODGE: 18,
  LINEAR_LIGHT: 19,
  LUMINOSITY: 20,
  MULTIPLY: 21,
  NEGATION: 22,
  NORMAL: 23,
  OVERLAY: 24,
  PIN_LIGHT: 25,
  REFLECT: 26,
  SATURATION: 27,
  SCREEN: 28,
  SOFT_LIGHT: 29,
  SRC: 30,
  SUBTRACT: 31,
  VIVID_LIGHT: 32
};
var add_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(x.rgb+y.rgb,y.a),opacity);}`;
var alpha_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y,y.a*opacity);}`;
var average_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4((x.rgb+y.rgb)*0.5,y.a),opacity);}`;
var color_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(yHSL.xy,xHSL.z));return mix(x,vec4(z,y.a),opacity);}`;
var color_burn_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 a=x.rgb,b=y.rgb;vec3 z=mix(step(0.0,b)*(1.0-min(vec3(1.0),(1.0-a)/b)),vec3(1.0),step(1.0,a));return mix(x,vec4(z,y.a),opacity);}`;
var color_dodge_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 a=x.rgb,b=y.rgb;vec3 z=step(0.0,a)*mix(min(vec3(1.0),a/max(1.0-b,1e-9)),vec3(1.0),step(1.0,b));return mix(x,vec4(z,y.a),opacity);}`;
var darken_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(min(x.rgb,y.rgb),y.a),opacity);}`;
var difference_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(abs(x.rgb-y.rgb),y.a),opacity);}`;
var divide_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(x.rgb/max(y.rgb,1e-12),y.a),opacity);}`;
var exclusion_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4((x.rgb+y.rgb-2.0*x.rgb*y.rgb),y.a),opacity);}`;
var hard_light_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 a=min(x.rgb,1.0);vec3 b=min(y.rgb,1.0);vec3 z=mix(2.0*a*b,1.0-2.0*(1.0-a)*(1.0-b),step(0.5,b));return mix(x,vec4(z,y.a),opacity);}`;
var hard_mix_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(step(1.0,x.rgb+y.rgb),y.a),opacity);}`;
var hue_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(yHSL.x,xHSL.yz));return mix(x,vec4(z,y.a),opacity);}`;
var invert_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(1.0-y.rgb,y.a),opacity);}`;
var invert_rgb_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(y.rgb*(1.0-x.rgb),y.a),opacity);}`;
var lighten_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(max(x.rgb,y.rgb),y.a),opacity);}`;
var linear_burn_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(clamp(y.rgb+x.rgb-1.0,0.0,1.0),y.a),opacity);}`;
var linear_dodge_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(min(x.rgb+y.rgb,1.0),y.a),opacity);}`;
var linear_light_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(clamp(2.0*y.rgb+x.rgb-1.0,0.0,1.0),y.a),opacity);}`;
var luminosity_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(xHSL.xy,yHSL.z));return mix(x,vec4(z,y.a),opacity);}`;
var multiply_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(x.rgb*y.rgb,y.a),opacity);}`;
var negation_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(1.0-abs(1.0-x.rgb-y.rgb),y.a),opacity);}`;
var normal_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y,opacity);}`;
var overlay_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 z=mix(2.0*y.rgb*x.rgb,1.0-2.0*(1.0-y.rgb)*(1.0-x.rgb),step(0.5,x.rgb));return mix(x,vec4(z,y.a),opacity);}`;
var pin_light_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 y2=2.0*y.rgb;vec3 z=mix(mix(y2,x.rgb,step(0.5*x.rgb,y.rgb)),max(y2-1.0,vec3(0.0)),step(x.rgb,y2-1.0));return mix(x,vec4(z,y.a),opacity);}`;
var reflect_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 z=mix(min(x.rgb*x.rgb/max(1.0-y.rgb,1e-12),1.0),y.rgb,step(1.0,y.rgb));return mix(x,vec4(z,y.a),opacity);}`;
var saturation_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(xHSL.x,yHSL.y,xHSL.z));return mix(x,vec4(z,y.a),opacity);}`;
var screen_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(x.rgb+y.rgb-min(x.rgb*y.rgb,1.0),y.a),opacity);}`;
var soft_light_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 a=x.rgb;vec3 b=y.rgb;vec3 y2=2.0*b;vec3 w=step(0.5,b);vec3 c=a-(1.0-y2)*a*(1.0-a);vec3 d=mix(a+(y2-1.0)*(sqrt(a)-a),a+(y2-1.0)*a*((16.0*a-12.0)*a+3.0),w*(1.0-step(0.25,a)));vec3 z=mix(c,d,w);return mix(x,vec4(z,y.a),opacity);}`;
var src_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return y;}`;
var subtract_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(max(x.rgb+y.rgb-1.0,0.0),y.a),opacity);}`;
var vivid_light_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 z=mix(max(1.0-min((1.0-x.rgb)/(2.0*y.rgb),1.0),0.0),min(x.rgb/(2.0*(1.0-y.rgb)),1.0),step(0.5,y.rgb));return mix(x,vec4(z,y.a),opacity);}`;
var blendFunctions = /* @__PURE__ */ new Map([
  [BlendFunction.ADD, add_default],
  [BlendFunction.ALPHA, alpha_default],
  [BlendFunction.AVERAGE, average_default],
  [BlendFunction.COLOR, color_default],
  [BlendFunction.COLOR_BURN, color_burn_default],
  [BlendFunction.COLOR_DODGE, color_dodge_default],
  [BlendFunction.DARKEN, darken_default],
  [BlendFunction.DIFFERENCE, difference_default],
  [BlendFunction.DIVIDE, divide_default],
  [BlendFunction.DST, null],
  [BlendFunction.EXCLUSION, exclusion_default],
  [BlendFunction.HARD_LIGHT, hard_light_default],
  [BlendFunction.HARD_MIX, hard_mix_default],
  [BlendFunction.HUE, hue_default],
  [BlendFunction.INVERT, invert_default],
  [BlendFunction.INVERT_RGB, invert_rgb_default],
  [BlendFunction.LIGHTEN, lighten_default],
  [BlendFunction.LINEAR_BURN, linear_burn_default],
  [BlendFunction.LINEAR_DODGE, linear_dodge_default],
  [BlendFunction.LINEAR_LIGHT, linear_light_default],
  [BlendFunction.LUMINOSITY, luminosity_default],
  [BlendFunction.MULTIPLY, multiply_default],
  [BlendFunction.NEGATION, negation_default],
  [BlendFunction.NORMAL, normal_default],
  [BlendFunction.OVERLAY, overlay_default],
  [BlendFunction.PIN_LIGHT, pin_light_default],
  [BlendFunction.REFLECT, reflect_default],
  [BlendFunction.SATURATION, saturation_default],
  [BlendFunction.SCREEN, screen_default],
  [BlendFunction.SOFT_LIGHT, soft_light_default],
  [BlendFunction.SRC, src_default],
  [BlendFunction.SUBTRACT, subtract_default],
  [BlendFunction.VIVID_LIGHT, vivid_light_default]
]);
var BlendMode = class extends EventDispatcher {
  /**
   * Constructs a new blend mode.
   *
   * @param {BlendFunction} blendFunction - The blend function.
   * @param {Number} opacity - The opacity of the color that will be blended with the base color.
   */
  constructor(blendFunction, opacity = 1) {
    super();
    this._blendFunction = blendFunction;
    this.opacity = new Uniform(opacity);
  }
  /**
   * Returns the opacity.
   *
   * @return {Number} The opacity.
   */
  getOpacity() {
    return this.opacity.value;
  }
  /**
   * Sets the opacity.
   *
   * @param {Number} value - The opacity.
   */
  setOpacity(value) {
    this.opacity.value = value;
  }
  /**
   * The blend function.
   *
   * @type {BlendFunction}
   */
  get blendFunction() {
    return this._blendFunction;
  }
  set blendFunction(value) {
    this._blendFunction = value;
    this.dispatchEvent({ type: "change" });
  }
  /**
   * Returns the blend function.
   *
   * @deprecated Use blendFunction instead.
   * @return {BlendFunction} The blend function.
   */
  getBlendFunction() {
    return this.blendFunction;
  }
  /**
   * Sets the blend function.
   *
   * @deprecated Use blendFunction instead.
   * @param {BlendFunction} value - The blend function.
   */
  setBlendFunction(value) {
    this.blendFunction = value;
  }
  /**
   * Returns the blend function shader code.
   *
   * @return {String} The blend function shader code.
   */
  getShaderCode() {
    return blendFunctions.get(this.blendFunction);
  }
};
var Effect = class extends EventDispatcher {
  /**
   * Constructs a new effect.
   *
   * @param {String} name - The name of this effect. Doesn't have to be unique.
   * @param {String} fragmentShader - The fragment shader. This shader is required.
   * @param {Object} [options] - Additional options.
   * @param {EffectAttribute} [options.attributes=EffectAttribute.NONE] - The effect attributes that determine the execution priority and resource requirements.
   * @param {BlendFunction} [options.blendFunction=BlendFunction.NORMAL] - The blend function of this effect.
   * @param {Map<String, String>} [options.defines] - Custom preprocessor macro definitions. Keys are names and values are code.
   * @param {Map<String, Uniform>} [options.uniforms] - Custom shader uniforms. Keys are names and values are uniforms.
   * @param {Set<WebGLExtension>} [options.extensions] - WebGL extensions.
   * @param {String} [options.vertexShader=null] - The vertex shader. Most effects don't need one.
   */
  constructor(name, fragmentShader, {
    attributes = EffectAttribute.NONE,
    blendFunction = BlendFunction.NORMAL,
    defines = /* @__PURE__ */ new Map(),
    uniforms = /* @__PURE__ */ new Map(),
    extensions = null,
    vertexShader = null
  } = {}) {
    super();
    this.name = name;
    this.renderer = null;
    this.attributes = attributes;
    this.fragmentShader = fragmentShader;
    this.vertexShader = vertexShader;
    this.defines = defines;
    this.uniforms = uniforms;
    this.extensions = extensions;
    this.blendMode = new BlendMode(blendFunction);
    this.blendMode.addEventListener("change", (event) => this.setChanged());
    this._inputColorSpace = LinearSRGBColorSpace;
    this._outputColorSpace = NoColorSpace;
  }
  /**
   * The input color space.
   *
   * @type {ColorSpace}
   * @experimental
   */
  get inputColorSpace() {
    return this._inputColorSpace;
  }
  /**
   * @type {ColorSpace}
   * @protected
   * @experimental
   */
  set inputColorSpace(value) {
    this._inputColorSpace = value;
    this.setChanged();
  }
  /**
   * The output color space.
   *
   * Should only be changed if this effect converts the input colors to a different color space.
   *
   * @type {ColorSpace}
   * @experimental
   */
  get outputColorSpace() {
    return this._outputColorSpace;
  }
  /**
   * @type {ColorSpace}
   * @protected
   * @experimental
   */
  set outputColorSpace(value) {
    this._outputColorSpace = value;
    this.setChanged();
  }
  /**
   * Sets the main scene.
   *
   * @type {Scene}
   */
  set mainScene(value) {
  }
  /**
   * Sets the main camera.
   *
   * @type {Camera}
   */
  set mainCamera(value) {
  }
  /**
   * Returns the name of this effect.
   *
   * @deprecated Use name instead.
   * @return {String} The name.
   */
  getName() {
    return this.name;
  }
  /**
   * Sets the renderer.
   *
   * @deprecated
   * @param {WebGLRenderer} renderer - The renderer.
   */
  setRenderer(renderer) {
    this.renderer = renderer;
  }
  /**
   * Returns the preprocessor macro definitions.
   *
   * @deprecated Use defines instead.
   * @return {Map<String, String>} The extensions.
   */
  getDefines() {
    return this.defines;
  }
  /**
   * Returns the uniforms of this effect.
   *
   * @deprecated Use uniforms instead.
   * @return {Map<String, Uniform>} The extensions.
   */
  getUniforms() {
    return this.uniforms;
  }
  /**
   * Returns the WebGL extensions that are required by this effect.
   *
   * @deprecated Use extensions instead.
   * @return {Set<WebGLExtension>} The extensions.
   */
  getExtensions() {
    return this.extensions;
  }
  /**
   * Returns the blend mode.
   *
   * The result of this effect will be blended with the result of the previous effect using this blend mode.
   *
   * @deprecated Use blendMode instead.
   * @return {BlendMode} The blend mode.
   */
  getBlendMode() {
    return this.blendMode;
  }
  /**
   * Returns the effect attributes.
   *
   * @return {EffectAttribute} The attributes.
   */
  getAttributes() {
    return this.attributes;
  }
  /**
   * Sets the effect attributes.
   *
   * Effects that have the same attributes will be executed in the order in which they were registered. Some attributes
   * imply a higher priority.
   *
   * @protected
   * @param {EffectAttribute} attributes - The attributes.
   */
  setAttributes(attributes) {
    this.attributes = attributes;
    this.setChanged();
  }
  /**
   * Returns the fragment shader.
   *
   * @return {String} The fragment shader.
   */
  getFragmentShader() {
    return this.fragmentShader;
  }
  /**
   * Sets the fragment shader.
   *
   * @protected
   * @param {String} fragmentShader - The fragment shader.
   */
  setFragmentShader(fragmentShader) {
    this.fragmentShader = fragmentShader;
    this.setChanged();
  }
  /**
   * Returns the vertex shader.
   *
   * @return {String} The vertex shader.
   */
  getVertexShader() {
    return this.vertexShader;
  }
  /**
   * Sets the vertex shader.
   *
   * @protected
   * @param {String} vertexShader - The vertex shader.
   */
  setVertexShader(vertexShader) {
    this.vertexShader = vertexShader;
    this.setChanged();
  }
  /**
   * Informs the associated {@link EffectPass} that this effect requires a shader recompilation.
   *
   * Should be called after changing macros or extensions and after adding/removing uniforms.
   *
   * @protected
   */
  setChanged() {
    this.dispatchEvent({ type: "change" });
  }
  /**
   * Sets the depth texture.
   *
   * You may override this method if your effect requires direct access to the depth texture that is bound to the
   * associated {@link EffectPass}.
   *
   * @param {Texture} depthTexture - A depth texture.
   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing.
   */
  setDepthTexture(depthTexture, depthPacking = BasicDepthPacking) {
  }
  /**
   * Updates this effect by performing supporting operations.
   *
   * This method is called by the {@link EffectPass} right before the main fullscreen render operation, even if the
   * blend function is set to `SKIP`.
   *
   * You may override this method if you need to update custom uniforms or render additional off-screen textures.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
   */
  update(renderer, inputBuffer, deltaTime) {
  }
  /**
   * Updates the size of this effect.
   *
   * You may override this method if you want to be informed about the size of the backbuffer/canvas.
   * This method is called before {@link initialize} and every time the size of the {@link EffectComposer} changes.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
  }
  /**
   * Performs initialization tasks.
   *
   * This method is called when the associated {@link EffectPass} is added to an {@link EffectComposer}.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.
   * @param {Number} frameBufferType - The type of the main frame buffers.
   * @example if(!alpha && frameBufferType === UnsignedByteType) { this.myRenderTarget.texture.format = RGBFormat; }
   */
  initialize(renderer, alpha, frameBufferType) {
  }
  /**
   * Performs a shallow search for properties that define a dispose method and deletes them.
   *
   * The {@link EffectComposer} calls this method when it is being destroyed.
   */
  dispose() {
    for (const key of Object.keys(this)) {
      const property = this[key];
      const isDisposable = property instanceof WebGLRenderTarget || property instanceof Material || property instanceof Texture || property instanceof Pass;
      if (isDisposable) {
        this[key].dispose();
      }
    }
  }
};
var kernelPresets = [
  new Float32Array([0, 0]),
  new Float32Array([0, 1, 1]),
  new Float32Array([0, 1, 1, 2]),
  new Float32Array([0, 1, 2, 2, 3]),
  new Float32Array([0, 1, 2, 3, 4, 4, 5]),
  new Float32Array([0, 1, 2, 3, 4, 5, 7, 8, 9, 10])
];
var ShaderPass = class extends Pass {
  /**
   * Constructs a new shader pass.
   *
   * @param {ShaderMaterial} material - A shader material.
   * @param {String} [input="inputBuffer"] - The name of the input buffer uniform.
   */
  constructor(material, input = "inputBuffer") {
    super("ShaderPass");
    this.fullscreenMaterial = material;
    this.input = input;
  }
  /**
   * Sets the name of the input buffer uniform.
   *
   * @param {String} input - The name of the input buffer uniform.
   * @deprecated Use input instead.
   */
  setInput(input) {
    this.input = input;
  }
  /**
   * Renders the effect.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.
   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.
   */
  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {
    const uniforms = this.fullscreenMaterial.uniforms;
    if (inputBuffer !== null && uniforms !== void 0 && uniforms[this.input] !== void 0) {
      uniforms[this.input].value = inputBuffer.texture;
    }
    renderer.setRenderTarget(this.renderToScreen ? null : outputBuffer);
    renderer.render(this.scene, this.camera);
  }
  /**
   * Performs initialization tasks.
   *
   * @param {WebGLRenderer} renderer - A renderer.
   * @param {Boolean} alpha - Whether the renderer uses the alpha channel.
   * @param {Number} frameBufferType - The type of the main frame buffers.
   */
  initialize(renderer, alpha, frameBufferType) {
    if (frameBufferType !== void 0 && frameBufferType !== UnsignedByteType) {
      this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1";
    }
  }
};
var DepthTestStrategy = {
  DEFAULT: 0,
  KEEP_MAX_DEPTH: 1,
  DISCARD_MAX_DEPTH: 2
};
var depth_mask_default = `#include <common>
#include <packing>
#ifdef GL_FRAGMENT_PRECISION_HIGH
uniform highp sampler2D depthBuffer0;uniform highp sampler2D depthBuffer1;
#else
uniform mediump sampler2D depthBuffer0;uniform mediump sampler2D depthBuffer1;
#endif
uniform sampler2D inputBuffer;uniform vec2 cameraNearFar;float getViewZ(const in float depth){
#ifdef PERSPECTIVE_CAMERA
return perspectiveDepthToViewZ(depth,cameraNearFar.x,cameraNearFar.y);
#else
return orthographicDepthToViewZ(depth,cameraNearFar.x,cameraNearFar.y);
#endif
}varying vec2 vUv;void main(){vec2 depth;
#if DEPTH_PACKING_0 == 3201
depth.x=unpackRGBAToDepth(texture2D(depthBuffer0,vUv));
#else
depth.x=texture2D(depthBuffer0,vUv).r;
#ifdef LOG_DEPTH
float d=pow(2.0,depth.x*log2(cameraNearFar.y+1.0))-1.0;float a=cameraNearFar.y/(cameraNearFar.y-cameraNearFar.x);float b=cameraNearFar.y*cameraNearFar.x/(cameraNearFar.x-cameraNearFar.y);depth.x=a+b/d;
#endif
#endif
#if DEPTH_PACKING_1 == 3201
depth.y=unpackRGBAToDepth(texture2D(depthBuffer1,vUv));
#else
depth.y=texture2D(depthBuffer1,vUv).r;
#ifdef LOG_DEPTH
float d=pow(2.0,depth.y*log2(cameraNearFar.y+1.0))-1.0;float a=cameraNearFar.y/(cameraNearFar.y-cameraNearFar.x);float b=cameraNearFar.y*cameraNearFar.x/(cameraNearFar.x-cameraNearFar.y);depth.y=a+b/d;
#endif
#endif
bool isMaxDepth=(depth.x==1.0);
#ifdef PERSPECTIVE_CAMERA
depth.x=viewZToOrthographicDepth(getViewZ(depth.x),cameraNearFar.x,cameraNearFar.y);depth.y=viewZToOrthographicDepth(getViewZ(depth.y),cameraNearFar.x,cameraNearFar.y);
#endif
#if DEPTH_TEST_STRATEGY == 0
bool keep=depthTest(depth.x,depth.y);
#elif DEPTH_TEST_STRATEGY == 1
bool keep=isMaxDepth||depthTest(depth.x,depth.y);
#else
bool keep=!isMaxDepth&&depthTest(depth.x,depth.y);
#endif
if(keep){gl_FragColor=texture2D(inputBuffer,vUv);}else{discard;}}`;
var DepthMaskMaterial = class extends ShaderMaterial {
  /**
   * Constructs a new depth mask material.
   */
  constructor() {
    super({
      name: "DepthMaskMaterial",
      defines: {
        DEPTH_EPSILON: "0.0001",
        DEPTH_PACKING_0: "0",
        DEPTH_PACKING_1: "0",
        DEPTH_TEST_STRATEGY: DepthTestStrategy.KEEP_MAX_DEPTH
      },
      uniforms: {
        inputBuffer: new Uniform(null),
        depthBuffer0: new Uniform(null),
        depthBuffer1: new Uniform(null),
        cameraNearFar: new Uniform(new Vector2(1, 1))
      },
      blending: NoBlending,
      toneMapped: false,
      depthWrite: false,
      depthTest: false,
      fragmentShader: depth_mask_default,
      vertexShader: common_default
    });
    this.depthMode = LessDepth;
  }
  /**
   * The primary depth buffer.
   *
   * @type {Texture}
   */
  set depthBuffer0(value) {
    this.uniforms.depthBuffer0.value = value;
  }
  /**
   * The primary depth packing strategy.
   *
   * @type {DepthPackingStrategies}
   */
  set depthPacking0(value) {
    this.defines.DEPTH_PACKING_0 = value.toFixed(0);
    this.needsUpdate = true;
  }
  /**
   * Sets the base depth buffer.
   *
   * @deprecated Use depthBuffer0 and depthPacking0 instead.
   * @param {Texture} buffer - The depth texture.
   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing strategy.
   */
  setDepthBuffer0(buffer, depthPacking = BasicDepthPacking) {
    this.depthBuffer0 = buffer;
    this.depthPacking0 = depthPacking;
  }
  /**
   * The secondary depth buffer.
   *
   * @type {Texture}
   */
  set depthBuffer1(value) {
    this.uniforms.depthBuffer1.value = value;
  }
  /**
   * The secondary depth packing strategy.
   *
   * @type {DepthPackingStrategies}
   */
  set depthPacking1(value) {
    this.defines.DEPTH_PACKING_1 = value.toFixed(0);
    this.needsUpdate = true;
  }
  /**
   * Sets the depth buffer that will be compared with the base depth buffer.
   *
   * @deprecated Use depthBuffer1 and depthPacking1 instead.
   * @param {Texture} buffer - The depth texture.
   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing strategy.
   */
  setDepthBuffer1(buffer, depthPacking = BasicDepthPacking) {
    this.depthBuffer1 = buffer;
    this.depthPacking1 = depthPacking;
  }
  /**
   * The strategy for handling maximum depth.
   *
   * @type {DepthTestStrategy}
   */
  get maxDepthStrategy() {
    return Number(this.defines.DEPTH_TEST_STRATEGY);
  }
  set maxDepthStrategy(value) {
    this.defines.DEPTH_TEST_STRATEGY = value.toFixed(0);
    this.needsUpdate = true;
  }
  /**
   * Indicates whether maximum depth values should be preserved.
   *
   * @type {Boolean}
   * @deprecated Use maxDepthStrategy instead.
   */
  get keepFar() {
    return this.maxDepthStrategy;
  }
  set keepFar(value) {
    this.maxDepthStrategy = value ? DepthTestStrategy.KEEP_MAX_DEPTH : DepthTestStrategy.DISCARD_MAX_DEPTH;
  }
  /**
   * Returns the strategy for dealing with maximum depth values.
   *
   * @deprecated Use maxDepthStrategy instead.
   * @return {DepthTestStrategy} The strategy.
   */
  getMaxDepthStrategy() {
    return this.maxDepthStrategy;
  }
  /**
   * Sets the strategy for dealing with maximum depth values.
   *
   * @deprecated Use maxDepthStrategy instead.
   * @param {DepthTestStrategy} value - The strategy.
   */
  setMaxDepthStrategy(value) {
    this.maxDepthStrategy = value;
  }
  /**
   * A small error threshold that is used for `EqualDepth` and `NotEqualDepth` tests. Default is `1e-4`.
   *
   * @type {Number}
   */
  get epsilon() {
    return Number(this.defines.DEPTH_EPSILON);
  }
  set epsilon(value) {
    this.defines.DEPTH_EPSILON = value.toFixed(16);
    this.needsUpdate = true;
  }
  /**
   * Returns the current error threshold for depth comparisons.
   *
   * @deprecated Use epsilon instead.
   * @return {Number} The error threshold.
   */
  getEpsilon() {
    return this.epsilon;
  }
  /**
   * Sets the depth comparison error threshold.
   *
   * @deprecated Use epsilon instead.
   * @param {Number} value - The new error threshold.
   */
  setEpsilon(value) {
    this.epsilon = value;
  }
  /**
   * The depth mode.
   *
   * @see https://threejs.org/docs/#api/en/constants/Materials
   * @type {DepthModes}
   */
  get depthMode() {
    return Number(this.defines.DEPTH_MODE);
  }
  set depthMode(value) {
    let depthTest;
    switch (value) {
      case NeverDepth:
        depthTest = "false";
        break;
      case AlwaysDepth:
        depthTest = "true";
        break;
      case EqualDepth:
        depthTest = "abs(d1 - d0) <= DEPTH_EPSILON";
        break;
      case NotEqualDepth:
        depthTest = "abs(d1 - d0) > DEPTH_EPSILON";
        break;
      case LessDepth:
        depthTest = "d0 > d1";
        break;
      case LessEqualDepth:
        depthTest = "d0 >= d1";
        break;
      case GreaterEqualDepth:
        depthTest = "d0 <= d1";
        break;
      case GreaterDepth:
      default:
        depthTest = "d0 < d1";
        break;
    }
    this.defines.DEPTH_MODE = value.toFixed(0);
    this.defines["depthTest(d0, d1)"] = depthTest;
    this.needsUpdate = true;
  }
  /**
   * Returns the current depth mode.
   *
   * @deprecated Use depthMode instead.
   * @return {DepthModes} The depth mode. Default is `LessDepth`.
   */
  getDepthMode() {
    return this.depthMode;
  }
  /**
   * Sets the depth mode.
   *
   * @deprecated Use depthMode instead.
   * @param {DepthModes} mode - The depth mode.
   */
  setDepthMode(mode) {
    this.depthMode = mode;
  }
  /**
   * Copies the settings of the given camera.
   *
   * @deprecated Use copyCameraSettings instead.
   * @param {Camera} camera - A camera.
   */
  adoptCameraSettings(camera) {
    this.copyCameraSettings(camera);
  }
  /**
   * Copies the settings of the given camera.
   *
   * @param {Camera} camera - A camera.
   */
  copyCameraSettings(camera) {
    if (camera) {
      this.uniforms.cameraNearFar.value.set(camera.near, camera.far);
      if (camera instanceof PerspectiveCamera) {
        this.defines.PERSPECTIVE_CAMERA = "1";
      } else {
        delete this.defines.PERSPECTIVE_CAMERA;
      }
      this.needsUpdate = true;
    }
  }
};
var RenderPass = class extends Pass {
  /**
   * Constructs a new render pass.
   *
   * @param {Scene} scene - The scene to render.
   * @param {Camera} camera - The camera to use to render the scene.
   * @param {Material} [overrideMaterial=null] - An override material.
   */
  constructor(scene, camera, overrideMaterial = null) {
    super("RenderPass", scene, camera);
    this.needsSwap = false;
    this.clearPass = new ClearPass();
    this.overrideMaterialManager = overrideMaterial === null ? null : new OverrideMaterialManager(overrideMaterial);
    this.ignoreBackground = false;
    this.skipShadowMapUpdate = false;
    this.selection = null;
  }
  set mainScene(value) {
    this.scene = value;
  }
  set mainCamera(value) {
    this.camera = value;
  }
  get renderToScreen() {
    return super.renderToScreen;
  }
  set renderToScreen(value) {
    super.renderToScreen = value;
    this.clearPass.renderToScreen = value;
  }
  /**
   * The current override material.
   *
   * @type {Material}
   */
  get overrideMaterial() {
    const manager = this.overrideMaterialManager;
    return manager !== null ? manager.material : null;
  }
  set overrideMaterial(value) {
    const manager = this.overrideMaterialManager;
    if (value !== null) {
      if (manager !== null) {
        manager.setMaterial(value);
      } else {
        this.overrideMaterialManager = new OverrideMaterialManager(value);
      }
    } else if (manager !== null) {
      manager.dispose();
      this.overrideMaterialManager = null;
    }
  }
  /**
   * Returns the current override material.
   *
   * @deprecated Use overrideMaterial instead.
   * @return {Material} The material.
   */
  getOverrideMaterial() {
    return this.overrideMaterial;
  }
  /**
   * Sets the override material.
   *
   * @deprecated Use overrideMaterial instead.
   * @return {Material} value - The material.
   */
  setOverrideMaterial(value) {
    this.overrideMaterial = value;
  }
  /**
   * Indicates whether the target buffer should be cleared before rendering.
   *
   * @type {Boolean}
   * @deprecated Use clearPass.enabled instead.
   */
  get clear() {
    return this.clearPass.enabled;
  }
  set clear(value) {
    this.clearPass.enabled = value;
  }
  /**
   * Returns the selection. Default is `null` (no restriction).
   *
   * @deprecated Use selection instead.
   * @return {Selection} The selection.
   */
  getSelection() {
    return this.selection;
  }
  /**
   * Sets the selection. Set to `null` to disable.
   *
   * @deprecated Use selection instead.
   * @param {Selection} value - The selection.
   */
  setSelection(value) {
    this.selection = value;
  }
  /**
   * Indicates whether the scene background is disabled.
   *
   * @deprecated Use ignoreBackground instead.
   * @return {Boolean} Whether the scene background is disabled.
   */
  isBackgroundDisabled() {
    return this.ignoreBackground;
  }
  /**
   * Enables or disables the scene background.
   *
   * @deprecated Use ignoreBackground instead.
   * @param {Boolean} value - Whether the scene background should be disabled.
   */
  setBackgroundDisabled(value) {
    this.ignoreBackground = value;
  }
  /**
   * Indicates whether the shadow map auto update is disabled.
   *
   * @deprecated Use skipShadowMapUpdate instead.
   * @return {Boolean} Whether the shadow map update is disabled.
   */
  isShadowMapDisabled() {
    return this.skipShadowMapUpdate;
  }
  /**
   * Enables or disables the shadow map auto update.
   *
   * @deprecated Use skipShadowMapUpdate instead.
   * @param {Boolean} value - Whether the shadow map auto update should be disabled.
   */
  setShadowMapDisabled(value) {
    this.skipShadowMapUpdate = value;
  }
  /**
   * Returns the clear pass.
   *
   * @deprecated Use clearPass.enabled instead.
   * @return {ClearPass} The clear pass.
   */
  getClearPass() {
    return this.clearPass;
  }
  /**
   * Renders the scene.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.
   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.
   */
  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {
    const scene = this.scene;
    const camera = this.camera;
    const selection = this.selection;
    const mask = camera.layers.mask;
    const background = scene.background;
    const shadowMapAutoUpdate = renderer.shadowMap.autoUpdate;
    const renderTarget = this.renderToScreen ? null : inputBuffer;
    if (selection !== null) {
      camera.layers.set(selection.getLayer());
    }
    if (this.skipShadowMapUpdate) {
      renderer.shadowMap.autoUpdate = false;
    }
    if (this.ignoreBackground || this.clearPass.overrideClearColor !== null) {
      scene.background = null;
    }
    if (this.clearPass.enabled) {
      this.clearPass.render(renderer, inputBuffer);
    }
    renderer.setRenderTarget(renderTarget);
    if (this.overrideMaterialManager !== null) {
      this.overrideMaterialManager.render(renderer, scene, camera);
    } else {
      renderer.render(scene, camera);
    }
    camera.layers.mask = mask;
    scene.background = background;
    renderer.shadowMap.autoUpdate = shadowMapAutoUpdate;
  }
};
var v = new Vector3();
var m = new Matrix4();
var c = new Color();
var DepthCopyMode = {
  FULL: 0,
  SINGLE: 1
};
var HALF_PI = Math.PI * 0.5;
var v2 = new Vector3();
var ab = new Vector3();
var depth_copy_default = `#include <packing>
varying vec2 vUv;
#ifdef NORMAL_DEPTH
#ifdef GL_FRAGMENT_PRECISION_HIGH
uniform highp sampler2D normalDepthBuffer;
#else
uniform mediump sampler2D normalDepthBuffer;
#endif
float readDepth(const in vec2 uv){return texture2D(normalDepthBuffer,uv).a;}
#else
#if INPUT_DEPTH_PACKING == 3201
uniform lowp sampler2D depthBuffer;
#elif defined(GL_FRAGMENT_PRECISION_HIGH)
uniform highp sampler2D depthBuffer;
#else
uniform mediump sampler2D depthBuffer;
#endif
float readDepth(const in vec2 uv){
#if INPUT_DEPTH_PACKING == 3201
return unpackRGBAToDepth(texture2D(depthBuffer,uv));
#else
return texture2D(depthBuffer,uv).r;
#endif
}
#endif
void main(){
#if INPUT_DEPTH_PACKING == OUTPUT_DEPTH_PACKING
gl_FragColor=texture2D(depthBuffer,vUv);
#else
float depth=readDepth(vUv);
#if OUTPUT_DEPTH_PACKING == 3201
gl_FragColor=(depth==1.0)?vec4(1.0):packDepthToRGBA(depth);
#else
gl_FragColor=vec4(vec3(depth),1.0);
#endif
#endif
}`;
var depth_copy_default2 = `varying vec2 vUv;
#if DEPTH_COPY_MODE == 1
uniform vec2 texelPosition;
#endif
void main(){
#if DEPTH_COPY_MODE == 1
vUv=texelPosition;
#else
vUv=position.xy*0.5+0.5;
#endif
gl_Position=vec4(position.xy,1.0,1.0);}`;
var DepthCopyMaterial = class extends ShaderMaterial {
  /**
   * Constructs a new depth copy material.
   */
  constructor() {
    super({
      name: "DepthCopyMaterial",
      defines: {
        INPUT_DEPTH_PACKING: "0",
        OUTPUT_DEPTH_PACKING: "0",
        DEPTH_COPY_MODE: "0"
      },
      uniforms: {
        depthBuffer: new Uniform(null),
        texelPosition: new Uniform(new Vector2())
      },
      blending: NoBlending,
      toneMapped: false,
      depthWrite: false,
      depthTest: false,
      fragmentShader: depth_copy_default,
      vertexShader: depth_copy_default2
    });
    this.depthCopyMode = DepthCopyMode.FULL;
  }
  /**
   * The input depth buffer.
   *
   * @type {Texture}
   */
  get depthBuffer() {
    return this.uniforms.depthBuffer.value;
  }
  set depthBuffer(value) {
    this.uniforms.depthBuffer.value = value;
  }
  /**
   * The input depth packing strategy.
   *
   * @type {DepthPackingStrategies}
   */
  set inputDepthPacking(value) {
    this.defines.INPUT_DEPTH_PACKING = value.toFixed(0);
    this.needsUpdate = true;
  }
  /**
   * The output depth packing strategy.
   *
   * @type {DepthPackingStrategies}
   */
  get outputDepthPacking() {
    return Number(this.defines.OUTPUT_DEPTH_PACKING);
  }
  set outputDepthPacking(value) {
    this.defines.OUTPUT_DEPTH_PACKING = value.toFixed(0);
    this.needsUpdate = true;
  }
  /**
   * Sets the input depth buffer.
   *
   * @deprecated Use depthBuffer and inputDepthPacking instead.
   * @param {Texture} buffer - The depth texture.
   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing strategy.
   */
  setDepthBuffer(buffer, depthPacking = BasicDepthPacking) {
    this.depthBuffer = buffer;
    this.inputDepthPacking = depthPacking;
  }
  /**
   * Returns the current input depth packing strategy.
   *
   * @deprecated
   * @return {DepthPackingStrategies} The input depth packing strategy.
   */
  getInputDepthPacking() {
    return Number(this.defines.INPUT_DEPTH_PACKING);
  }
  /**
   * Sets the input depth packing strategy.
   *
   * @deprecated Use inputDepthPacking instead.
   * @param {DepthPackingStrategies} value - The new input depth packing strategy.
   */
  setInputDepthPacking(value) {
    this.defines.INPUT_DEPTH_PACKING = value.toFixed(0);
    this.needsUpdate = true;
  }
  /**
   * Returns the current output depth packing strategy.
   *
   * @deprecated Use outputDepthPacking instead.
   * @return {DepthPackingStrategies} The output depth packing strategy.
   */
  getOutputDepthPacking() {
    return Number(this.defines.OUTPUT_DEPTH_PACKING);
  }
  /**
   * Sets the output depth packing strategy.
   *
   * @deprecated Use outputDepthPacking instead.
   * @param {DepthPackingStrategies} value - The new output depth packing strategy.
   */
  setOutputDepthPacking(value) {
    this.defines.OUTPUT_DEPTH_PACKING = value.toFixed(0);
    this.needsUpdate = true;
  }
  /**
   * The screen space position used for single-texel copy operations.
   *
   * @type {Vector2}
   */
  get texelPosition() {
    return this.uniforms.texelPosition.value;
  }
  /**
   * Returns the screen space position used for single-texel copy operations.
   *
   * @deprecated Use texelPosition instead.
   * @return {Vector2} The position.
   */
  getTexelPosition() {
    return this.uniforms.texelPosition.value;
  }
  /**
   * Sets the screen space position used for single-texel copy operations.
   *
   * @deprecated
   * @param {Vector2} value - The position.
   */
  setTexelPosition(value) {
    this.uniforms.texelPosition.value = value;
  }
  /**
   * The depth copy mode.
   *
   * @type {DepthCopyMode}
   */
  get mode() {
    return this.depthCopyMode;
  }
  set mode(value) {
    this.depthCopyMode = value;
    this.defines.DEPTH_COPY_MODE = value.toFixed(0);
    this.needsUpdate = true;
  }
  /**
   * Returns the depth copy mode.
   *
   * @deprecated Use mode instead.
   * @return {DepthCopyMode} The depth copy mode.
   */
  getMode() {
    return this.mode;
  }
  /**
   * Sets the depth copy mode.
   *
   * @deprecated Use mode instead.
   * @param {DepthCopyMode} value - The new mode.
   */
  setMode(value) {
    this.mode = value;
  }
};
var DepthCopyPass = class extends Pass {
  /**
   * Constructs a new depth save pass.
   *
   * @param {Object} [options] - The options.
   * @param {DepthPackingStrategies} [options.depthPacking=RGBADepthPacking] - The output depth packing.
   */
  constructor({ depthPacking = RGBADepthPacking } = {}) {
    super("DepthCopyPass");
    const material = new DepthCopyMaterial();
    material.outputDepthPacking = depthPacking;
    this.fullscreenMaterial = material;
    this.needsDepthTexture = true;
    this.needsSwap = false;
    this.renderTarget = new WebGLRenderTarget(1, 1, {
      type: depthPacking === RGBADepthPacking ? UnsignedByteType : FloatType,
      minFilter: NearestFilter,
      magFilter: NearestFilter,
      depthBuffer: false
    });
    this.renderTarget.texture.name = "DepthCopyPass.Target";
  }
  /**
   * The output depth texture.
   *
   * @type {Texture}
   */
  get texture() {
    return this.renderTarget.texture;
  }
  /**
   * Returns the output depth texture.
   *
   * @deprecated Use texture instead.
   * @return {Texture} The texture.
   */
  getTexture() {
    return this.renderTarget.texture;
  }
  /**
   * The output depth packing.
   *
   * @type {DepthPackingStrategies}
   */
  get depthPacking() {
    return this.fullscreenMaterial.outputDepthPacking;
  }
  /**
   * Returns the output depth packing.
   *
   * @deprecated Use depthPacking instead.
   * @return {DepthPackingStrategies} The depth packing.
   */
  getDepthPacking() {
    return this.fullscreenMaterial.outputDepthPacking;
  }
  /**
   * Sets the depth texture.
   *
   * @param {Texture} depthTexture - A depth texture.
   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing.
   */
  setDepthTexture(depthTexture, depthPacking = BasicDepthPacking) {
    this.fullscreenMaterial.depthBuffer = depthTexture;
    this.fullscreenMaterial.inputDepthPacking = depthPacking;
  }
  /**
   * Copies depth from a depth texture.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.
   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.
   */
  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {
    renderer.setRenderTarget(this.renderToScreen ? null : this.renderTarget);
    renderer.render(this.scene, this.camera);
  }
  /**
   * Updates the size of this pass.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
    this.renderTarget.setSize(width, height);
  }
};
var threeRevision = Number(REVISION.replace(/\D+/g, ""));
var unpackDownscale = 255 / 256;
var unpackFactorsLegacy = new Float32Array([
  unpackDownscale / 256 ** 3,
  unpackDownscale / 256 ** 2,
  unpackDownscale / 256,
  unpackDownscale
]);
var unpackFactors = new Float32Array([
  unpackDownscale,
  unpackDownscale / 256,
  unpackDownscale / 256 ** 2,
  1 / 256 ** 3
]);
var P = [
  new Float32Array(3),
  new Float32Array(3)
];
var C2 = [
  new Float32Array(3),
  new Float32Array(3),
  new Float32Array(3),
  new Float32Array(3)
];
var T = [
  [
    new Float32Array([0, 0, 0]),
    new Float32Array([1, 0, 0]),
    new Float32Array([1, 1, 0]),
    new Float32Array([1, 1, 1])
  ],
  [
    new Float32Array([0, 0, 0]),
    new Float32Array([1, 0, 0]),
    new Float32Array([1, 0, 1]),
    new Float32Array([1, 1, 1])
  ],
  [
    new Float32Array([0, 0, 0]),
    new Float32Array([0, 0, 1]),
    new Float32Array([1, 0, 1]),
    new Float32Array([1, 1, 1])
  ],
  [
    new Float32Array([0, 0, 0]),
    new Float32Array([0, 1, 0]),
    new Float32Array([1, 1, 0]),
    new Float32Array([1, 1, 1])
  ],
  [
    new Float32Array([0, 0, 0]),
    new Float32Array([0, 1, 0]),
    new Float32Array([0, 1, 1]),
    new Float32Array([1, 1, 1])
  ],
  [
    new Float32Array([0, 0, 0]),
    new Float32Array([0, 0, 1]),
    new Float32Array([0, 1, 1]),
    new Float32Array([1, 1, 1])
  ]
];
var area = [
  new Float32Array(2),
  new Float32Array(2)
];
var orthogonalSubsamplingOffsets = new Float32Array([
  0,
  -0.25,
  0.25,
  -0.125,
  0.125,
  -0.375,
  0.375
]);
var diagonalSubsamplingOffsets = [
  new Float32Array([0, 0]),
  new Float32Array([0.25, -0.25]),
  new Float32Array([-0.25, 0.25]),
  new Float32Array([0.125, -0.125]),
  new Float32Array([-0.125, 0.125])
];
var orthogonalEdges = [
  new Uint8Array([0, 0]),
  new Uint8Array([3, 0]),
  new Uint8Array([0, 3]),
  new Uint8Array([3, 3]),
  new Uint8Array([1, 0]),
  new Uint8Array([4, 0]),
  new Uint8Array([1, 3]),
  new Uint8Array([4, 3]),
  new Uint8Array([0, 1]),
  new Uint8Array([3, 1]),
  new Uint8Array([0, 4]),
  new Uint8Array([3, 4]),
  new Uint8Array([1, 1]),
  new Uint8Array([4, 1]),
  new Uint8Array([1, 4]),
  new Uint8Array([4, 4])
];
var diagonalEdges = [
  new Uint8Array([0, 0]),
  new Uint8Array([1, 0]),
  new Uint8Array([0, 2]),
  new Uint8Array([1, 2]),
  new Uint8Array([2, 0]),
  new Uint8Array([3, 0]),
  new Uint8Array([2, 2]),
  new Uint8Array([3, 2]),
  new Uint8Array([0, 1]),
  new Uint8Array([1, 1]),
  new Uint8Array([0, 3]),
  new Uint8Array([1, 3]),
  new Uint8Array([2, 1]),
  new Uint8Array([3, 1]),
  new Uint8Array([2, 3]),
  new Uint8Array([3, 3])
];
var edges = /* @__PURE__ */ new Map([
  [bilinear(0, 0, 0, 0), new Float32Array([0, 0, 0, 0])],
  [bilinear(0, 0, 0, 1), new Float32Array([0, 0, 0, 1])],
  [bilinear(0, 0, 1, 0), new Float32Array([0, 0, 1, 0])],
  [bilinear(0, 0, 1, 1), new Float32Array([0, 0, 1, 1])],
  [bilinear(0, 1, 0, 0), new Float32Array([0, 1, 0, 0])],
  [bilinear(0, 1, 0, 1), new Float32Array([0, 1, 0, 1])],
  [bilinear(0, 1, 1, 0), new Float32Array([0, 1, 1, 0])],
  [bilinear(0, 1, 1, 1), new Float32Array([0, 1, 1, 1])],
  [bilinear(1, 0, 0, 0), new Float32Array([1, 0, 0, 0])],
  [bilinear(1, 0, 0, 1), new Float32Array([1, 0, 0, 1])],
  [bilinear(1, 0, 1, 0), new Float32Array([1, 0, 1, 0])],
  [bilinear(1, 0, 1, 1), new Float32Array([1, 0, 1, 1])],
  [bilinear(1, 1, 0, 0), new Float32Array([1, 1, 0, 0])],
  [bilinear(1, 1, 0, 1), new Float32Array([1, 1, 0, 1])],
  [bilinear(1, 1, 1, 0), new Float32Array([1, 1, 1, 0])],
  [bilinear(1, 1, 1, 1), new Float32Array([1, 1, 1, 1])]
]);
function lerp2(a2, b3, p3) {
  return a2 + (b3 - a2) * p3;
}
function bilinear(e02, e1, e22, e3) {
  const a2 = lerp2(e02, e1, 1 - 0.25);
  const b3 = lerp2(e22, e3, 1 - 0.25);
  return lerp2(a2, b3, 1 - 0.125);
}

// node_modules/@takram/three-geospatial/build/shaders.js
var n = `// Reference: https://github.com/mrdoob/three.js/blob/r171/examples/jsm/csm/CSMShader.js

#ifndef SHADOW_CASCADE_COUNT
#error "SHADOW_CASCADE_COUNT macro must be defined."
#endif // SHADOW_CASCADE_COUNT

int getCascadeIndex(
  const mat4 viewMatrix,
  const vec3 worldPosition,
  const vec2 intervals[SHADOW_CASCADE_COUNT],
  const float near,
  const float far
) {
  vec4 viewPosition = viewMatrix * vec4(worldPosition, 1.0);
  float depth = viewZToOrthographicDepth(viewPosition.z, near, far);
  vec2 interval;
  #pragma unroll_loop_start
  for (int i = 0; i < 4; ++i) {
    #if UNROLLED_LOOP_INDEX < SHADOW_CASCADE_COUNT
    interval = intervals[i];
    if (depth >= interval.x && depth < interval.y) {
      return UNROLLED_LOOP_INDEX;
    }
    #endif // UNROLLED_LOOP_INDEX < SHADOW_CASCADE_COUNT
  }
  #pragma unroll_loop_end
  return SHADOW_CASCADE_COUNT - 1;
}

int getFadedCascadeIndex(
  const mat4 viewMatrix,
  const vec3 worldPosition,
  const vec2 intervals[SHADOW_CASCADE_COUNT],
  const float near,
  const float far,
  const float jitter
) {
  vec4 viewPosition = viewMatrix * vec4(worldPosition, 1.0);
  float depth = viewZToOrthographicDepth(viewPosition.z, near, far);

  vec2 interval;
  float intervalCenter;
  float closestEdge;
  float margin;
  int nextIndex = -1;
  int prevIndex = -1;
  float alpha;

  #pragma unroll_loop_start
  for (int i = 0; i < 4; ++i) {
    #if UNROLLED_LOOP_INDEX < SHADOW_CASCADE_COUNT
    interval = intervals[i];
    intervalCenter = (interval.x + interval.y) * 0.5;
    closestEdge = depth < intervalCenter ? interval.x : interval.y;
    margin = closestEdge * closestEdge * 0.5;
    interval += margin * vec2(-0.5, 0.5);

    #if UNROLLED_LOOP_INDEX < SHADOW_CASCADE_COUNT - 1
    if (depth >= interval.x && depth < interval.y) {
      prevIndex = nextIndex;
      nextIndex = UNROLLED_LOOP_INDEX;
      alpha = saturate(min(depth - interval.x, interval.y - depth) / margin);
    }
    #else // UNROLLED_LOOP_INDEX < SHADOW_CASCADE_COUNT - 1
    // Don't fade out the last cascade.
    if (depth >= interval.x) {
      prevIndex = nextIndex;
      nextIndex = UNROLLED_LOOP_INDEX;
      alpha = saturate((depth - interval.x) / margin);
    }
    #endif // UNROLLED_LOOP_INDEX < SHADOW_CASCADE_COUNT - 1
    #endif // UNROLLED_LOOP_INDEX < SHADOW_CASCADE_COUNT
  }
  #pragma unroll_loop_end

  return jitter <= alpha
    ? nextIndex
    : prevIndex;
}
`;
var e = `// cSpell:words logdepthbuf

float reverseLogDepth(const float depth, const float near, const float far) {
  #ifdef USE_LOGDEPTHBUF
  float d = pow(2.0, depth * log2(far + 1.0)) - 1.0;
  float a = far / (far - near);
  float b = far * near / (near - far);
  return a + b / d;
  #else // USE_LOGDEPTHBUF
  return depth;
  #endif // USE_LOGDEPTHBUF
}

float linearizeDepth(const float depth, const float near, const float far) {
  float ndc = depth * 2.0 - 1.0;
  return 2.0 * near * far / (far + near - ndc * (far - near));
}
`;
var c2 = `// Reference: https://advances.realtimerendering.com/s2014/index.html#_NEXT_GENERATION_POST

float interleavedGradientNoise(const vec2 coord) {
  const vec3 magic = vec3(0.06711056, 0.00583715, 52.9829189);
  return fract(magic.z * fract(dot(coord, magic.xy)));
}
`;
var i = `#if !defined(saturate)
#define saturate(a) clamp(a, 0.0, 1.0)
#endif // !defined(saturate)

float remap(const float x, const float min1, const float max1, const float min2, const float max2) {
  return min2 + (x - min1) / (max1 - min1) * (max2 - min2);
}

vec2 remap(const vec2 x, const vec2 min1, const vec2 max1, const vec2 min2, const vec2 max2) {
  return min2 + (x - min1) / (max1 - min1) * (max2 - min2);
}

vec3 remap(const vec3 x, const vec3 min1, const vec3 max1, const vec3 min2, const vec3 max2) {
  return min2 + (x - min1) / (max1 - min1) * (max2 - min2);
}

vec4 remap(const vec4 x, const vec4 min1, const vec4 max1, const vec4 min2, const vec4 max2) {
  return min2 + (x - min1) / (max1 - min1) * (max2 - min2);
}

float remapClamped(
  const float x,
  const float min1,
  const float max1,
  const float min2,
  const float max2
) {
  return clamp(min2 + (x - min1) / (max1 - min1) * (max2 - min2), min2, max2);
}

vec2 remapClamped(
  const vec2 x,
  const vec2 min1,
  const vec2 max1,
  const vec2 min2,
  const vec2 max2
) {
  return clamp(min2 + (x - min1) / (max1 - min1) * (max2 - min2), min2, max2);
}

vec3 remapClamped(
  const vec3 x,
  const vec3 min1,
  const vec3 max1,
  const vec3 min2,
  const vec3 max2
) {
  return clamp(min2 + (x - min1) / (max1 - min1) * (max2 - min2), min2, max2);
}

vec4 remapClamped(
  const vec4 x,
  const vec4 min1,
  const vec4 max1,
  const vec4 min2,
  const vec4 max2
) {
  return clamp(min2 + (x - min1) / (max1 - min1) * (max2 - min2), min2, max2);
}

// Implicitly remap to 0 and 1
float remap(const float x, const float min1, const float max1) {
  return (x - min1) / (max1 - min1);
}

vec2 remap(const vec2 x, const vec2 min1, const vec2 max1) {
  return (x - min1) / (max1 - min1);
}

vec3 remap(const vec3 x, const vec3 min1, const vec3 max1) {
  return (x - min1) / (max1 - min1);
}

vec4 remap(const vec4 x, const vec4 min1, const vec4 max1) {
  return (x - min1) / (max1 - min1);
}

float remapClamped(const float x, const float min1, const float max1) {
  return saturate((x - min1) / (max1 - min1));
}

vec2 remapClamped(const vec2 x, const vec2 min1, const vec2 max1) {
  return saturate((x - min1) / (max1 - min1));
}

vec3 remapClamped(const vec3 x, const vec3 min1, const vec3 max1) {
  return saturate((x - min1) / (max1 - min1));
}

vec4 remapClamped(const vec4 x, const vec4 min1, const vec4 max1) {
  return saturate((x - min1) / (max1 - min1));
}
`;
var o = `// Reference: https://jcgt.org/published/0003/02/01/paper.pdf

vec2 signNotZero(vec2 v) {
  return vec2(v.x >= 0.0 ? 1.0 : -1.0, v.y >= 0.0 ? 1.0 : -1.0);
}

vec2 packNormalToVec2(vec3 v) {
  vec2 p = v.xy * (1.0 / (abs(v.x) + abs(v.y) + abs(v.z)));
  return v.z <= 0.0
    ? (1.0 - abs(p.yx)) * signNotZero(p)
    : p;
}

vec3 unpackVec2ToNormal(vec2 e) {
  vec3 v = vec3(e.xy, 1.0 - abs(e.x) - abs(e.y));
  if (v.z < 0.0) {
    v.xy = (1.0 - abs(v.yx)) * signNotZero(v.xy);
  }
  return normalize(v);
}
`;
var r = `float raySphereFirstIntersection(
  const vec3 origin,
  const vec3 direction,
  const vec3 center,
  const float radius
) {
  vec3 a = origin - center;
  float b = 2.0 * dot(direction, a);
  float c = dot(a, a) - radius * radius;
  float discriminant = b * b - 4.0 * c;
  return discriminant < 0.0
    ? -1.0
    : (-b - sqrt(discriminant)) * 0.5;
}

float raySphereFirstIntersection(const vec3 origin, const vec3 direction, const float radius) {
  return raySphereFirstIntersection(origin, direction, vec3(0.0), radius);
}

vec4 raySphereFirstIntersection(
  const vec3 origin,
  const vec3 direction,
  const vec3 center,
  const vec4 radius
) {
  vec3 a = origin - center;
  float b = 2.0 * dot(direction, a);
  vec4 c = dot(a, a) - radius * radius;
  vec4 discriminant = b * b - 4.0 * c;
  vec4 mask = step(discriminant, vec4(0.0));
  return mix((-b - sqrt(max(vec4(0.0), discriminant))) * 0.5, vec4(-1.0), mask);
}

vec4 raySphereFirstIntersection(const vec3 origin, const vec3 direction, const vec4 radius) {
  return raySphereFirstIntersection(origin, direction, vec3(0.0), radius);
}

float raySphereSecondIntersection(
  const vec3 origin,
  const vec3 direction,
  const vec3 center,
  const float radius
) {
  vec3 a = origin - center;
  float b = 2.0 * dot(direction, a);
  float c = dot(a, a) - radius * radius;
  float discriminant = b * b - 4.0 * c;
  return discriminant < 0.0
    ? -1.0
    : (-b + sqrt(discriminant)) * 0.5;
}

float raySphereSecondIntersection(const vec3 origin, const vec3 direction, const float radius) {
  return raySphereSecondIntersection(origin, direction, vec3(0.0), radius);
}

vec4 raySphereSecondIntersection(
  const vec3 origin,
  const vec3 direction,
  const vec3 center,
  const vec4 radius
) {
  vec3 a = origin - center;
  float b = 2.0 * dot(direction, a);
  vec4 c = dot(a, a) - radius * radius;
  vec4 discriminant = b * b - 4.0 * c;
  vec4 mask = step(discriminant, vec4(0.0));
  return mix((-b + sqrt(max(vec4(0.0), discriminant))) * 0.5, vec4(-1.0), mask);
}

vec4 raySphereSecondIntersection(const vec3 origin, const vec3 direction, const vec4 radius) {
  return raySphereSecondIntersection(origin, direction, vec3(0.0), radius);
}

void raySphereIntersections(
  const vec3 origin,
  const vec3 direction,
  const vec3 center,
  const float radius,
  out float intersection1,
  out float intersection2
) {
  vec3 a = origin - center;
  float b = 2.0 * dot(direction, a);
  float c = dot(a, a) - radius * radius;
  float discriminant = b * b - 4.0 * c;
  if (discriminant < 0.0) {
    intersection1 = -1.0;
    intersection2 = -1.0;
    return;
  } else {
    float Q = sqrt(discriminant);
    intersection1 = (-b - Q) * 0.5;
    intersection2 = (-b + Q) * 0.5;
  }
}

void raySphereIntersections(
  const vec3 origin,
  const vec3 direction,
  const float radius,
  out float intersection1,
  out float intersection2
) {
  raySphereIntersections(origin, direction, vec3(0.0), radius, intersection1, intersection2);
}

void raySphereIntersections(
  const vec3 origin,
  const vec3 direction,
  const vec3 center,
  const vec4 radius,
  out vec4 intersection1,
  out vec4 intersection2
) {
  vec3 a = origin - center;
  float b = 2.0 * dot(direction, a);
  vec4 c = dot(a, a) - radius * radius;
  vec4 discriminant = b * b - 4.0 * c;
  vec4 mask = step(discriminant, vec4(0.0));
  vec4 Q = sqrt(max(vec4(0.0), discriminant));
  intersection1 = mix((-b - Q) * 0.5, vec4(-1.0), mask);
  intersection2 = mix((-b + Q) * 0.5, vec4(-1.0), mask);
}

void raySphereIntersections(
  const vec3 origin,
  const vec3 direction,
  const vec4 radius,
  out vec4 intersection1,
  out vec4 intersection2
) {
  raySphereIntersections(origin, direction, vec3(0.0), radius, intersection1, intersection2);
}
`;
var a = `vec3 screenToView(
  const vec2 uv,
  const float depth,
  const float viewZ,
  const mat4 projectionMatrix,
  const mat4 inverseProjectionMatrix
) {
  vec4 clip = vec4(vec3(uv, depth) * 2.0 - 1.0, 1.0);
  float clipW = projectionMatrix[2][3] * viewZ + projectionMatrix[3][3];
  clip *= clipW;
  return (inverseProjectionMatrix * clip).xyz;
}
`;
var v3 = `// Reference: https://www.gamedev.net/tutorials/programming/graphics/contact-hardening-soft-shadows-made-fast-r4906/

vec2 vogelDisk(const int index, const int sampleCount, const float phi) {
  const float goldenAngle = 2.39996322972865332;
  float r = sqrt(float(index) + 0.5) / sqrt(float(sampleCount));
  float theta = float(index) * goldenAngle + phi;
  return r * vec2(cos(theta), sin(theta));
}
`;
var m2 = n;
var d = e;
var x = c2;
var f = i;
var p = o;
var u = r;
var h = a;
var _ = v3;

// node_modules/@takram/three-atmosphere/build/shared2.js
var e2 = `// Based on: https://github.com/ebruneton/precomputed_atmospheric_scattering/blob/master/atmosphere/functions.glsl

/**
 * Copyright (c) 2017 Eric Bruneton
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the copyright holders nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Precomputed Atmospheric Scattering
 * Copyright (c) 2008 INRIA
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the copyright holders nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

Number ClampCosine(const Number mu) {
  return clamp(mu, Number(-1.0), Number(1.0));
}

Length ClampDistance(const Length d) {
  return max(d, 0.0 * m);
}

Length ClampRadius(const AtmosphereParameters atmosphere, const Length r) {
  return clamp(r, atmosphere.bottom_radius, atmosphere.top_radius);
}

Length SafeSqrt(const Area a) {
  return sqrt(max(a, 0.0 * m2));
}

Length DistanceToTopAtmosphereBoundary(const AtmosphereParameters atmosphere,
    const Length r, const Number mu) {
  assert(r <= atmosphere.top_radius);
  assert(mu >= -1.0 && mu <= 1.0);
  Area discriminant = r * r * (mu * mu - 1.0) +
      atmosphere.top_radius * atmosphere.top_radius;
  return ClampDistance(-r * mu + SafeSqrt(discriminant));
}

Length DistanceToBottomAtmosphereBoundary(const AtmosphereParameters atmosphere,
    const Length r, const Number mu) {
  assert(r >= atmosphere.bottom_radius);
  assert(mu >= -1.0 && mu <= 1.0);
  Area discriminant = r * r * (mu * mu - 1.0) +
      atmosphere.bottom_radius * atmosphere.bottom_radius;
  return ClampDistance(-r * mu - SafeSqrt(discriminant));
}

bool RayIntersectsGround(const AtmosphereParameters atmosphere,
    const Length r, const Number mu) {
  assert(r >= atmosphere.bottom_radius);
  assert(mu >= -1.0 && mu <= 1.0);
  return mu < 0.0 && r * r * (mu * mu - 1.0) +
      atmosphere.bottom_radius * atmosphere.bottom_radius >= 0.0 * m2;
}

Number GetTextureCoordFromUnitRange(const Number x, const int texture_size) {
  return 0.5 / Number(texture_size) + x * (1.0 - 1.0 / Number(texture_size));
}

vec2 GetTransmittanceTextureUvFromRMu(const AtmosphereParameters atmosphere,
    const Length r, const Number mu) {
  assert(r >= atmosphere.bottom_radius && r <= atmosphere.top_radius);
  assert(mu >= -1.0 && mu <= 1.0);
  // Distance to top atmosphere boundary for a horizontal ray at ground level.
  Length H = sqrt(atmosphere.top_radius * atmosphere.top_radius -
      atmosphere.bottom_radius * atmosphere.bottom_radius);
  // Distance to the horizon.
  Length rho =
      SafeSqrt(r * r - atmosphere.bottom_radius * atmosphere.bottom_radius);
  // Distance to the top atmosphere boundary for the ray (r,mu), and its minimum
  // and maximum values over all mu - obtained for (r,1) and (r,mu_horizon).
  Length d = DistanceToTopAtmosphereBoundary(atmosphere, r, mu);
  Length d_min = atmosphere.top_radius - r;
  Length d_max = rho + H;
  Number x_mu = (d - d_min) / (d_max - d_min);
  Number x_r = rho / H;
  return vec2(GetTextureCoordFromUnitRange(x_mu, TRANSMITTANCE_TEXTURE_WIDTH),
              GetTextureCoordFromUnitRange(x_r, TRANSMITTANCE_TEXTURE_HEIGHT));
}

DimensionlessSpectrum GetTransmittanceToTopAtmosphereBoundary(
    const AtmosphereParameters atmosphere,
    const TransmittanceTexture transmittance_texture,
    const Length r, const Number mu) {
  assert(r >= atmosphere.bottom_radius && r <= atmosphere.top_radius);
  vec2 uv = GetTransmittanceTextureUvFromRMu(atmosphere, r, mu);
  // @shotamatsuda: Added for the precomputation stage in half-float precision.
  #ifdef TRANSMITTANCE_PRECISION_LOG
  // Manually interpolate the transmittance instead of the optical depth.
  const vec2 size = vec2(TRANSMITTANCE_TEXTURE_WIDTH, TRANSMITTANCE_TEXTURE_HEIGHT);
  const vec3 texel_size = vec3(1.0 / size, 0.0);
  vec2 coord = (uv * size) - 0.5;
  vec2 i = (floor(coord) + 0.5) * texel_size.xy;
  vec2 f = fract(coord);
  vec4 t1 = exp(-texture(transmittance_texture, i));
  vec4 t2 = exp(-texture(transmittance_texture, i + texel_size.xz));
  vec4 t3 = exp(-texture(transmittance_texture, i + texel_size.zy));
  vec4 t4 = exp(-texture(transmittance_texture, i + texel_size.xy));
  return DimensionlessSpectrum(mix(mix(t1, t2, f.x), mix(t3, t4, f.x), f.y));
  #else // TRANSMITTANCE_PRECISION_LOG
  return DimensionlessSpectrum(texture(transmittance_texture, uv));
  #endif // TRANSMITTANCE_PRECISION_LOG
}

DimensionlessSpectrum GetTransmittance(
    const AtmosphereParameters atmosphere,
    const TransmittanceTexture transmittance_texture,
    const Length r, const Number mu, const Length d,
    const bool ray_r_mu_intersects_ground) {
  assert(r >= atmosphere.bottom_radius && r <= atmosphere.top_radius);
  assert(mu >= -1.0 && mu <= 1.0);
  assert(d >= 0.0 * m);

  Length r_d = ClampRadius(atmosphere, sqrt(d * d + 2.0 * r * mu * d + r * r));
  Number mu_d = ClampCosine((r * mu + d) / r_d);

  if (ray_r_mu_intersects_ground) {
    return min(
        GetTransmittanceToTopAtmosphereBoundary(
            atmosphere, transmittance_texture, r_d, -mu_d) /
        GetTransmittanceToTopAtmosphereBoundary(
            atmosphere, transmittance_texture, r, -mu),
        DimensionlessSpectrum(1.0));
  } else {
    return min(
        GetTransmittanceToTopAtmosphereBoundary(
            atmosphere, transmittance_texture, r, mu) /
        GetTransmittanceToTopAtmosphereBoundary(
            atmosphere, transmittance_texture, r_d, mu_d),
        DimensionlessSpectrum(1.0));
  }
}

DimensionlessSpectrum GetTransmittanceToSun(
    const AtmosphereParameters atmosphere,
    const TransmittanceTexture transmittance_texture,
    const Length r, const Number mu_s) {
  Number sin_theta_h = atmosphere.bottom_radius / r;
  Number cos_theta_h = -sqrt(max(1.0 - sin_theta_h * sin_theta_h, 0.0));
  return GetTransmittanceToTopAtmosphereBoundary(
          atmosphere, transmittance_texture, r, mu_s) *
      smoothstep(-sin_theta_h * atmosphere.sun_angular_radius / rad,
                 sin_theta_h * atmosphere.sun_angular_radius / rad,
                 mu_s - cos_theta_h);
}

InverseSolidAngle RayleighPhaseFunction(const Number nu) {
  InverseSolidAngle k = 3.0 / (16.0 * PI * sr);
  return k * (1.0 + nu * nu);
}

InverseSolidAngle MiePhaseFunction(const Number g, const Number nu) {
  InverseSolidAngle k = 3.0 / (8.0 * PI * sr) * (1.0 - g * g) / (2.0 + g * g);
  return k * (1.0 + nu * nu) / pow(1.0 + g * g - 2.0 * g * nu, 1.5);
}

vec4 GetScatteringTextureUvwzFromRMuMuSNu(const AtmosphereParameters atmosphere,
    const Length r, const Number mu, const Number mu_s, const Number nu,
    const bool ray_r_mu_intersects_ground) {
  assert(r >= atmosphere.bottom_radius && r <= atmosphere.top_radius);
  assert(mu >= -1.0 && mu <= 1.0);
  assert(mu_s >= -1.0 && mu_s <= 1.0);
  assert(nu >= -1.0 && nu <= 1.0);

  // Distance to top atmosphere boundary for a horizontal ray at ground level.
  Length H = sqrt(atmosphere.top_radius * atmosphere.top_radius -
      atmosphere.bottom_radius * atmosphere.bottom_radius);
  // Distance to the horizon.
  Length rho =
      SafeSqrt(r * r - atmosphere.bottom_radius * atmosphere.bottom_radius);
  Number u_r = GetTextureCoordFromUnitRange(rho / H, SCATTERING_TEXTURE_R_SIZE);

  // Discriminant of the quadratic equation for the intersections of the ray
  // (r,mu) with the ground (see RayIntersectsGround).
  Length r_mu = r * mu;
  Area discriminant =
      r_mu * r_mu - r * r + atmosphere.bottom_radius * atmosphere.bottom_radius;
  Number u_mu;
  if (ray_r_mu_intersects_ground) {
    // Distance to the ground for the ray (r,mu), and its minimum and maximum
    // values over all mu - obtained for (r,-1) and (r,mu_horizon).
    Length d = -r_mu - SafeSqrt(discriminant);
    Length d_min = r - atmosphere.bottom_radius;
    Length d_max = rho;
    u_mu = 0.5 - 0.5 * GetTextureCoordFromUnitRange(d_max == d_min ? 0.0 :
        (d - d_min) / (d_max - d_min), SCATTERING_TEXTURE_MU_SIZE / 2);
  } else {
    // Distance to the top atmosphere boundary for the ray (r,mu), and its
    // minimum and maximum values over all mu - obtained for (r,1) and
    // (r,mu_horizon).
    Length d = -r_mu + SafeSqrt(discriminant + H * H);
    Length d_min = atmosphere.top_radius - r;
    Length d_max = rho + H;
    u_mu = 0.5 + 0.5 * GetTextureCoordFromUnitRange(
        (d - d_min) / (d_max - d_min), SCATTERING_TEXTURE_MU_SIZE / 2);
  }

  Length d = DistanceToTopAtmosphereBoundary(
      atmosphere, atmosphere.bottom_radius, mu_s);
  Length d_min = atmosphere.top_radius - atmosphere.bottom_radius;
  Length d_max = H;
  Number a = (d - d_min) / (d_max - d_min);
  Length D = DistanceToTopAtmosphereBoundary(
      atmosphere, atmosphere.bottom_radius, atmosphere.mu_s_min);
  Number A = (D - d_min) / (d_max - d_min);
  // An ad-hoc function equal to 0 for mu_s = mu_s_min (because then d = D and
  // thus a = A), equal to 1 for mu_s = 1 (because then d = d_min and thus
  // a = 0), and with a large slope around mu_s = 0, to get more texture
  // samples near the horizon.
  Number u_mu_s = GetTextureCoordFromUnitRange(
      max(1.0 - a / A, 0.0) / (1.0 + a), SCATTERING_TEXTURE_MU_S_SIZE);

  Number u_nu = (nu + 1.0) / 2.0;
  return vec4(u_nu, u_mu_s, u_mu, u_r);
}

vec2 GetIrradianceTextureUvFromRMuS(const AtmosphereParameters atmosphere,
    const Length r, const Number mu_s) {
  assert(r >= atmosphere.bottom_radius && r <= atmosphere.top_radius);
  assert(mu_s >= -1.0 && mu_s <= 1.0);
  Number x_r = (r - atmosphere.bottom_radius) /
      (atmosphere.top_radius - atmosphere.bottom_radius);
  Number x_mu_s = mu_s * 0.5 + 0.5;
  return vec2(GetTextureCoordFromUnitRange(x_mu_s, IRRADIANCE_TEXTURE_WIDTH),
              GetTextureCoordFromUnitRange(x_r, IRRADIANCE_TEXTURE_HEIGHT));
}

IrradianceSpectrum GetIrradiance(
    const AtmosphereParameters atmosphere,
    const IrradianceTexture irradiance_texture,
    const Length r, const Number mu_s) {
  vec2 uv = GetIrradianceTextureUvFromRMuS(atmosphere, r, mu_s);
  return IrradianceSpectrum(texture(irradiance_texture, uv));
}
`;
var t = `// Based on: https://github.com/ebruneton/precomputed_atmospheric_scattering/blob/master/atmosphere/definitions.glsl

/**
 * Copyright (c) 2017 Eric Bruneton
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the copyright holders nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

#define assert(x)

#define Length float
#define Wavelength float
#define Angle float
#define SolidAngle float
#define Power float
#define LuminousPower float

#define Number float
#define InverseLength float
#define Area float
#define Volume float
#define NumberDensity float
#define Irradiance float
#define Radiance float
#define SpectralPower float
#define SpectralIrradiance float
#define SpectralRadiance float
#define SpectralRadianceDensity float
#define ScatteringCoefficient float
#define InverseSolidAngle float
#define LuminousIntensity float
#define Luminance float
#define Illuminance float

// A generic function from Wavelength to some other type.
#define AbstractSpectrum vec3
// A function from Wavelength to Number.
#define DimensionlessSpectrum vec3
// A function from Wavelength to SpectralPower.
#define PowerSpectrum vec3
// A function from Wavelength to SpectralIrradiance.
#define IrradianceSpectrum vec3
// A function from Wavelength to SpectralRadiance.
#define RadianceSpectrum vec3
// A function from Wavelength to SpectralRadianceDensity.
#define RadianceDensitySpectrum vec3
// A function from Wavelength to ScatteringCoefficient.
#define ScatteringSpectrum vec3

// A position in 3D (3 length values).
#define Position vec3
// A unit direction vector in 3D (3 unit-less values).
#define Direction vec3
// A vector of 3 luminance values.
#define Luminance3 vec3
// A vector of 3 illuminance values.
#define Illuminance3 vec3

#define TransmittanceTexture sampler2D
#define AbstractScatteringTexture sampler3D
#define ReducedScatteringTexture sampler3D
#define ScatteringTexture sampler3D
#define ScatteringDensityTexture sampler3D
#define IrradianceTexture sampler2D

const Length m = 1.0;
const Wavelength nm = 1.0;
const Angle rad = 1.0;
const SolidAngle sr = 1.0;
const Power watt = 1.0;
const LuminousPower lm = 1.0;

#if !defined(PI)
const float PI = 3.14159265358979323846;
#endif // !defined(PI)

const Length km = 1000.0 * m;
const Area m2 = m * m;
const Volume m3 = m * m * m;
const Angle pi = PI * rad;
const Angle deg = pi / 180.0;
const Irradiance watt_per_square_meter = watt / m2;
const Radiance watt_per_square_meter_per_sr = watt / (m2 * sr);
const SpectralIrradiance watt_per_square_meter_per_nm = watt / (m2 * nm);
const SpectralRadiance watt_per_square_meter_per_sr_per_nm = watt / (m2 * sr * nm);
const SpectralRadianceDensity watt_per_cubic_meter_per_sr_per_nm = watt / (m3 * sr * nm);
const LuminousIntensity cd = lm / sr;
const LuminousIntensity kcd = 1000.0 * cd;
const Luminance cd_per_square_meter = cd / m2;
const Luminance kcd_per_square_meter = kcd / m2;

struct DensityProfileLayer {
  Length width;
  Number exp_term;
  InverseLength exp_scale;
  InverseLength linear_term;
  Number constant_term;
};

struct DensityProfile {
  DensityProfileLayer layers[2];
};

// See AtmosphereParameter.ts for further details.
struct AtmosphereParameters {
  IrradianceSpectrum solar_irradiance;
  Angle sun_angular_radius;
  Length bottom_radius;
  Length top_radius;
  DensityProfile rayleigh_density;
  ScatteringSpectrum rayleigh_scattering;
  DensityProfile mie_density;
  ScatteringSpectrum mie_scattering;
  ScatteringSpectrum mie_extinction;
  Number mie_phase_function_g;
  DensityProfile absorption_density;
  ScatteringSpectrum absorption_extinction;
  DimensionlessSpectrum ground_albedo;
  Number mu_s_min;
};
`;
var n2 = `// Based on: https://github.com/ebruneton/precomputed_atmospheric_scattering/blob/master/atmosphere/functions.glsl

/**
 * Copyright (c) 2017 Eric Bruneton
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the copyright holders nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Precomputed Atmospheric Scattering
 * Copyright (c) 2008 INRIA
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the copyright holders nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifdef COMBINED_SCATTERING_TEXTURES
vec3 GetExtrapolatedSingleMieScattering(
    const AtmosphereParameters atmosphere, const vec4 scattering) {
  // Algebraically this can never be negative, but rounding errors can produce
  // that effect for sufficiently short view rays.
  // @shotamatsuda: Avoid division by infinitesimal values.
  // See https://github.com/takram-design-engineering/three-geospatial/issues/47
  if (scattering.r < 1e-5) {
    return vec3(0.0);
  }
  return scattering.rgb * scattering.a / scattering.r *
	    (atmosphere.rayleigh_scattering.r / atmosphere.mie_scattering.r) *
	    (atmosphere.mie_scattering / atmosphere.rayleigh_scattering);
}
#endif // COMBINED_SCATTERING_TEXTURES

IrradianceSpectrum GetCombinedScattering(
    const AtmosphereParameters atmosphere,
    const ReducedScatteringTexture scattering_texture,
    const ReducedScatteringTexture single_mie_scattering_texture,
    const Length r, const Number mu, const Number mu_s, const Number nu,
    const bool ray_r_mu_intersects_ground,
    out IrradianceSpectrum single_mie_scattering) {
  vec4 uvwz = GetScatteringTextureUvwzFromRMuMuSNu(
      atmosphere, r, mu, mu_s, nu, ray_r_mu_intersects_ground);
  Number tex_coord_x = uvwz.x * Number(SCATTERING_TEXTURE_NU_SIZE - 1);
  Number tex_x = floor(tex_coord_x);
  Number lerp = tex_coord_x - tex_x;
  vec3 uvw0 = vec3((tex_x + uvwz.y) / Number(SCATTERING_TEXTURE_NU_SIZE),
      uvwz.z, uvwz.w);
  vec3 uvw1 = vec3((tex_x + 1.0 + uvwz.y) / Number(SCATTERING_TEXTURE_NU_SIZE),
      uvwz.z, uvwz.w);
#ifdef COMBINED_SCATTERING_TEXTURES
  vec4 combined_scattering =
      texture(scattering_texture, uvw0) * (1.0 - lerp) +
      texture(scattering_texture, uvw1) * lerp;
  IrradianceSpectrum scattering = IrradianceSpectrum(combined_scattering);
  single_mie_scattering =
      GetExtrapolatedSingleMieScattering(atmosphere, combined_scattering);
#else // COMBINED_SCATTERING_TEXTURES
  IrradianceSpectrum scattering = IrradianceSpectrum(
      texture(scattering_texture, uvw0) * (1.0 - lerp) +
      texture(scattering_texture, uvw1) * lerp);
  single_mie_scattering = IrradianceSpectrum(
      texture(single_mie_scattering_texture, uvw0) * (1.0 - lerp) +
      texture(single_mie_scattering_texture, uvw1) * lerp);
#endif // COMBINED_SCATTERING_TEXTURES
  return scattering;
}

// @shotamatsuda: Added for reading higher-order scattering texture.
#ifdef HAS_HIGHER_ORDER_SCATTERING_TEXTURE
IrradianceSpectrum GetScattering(
    const AtmosphereParameters atmosphere,
    const ReducedScatteringTexture scattering_texture,
    const Length r, const Number mu, const Number mu_s, const Number nu,
    const bool ray_r_mu_intersects_ground) {
  vec4 uvwz = GetScatteringTextureUvwzFromRMuMuSNu(
      atmosphere, r, mu, mu_s, nu, ray_r_mu_intersects_ground);
  Number tex_coord_x = uvwz.x * Number(SCATTERING_TEXTURE_NU_SIZE - 1);
  Number tex_x = floor(tex_coord_x);
  Number lerp = tex_coord_x - tex_x;
  vec3 uvw0 = vec3((tex_x + uvwz.y) / Number(SCATTERING_TEXTURE_NU_SIZE),
      uvwz.z, uvwz.w);
  vec3 uvw1 = vec3((tex_x + 1.0 + uvwz.y) / Number(SCATTERING_TEXTURE_NU_SIZE),
      uvwz.z, uvwz.w);
  IrradianceSpectrum scattering = IrradianceSpectrum(
      texture(scattering_texture, uvw0) * (1.0 - lerp) +
      texture(scattering_texture, uvw1) * lerp);
  return scattering;
}
#endif // HAS_HIGHER_ORDER_SCATTERING_TEXTURE

RadianceSpectrum GetSkyRadiance(
    const AtmosphereParameters atmosphere,
    const TransmittanceTexture transmittance_texture,
    const ReducedScatteringTexture scattering_texture,
    const ReducedScatteringTexture single_mie_scattering_texture,
    Position camera, const Direction view_ray, const Length shadow_length,
    const Direction sun_direction,
    out DimensionlessSpectrum transmittance) {
  // Compute the distance to the top atmosphere boundary along the view ray,
  // assuming the viewer is in space (or NaN if the view ray does not intersect
  // the atmosphere).
  Length r = length(camera);
  Length rmu = dot(camera, view_ray);
  // @shotamatsuda: Use SafeSqrt instead.
  // See: https://github.com/takram-design-engineering/three-geospatial/pull/26
  Length distance_to_top_atmosphere_boundary = -rmu -
      SafeSqrt(rmu * rmu - r * r +
          atmosphere.top_radius * atmosphere.top_radius);
  // If the viewer is in space and the view ray intersects the atmosphere, move
  // the viewer to the top atmosphere boundary (along the view ray):
  if (distance_to_top_atmosphere_boundary > 0.0 * m) {
    camera = camera + view_ray * distance_to_top_atmosphere_boundary;
    r = atmosphere.top_radius;
    rmu += distance_to_top_atmosphere_boundary;
  } else if (r > atmosphere.top_radius) {
    // If the view ray does not intersect the atmosphere, simply return 0.
    transmittance = DimensionlessSpectrum(1.0);
    return RadianceSpectrum(0.0 * watt_per_square_meter_per_sr_per_nm);
  }
  // Compute the r, mu, mu_s and nu parameters needed for the texture lookups.
  Number mu = rmu / r;
  Number mu_s = dot(camera, sun_direction) / r;
  Number nu = dot(view_ray, sun_direction);

  // @shotamatsuda: For rendering points below the bottom atmosphere.
  #ifdef GROUND
  bool ray_r_mu_intersects_ground = RayIntersectsGround(atmosphere, r, mu);
  #else // GROUND
  bool ray_r_mu_intersects_ground = false;
  #endif // GROUND

  transmittance = ray_r_mu_intersects_ground ? DimensionlessSpectrum(0.0) :
      GetTransmittanceToTopAtmosphereBoundary(
          atmosphere, transmittance_texture, r, mu);
  IrradianceSpectrum single_mie_scattering;
  IrradianceSpectrum scattering;
  if (shadow_length == 0.0 * m) {
    scattering = GetCombinedScattering(
        atmosphere, scattering_texture, single_mie_scattering_texture,
        r, mu, mu_s, nu, ray_r_mu_intersects_ground,
        single_mie_scattering);
  } else {
    // Case of light shafts (shadow_length is the total length noted l in our
    // paper): we omit the scattering between the camera and the point at
    // distance l, by implementing Eq. (18) of the paper (shadow_transmittance
    // is the T(x,x_s) term, scattering is the S|x_s=x+lv term).
    Length d = shadow_length;
    Length r_p =
        ClampRadius(atmosphere, sqrt(d * d + 2.0 * r * mu * d + r * r));
    Number mu_p = (r * mu + d) / r_p;
    Number mu_s_p = (r * mu_s + d * nu) / r_p;

    scattering = GetCombinedScattering(
        atmosphere, scattering_texture, single_mie_scattering_texture,
        r_p, mu_p, mu_s_p, nu, ray_r_mu_intersects_ground,
        single_mie_scattering);
    DimensionlessSpectrum shadow_transmittance =
        GetTransmittance(atmosphere, transmittance_texture,
            r, mu, shadow_length, ray_r_mu_intersects_ground);
    // @shotamatsuda: Occlude only single Rayleigh scattering by the shadow.
#ifdef HAS_HIGHER_ORDER_SCATTERING_TEXTURE
    IrradianceSpectrum higher_order_scattering = GetScattering(
        atmosphere, higher_order_scattering_texture,
        r_p, mu_p, mu_s_p, nu, ray_r_mu_intersects_ground);
    IrradianceSpectrum single_scattering = scattering - higher_order_scattering;
    scattering = single_scattering * shadow_transmittance + higher_order_scattering;
#else // HAS_HIGHER_ORDER_SCATTERING_TEXTURE
    scattering = scattering * shadow_transmittance;
#endif // HAS_HIGHER_ORDER_SCATTERING_TEXTURE
    single_mie_scattering = single_mie_scattering * shadow_transmittance;
  }
  return scattering * RayleighPhaseFunction(nu) + single_mie_scattering *
      MiePhaseFunction(atmosphere.mie_phase_function_g, nu);
}

// @shotamatsuda: Returns the point on the ray closest to the origin.
vec3 ClosestPointOnRay(const Position camera, const Position point) {
  Position ray = point - camera;
  Number t = clamp(-dot(camera, ray) / dot(ray, ray), 0.0, 1.0);
  return camera + t * ray;
}

vec2 RaySphereIntersections(
    const Position camera, const Direction direction, const Length radius) {
  float b = 2.0 * dot(direction, camera);
  float c = dot(camera, camera) - radius * radius;
  float discriminant = b * b - 4.0 * c;
  float Q = sqrt(discriminant);
  return vec2(-b - Q, -b + Q) * 0.5;
}

// @shotamatsuda: Clip the view ray at the bottom atmosphere boundary.
bool ClipAtBottomAtmosphere(
    const AtmosphereParameters atmosphere,
    const Direction view_ray, inout Position camera, inout Position point) {
  const Length eps = 0.0;
  Length bottom_radius = atmosphere.bottom_radius + eps;
  Length r_camera = length(camera);
  Length r_point = length(point);
  bool camera_below = r_camera < bottom_radius;
  bool point_below = r_point < bottom_radius;

  vec2 t = RaySphereIntersections(camera, view_ray, bottom_radius);
  Position intersection = camera + view_ray * (camera_below ? t.y : t.x);
  camera = camera_below ? intersection : camera;
  point = point_below ? intersection : point;

  return camera_below && point_below;
}

RadianceSpectrum GetSkyRadianceToPoint(
    const AtmosphereParameters atmosphere,
    const TransmittanceTexture transmittance_texture,
    const ReducedScatteringTexture scattering_texture,
    const ReducedScatteringTexture single_mie_scattering_texture,
    Position camera, Position point, const Length shadow_length,
    const Direction sun_direction, out DimensionlessSpectrum transmittance) {
  // @shotamatsuda: Avoid artifacts when the ray does not intersect the top
  // atmosphere boundary.
  if (length(ClosestPointOnRay(camera, point)) > atmosphere.top_radius) {
    transmittance = vec3(1.0);
    return vec3(0.0);
  }

  Direction view_ray = normalize(point - camera);
  if (ClipAtBottomAtmosphere(atmosphere, view_ray, camera, point)) {
    transmittance = vec3(1.0);
    return vec3(0.0);
  }

  // Compute the distance to the top atmosphere boundary along the view ray,
  // assuming the viewer is in space (or NaN if the view ray does not intersect
  // the atmosphere).
  Length r = length(camera);
  Length rmu = dot(camera, view_ray);
  // @shotamatsuda: Use SafeSqrt instead.
  // See: https://github.com/takram-design-engineering/three-geospatial/pull/26
  Length distance_to_top_atmosphere_boundary = -rmu -
      SafeSqrt(rmu * rmu - r * r +
          atmosphere.top_radius * atmosphere.top_radius);
  // If the viewer is in space and the view ray intersects the atmosphere, move
  // the viewer to the top atmosphere boundary (along the view ray):
  if (distance_to_top_atmosphere_boundary > 0.0 * m) {
    camera = camera + view_ray * distance_to_top_atmosphere_boundary;
    r = atmosphere.top_radius;
    rmu += distance_to_top_atmosphere_boundary;
  }

  // Compute the r, mu, mu_s and nu parameters for the first texture lookup.
  Number mu = rmu / r;
  Number mu_s = dot(camera, sun_direction) / r;
  Number nu = dot(view_ray, sun_direction);
  Length d = length(point - camera);
  bool ray_r_mu_intersects_ground = RayIntersectsGround(atmosphere, r, mu);

  // @shotamatsuda: Hack to avoid rendering artifacts near the horizon, due to
  // finite atmosphere texture resolution and finite floating point precision.
  // See: https://github.com/ebruneton/precomputed_atmospheric_scattering/pull/32
  if (!ray_r_mu_intersects_ground) {
    Number mu_horizon = -SafeSqrt(1.0 -
        (atmosphere.bottom_radius * atmosphere.bottom_radius) / (r * r));
    const Number eps = 0.004;
    mu = max(mu, mu_horizon + eps);
  }

  transmittance = GetTransmittance(atmosphere, transmittance_texture,
      r, mu, d, ray_r_mu_intersects_ground);

  IrradianceSpectrum single_mie_scattering;
  IrradianceSpectrum scattering = GetCombinedScattering(
      atmosphere, scattering_texture, single_mie_scattering_texture,
      r, mu, mu_s, nu, ray_r_mu_intersects_ground,
      single_mie_scattering);

  // Compute the r, mu, mu_s and nu parameters for the second texture lookup.
  // If shadow_length is not 0 (case of light shafts), we want to ignore the
  // scattering along the last shadow_length meters of the view ray, which we
  // do by subtracting shadow_length from d (this way scattering_p is equal to
  // the S|x_s=x_0-lv term in Eq. (17) of our paper).
  d = max(d - shadow_length, 0.0 * m);
  Length r_p = ClampRadius(atmosphere, sqrt(d * d + 2.0 * r * mu * d + r * r));
  Number mu_p = (r * mu + d) / r_p;
  Number mu_s_p = (r * mu_s + d * nu) / r_p;

  IrradianceSpectrum single_mie_scattering_p;
  IrradianceSpectrum scattering_p = GetCombinedScattering(
      atmosphere, scattering_texture, single_mie_scattering_texture,
      r_p, mu_p, mu_s_p, nu, ray_r_mu_intersects_ground,
      single_mie_scattering_p);

  // Combine the lookup results to get the scattering between camera and point.
  DimensionlessSpectrum shadow_transmittance = transmittance;
  if (shadow_length > 0.0 * m) {
    // This is the T(x,x_s) term in Eq. (17) of our paper, for light shafts.
    shadow_transmittance = GetTransmittance(atmosphere, transmittance_texture,
        r, mu, d, ray_r_mu_intersects_ground);
  }
  // @shotamatsuda: Occlude only single Rayleigh scattering by the shadow.
#ifdef HAS_HIGHER_ORDER_SCATTERING_TEXTURE
  IrradianceSpectrum higher_order_scattering = GetScattering(
      atmosphere, higher_order_scattering_texture,
      r, mu, mu_s, nu, ray_r_mu_intersects_ground);
  IrradianceSpectrum single_scattering = scattering - higher_order_scattering;
  IrradianceSpectrum higher_order_scattering_p = GetScattering(
      atmosphere, higher_order_scattering_texture,
      r_p, mu_p, mu_s_p, nu, ray_r_mu_intersects_ground);
  IrradianceSpectrum single_scattering_p =
      scattering_p - higher_order_scattering_p;
  scattering =
      single_scattering - shadow_transmittance * single_scattering_p +
      higher_order_scattering - transmittance * higher_order_scattering_p;
#else // HAS_HIGHER_ORDER_SCATTERING_TEXTURE
  scattering = scattering - shadow_transmittance * scattering_p;
#endif // HAS_HIGHER_ORDER_SCATTERING_TEXTURE

  single_mie_scattering =
      single_mie_scattering - shadow_transmittance * single_mie_scattering_p;
#ifdef COMBINED_SCATTERING_TEXTURES
  single_mie_scattering = GetExtrapolatedSingleMieScattering(
      atmosphere, vec4(scattering, single_mie_scattering.r));
#endif // COMBINED_SCATTERING_TEXTURES

  // Hack to avoid rendering artifacts when the sun is below the horizon.
  single_mie_scattering = single_mie_scattering *
      smoothstep(Number(0.0), Number(0.01), mu_s);

  return scattering * RayleighPhaseFunction(nu) + single_mie_scattering *
      MiePhaseFunction(atmosphere.mie_phase_function_g, nu);
}

IrradianceSpectrum GetSunAndSkyIrradiance(
    const AtmosphereParameters atmosphere,
    const TransmittanceTexture transmittance_texture,
    const IrradianceTexture irradiance_texture,
    const Position point, const Direction normal, const Direction sun_direction,
    out IrradianceSpectrum sky_irradiance) {
  Length r = length(point);
  Number mu_s = dot(point, sun_direction) / r;

  // Indirect irradiance (approximated if the surface is not horizontal).
  sky_irradiance = GetIrradiance(atmosphere, irradiance_texture, r, mu_s) *
      (1.0 + dot(normal, point) / r) * 0.5;

  // Direct irradiance.
  return atmosphere.solar_irradiance *
      GetTransmittanceToSun(
          atmosphere, transmittance_texture, r, mu_s) *
      max(dot(normal, sun_direction), 0.0);
}

// @shotamatsuda: Added for the clouds.
IrradianceSpectrum GetSunAndSkyScalarIrradiance(
    const AtmosphereParameters atmosphere,
    const TransmittanceTexture transmittance_texture,
    const IrradianceTexture irradiance_texture,
    const Position point, const Direction sun_direction,
    out IrradianceSpectrum sky_irradiance) {
  Length r = length(point);
  Number mu_s = dot(point, sun_direction) / r;

  // Indirect irradiance. Integral over sphere yields 2.
  sky_irradiance = GetIrradiance(atmosphere, irradiance_texture, r, mu_s) *
      2.0 * PI;

  // Direct irradiance. Omit the cosine term.
  return atmosphere.solar_irradiance *
      GetTransmittanceToSun(atmosphere, transmittance_texture, r, mu_s);
}

Luminance3 GetSolarLuminance() {
  return ATMOSPHERE.solar_irradiance /
      (PI * ATMOSPHERE.sun_angular_radius * ATMOSPHERE.sun_angular_radius) *
      SUN_SPECTRAL_RADIANCE_TO_LUMINANCE;
}

Luminance3 GetSkyLuminance(
    const Position camera, Direction view_ray, const Length shadow_length,
    const Direction sun_direction, out DimensionlessSpectrum transmittance) {
  return GetSkyRadiance(ATMOSPHERE, transmittance_texture,
      scattering_texture, single_mie_scattering_texture,
      camera, view_ray, shadow_length, sun_direction,
      transmittance) * SKY_SPECTRAL_RADIANCE_TO_LUMINANCE;
}

Luminance3 GetSkyLuminanceToPoint(
    const Position camera, const Position point, const Length shadow_length,
    const Direction sun_direction, out DimensionlessSpectrum transmittance) {
  return GetSkyRadianceToPoint(ATMOSPHERE, transmittance_texture,
      scattering_texture, single_mie_scattering_texture,
      camera, point, shadow_length, sun_direction, transmittance) *
      SKY_SPECTRAL_RADIANCE_TO_LUMINANCE;
}

Illuminance3 GetSunAndSkyIlluminance(
    const Position p, const Direction normal, const Direction sun_direction,
    out IrradianceSpectrum sky_irradiance) {
  IrradianceSpectrum sun_irradiance = GetSunAndSkyIrradiance(
      ATMOSPHERE, transmittance_texture, irradiance_texture, p, normal,
      sun_direction, sky_irradiance);
  sky_irradiance *= SKY_SPECTRAL_RADIANCE_TO_LUMINANCE;
  return sun_irradiance * SUN_SPECTRAL_RADIANCE_TO_LUMINANCE;
}

// @shotamatsuda: Added for the clouds.
Illuminance3 GetSunAndSkyScalarIlluminance(
    const Position p, const Direction sun_direction,
    out IrradianceSpectrum sky_irradiance) {
  IrradianceSpectrum sun_irradiance = GetSunAndSkyScalarIrradiance(
      ATMOSPHERE, transmittance_texture, irradiance_texture, p,
      sun_direction, sky_irradiance);
  sky_irradiance *= SKY_SPECTRAL_RADIANCE_TO_LUMINANCE;
  return sun_irradiance * SUN_SPECTRAL_RADIANCE_TO_LUMINANCE;
}

#define GetSolarRadiance GetSolarLuminance
#define GetSkyRadiance GetSkyLuminance
#define GetSkyRadianceToPoint GetSkyLuminanceToPoint
#define GetSunAndSkyIrradiance GetSunAndSkyIlluminance
#define GetSunAndSkyScalarIrradiance GetSunAndSkyScalarIlluminance
`;
var r2 = `// Based on: https://github.com/ebruneton/precomputed_atmospheric_scattering/blob/master/atmosphere/functions.glsl

/**
 * Copyright (c) 2017 Eric Bruneton
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the copyright holders nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Precomputed Atmospheric Scattering
 * Copyright (c) 2008 INRIA
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the copyright holders nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

Number GetLayerDensity(const DensityProfileLayer layer, const Length altitude) {
  Number density = layer.exp_term * exp(layer.exp_scale * altitude) +
      layer.linear_term * altitude + layer.constant_term;
  return clamp(density, Number(0.0), Number(1.0));
}

Number GetProfileDensity(const DensityProfile profile, const Length altitude) {
  DensityProfileLayer layers[2] = profile.layers;
  return altitude < layers[0].width
    ? GetLayerDensity(layers[0], altitude)
    : GetLayerDensity(layers[1], altitude);
}

Length ComputeOpticalLengthToTopAtmosphereBoundary(
    const AtmosphereParameters atmosphere, const DensityProfile profile,
    const Length r, const Number mu) {
  assert(r >= atmosphere.bottom_radius && r <= atmosphere.top_radius);
  assert(mu >= -1.0 && mu <= 1.0);
  // Number of intervals for the numerical integration.
  const int SAMPLE_COUNT = 500;
  // The integration step, i.e. the length of each integration interval.
  Length dx =
      DistanceToTopAtmosphereBoundary(atmosphere, r, mu) / Number(SAMPLE_COUNT);
  // Integration loop.
  Length result = 0.0 * m;
  for (int i = 0; i <= SAMPLE_COUNT; ++i) {
    Length d_i = Number(i) * dx;
    // Distance between the current sample point and the planet center.
    Length r_i = sqrt(d_i * d_i + 2.0 * r * mu * d_i + r * r);
    // Number density at the current sample point (divided by the number density
    // at the bottom of the atmosphere, yielding a dimensionless number).
    Number y_i = GetProfileDensity(profile, r_i - atmosphere.bottom_radius);
    // Sample weight (from the trapezoidal rule).
    Number weight_i = i == 0 || i == SAMPLE_COUNT ? 0.5 : 1.0;
    result += y_i * weight_i * dx;
  }
  return result;
}

DimensionlessSpectrum ComputeTransmittanceToTopAtmosphereBoundary(
    const AtmosphereParameters atmosphere, const Length r, const Number mu) {
  assert(r >= atmosphere.bottom_radius && r <= atmosphere.top_radius);
  assert(mu >= -1.0 && mu <= 1.0);
  vec3 optical_depth = (
      atmosphere.rayleigh_scattering *
          ComputeOpticalLengthToTopAtmosphereBoundary(
              atmosphere, atmosphere.rayleigh_density, r, mu) +
      atmosphere.mie_extinction *
          ComputeOpticalLengthToTopAtmosphereBoundary(
              atmosphere, atmosphere.mie_density, r, mu) +
      atmosphere.absorption_extinction *
          ComputeOpticalLengthToTopAtmosphereBoundary(
              atmosphere, atmosphere.absorption_density, r, mu));
  // @shotamatsuda: Added for the precomputation stage in half-float precision.
  #ifdef TRANSMITTANCE_PRECISION_LOG
  return optical_depth;
  #else // TRANSMITTANCE_PRECISION_LOG
  return exp(-optical_depth);
  #endif // TRANSMITTANCE_PRECISION_LOG
}

Number GetUnitRangeFromTextureCoord(const Number u, const int texture_size) {
  return (u - 0.5 / Number(texture_size)) / (1.0 - 1.0 / Number(texture_size));
}

void GetRMuFromTransmittanceTextureUv(const AtmosphereParameters atmosphere,
    const vec2 uv, out Length r, out Number mu) {
  assert(uv.x >= 0.0 && uv.x <= 1.0);
  assert(uv.y >= 0.0 && uv.y <= 1.0);
  Number x_mu = GetUnitRangeFromTextureCoord(uv.x, TRANSMITTANCE_TEXTURE_WIDTH);
  Number x_r = GetUnitRangeFromTextureCoord(uv.y, TRANSMITTANCE_TEXTURE_HEIGHT);
  // Distance to top atmosphere boundary for a horizontal ray at ground level.
  Length H = sqrt(atmosphere.top_radius * atmosphere.top_radius -
      atmosphere.bottom_radius * atmosphere.bottom_radius);
  // Distance to the horizon, from which we can compute r:
  Length rho = H * x_r;
  r = sqrt(rho * rho + atmosphere.bottom_radius * atmosphere.bottom_radius);
  // Distance to the top atmosphere boundary for the ray (r,mu), and its minimum
  // and maximum values over all mu - obtained for (r,1) and (r,mu_horizon) -
  // from which we can recover mu:
  Length d_min = atmosphere.top_radius - r;
  Length d_max = rho + H;
  Length d = d_min + x_mu * (d_max - d_min);
  mu = d == 0.0 * m ? Number(1.0) : (H * H - rho * rho - d * d) / (2.0 * r * d);
  mu = ClampCosine(mu);
}

DimensionlessSpectrum ComputeTransmittanceToTopAtmosphereBoundaryTexture(
    const AtmosphereParameters atmosphere, const vec2 frag_coord) {
  const vec2 TRANSMITTANCE_TEXTURE_SIZE =
      vec2(TRANSMITTANCE_TEXTURE_WIDTH, TRANSMITTANCE_TEXTURE_HEIGHT);
  Length r;
  Number mu;
  GetRMuFromTransmittanceTextureUv(
      atmosphere, frag_coord / TRANSMITTANCE_TEXTURE_SIZE, r, mu);
  return ComputeTransmittanceToTopAtmosphereBoundary(atmosphere, r, mu);
}

void ComputeSingleScatteringIntegrand(
    const AtmosphereParameters atmosphere,
    const TransmittanceTexture transmittance_texture,
    const Length r, const Number mu, const Number mu_s, const Number nu,
    const Length d, const bool ray_r_mu_intersects_ground,
    out DimensionlessSpectrum rayleigh, out DimensionlessSpectrum mie) {
  Length r_d = ClampRadius(atmosphere, sqrt(d * d + 2.0 * r * mu * d + r * r));
  Number mu_s_d = ClampCosine((r * mu_s + d * nu) / r_d);
  DimensionlessSpectrum transmittance =
      GetTransmittance(
          atmosphere, transmittance_texture, r, mu, d,
          ray_r_mu_intersects_ground) *
      GetTransmittanceToSun(
          atmosphere, transmittance_texture, r_d, mu_s_d);
  rayleigh = transmittance * GetProfileDensity(
      atmosphere.rayleigh_density, r_d - atmosphere.bottom_radius);
  mie = transmittance * GetProfileDensity(
      atmosphere.mie_density, r_d - atmosphere.bottom_radius);
}

Length DistanceToNearestAtmosphereBoundary(const AtmosphereParameters atmosphere,
    Length r, Number mu, bool ray_r_mu_intersects_ground) {
  if (ray_r_mu_intersects_ground) {
    return DistanceToBottomAtmosphereBoundary(atmosphere, r, mu);
  } else {
    return DistanceToTopAtmosphereBoundary(atmosphere, r, mu);
  }
}

void ComputeSingleScattering(
    const AtmosphereParameters atmosphere,
    const TransmittanceTexture transmittance_texture,
    const Length r, const Number mu, const Number mu_s, const Number nu,
    const bool ray_r_mu_intersects_ground,
    out IrradianceSpectrum rayleigh, out IrradianceSpectrum mie) {
  assert(r >= atmosphere.bottom_radius && r <= atmosphere.top_radius);
  assert(mu >= -1.0 && mu <= 1.0);
  assert(mu_s >= -1.0 && mu_s <= 1.0);
  assert(nu >= -1.0 && nu <= 1.0);

  // Number of intervals for the numerical integration.
  const int SAMPLE_COUNT = 50;
  // The integration step, i.e. the length of each integration interval.
  Length dx =
      DistanceToNearestAtmosphereBoundary(atmosphere, r, mu,
          ray_r_mu_intersects_ground) / Number(SAMPLE_COUNT);
  // Integration loop.
  DimensionlessSpectrum rayleigh_sum = DimensionlessSpectrum(0.0);
  DimensionlessSpectrum mie_sum = DimensionlessSpectrum(0.0);
  for (int i = 0; i <= SAMPLE_COUNT; ++i) {
    Length d_i = Number(i) * dx;
    // The Rayleigh and Mie single scattering at the current sample point.
    DimensionlessSpectrum rayleigh_i;
    DimensionlessSpectrum mie_i;
    ComputeSingleScatteringIntegrand(atmosphere, transmittance_texture,
        r, mu, mu_s, nu, d_i, ray_r_mu_intersects_ground, rayleigh_i, mie_i);
    // Sample weight (from the trapezoidal rule).
    Number weight_i = (i == 0 || i == SAMPLE_COUNT) ? 0.5 : 1.0;
    rayleigh_sum += rayleigh_i * weight_i;
    mie_sum += mie_i * weight_i;
  }
  rayleigh = rayleigh_sum * dx * atmosphere.solar_irradiance *
      atmosphere.rayleigh_scattering;
  mie = mie_sum * dx * atmosphere.solar_irradiance * atmosphere.mie_scattering;
}

void GetRMuMuSNuFromScatteringTextureUvwz(const AtmosphereParameters atmosphere,
    const vec4 uvwz, out Length r, out Number mu, out Number mu_s,
    out Number nu, out bool ray_r_mu_intersects_ground) {
  assert(uvwz.x >= 0.0 && uvwz.x <= 1.0);
  assert(uvwz.y >= 0.0 && uvwz.y <= 1.0);
  assert(uvwz.z >= 0.0 && uvwz.z <= 1.0);
  assert(uvwz.w >= 0.0 && uvwz.w <= 1.0);

  // Distance to top atmosphere boundary for a horizontal ray at ground level.
  Length H = sqrt(atmosphere.top_radius * atmosphere.top_radius -
      atmosphere.bottom_radius * atmosphere.bottom_radius);
  // Distance to the horizon.
  Length rho =
      H * GetUnitRangeFromTextureCoord(uvwz.w, SCATTERING_TEXTURE_R_SIZE);
  r = sqrt(rho * rho + atmosphere.bottom_radius * atmosphere.bottom_radius);

  if (uvwz.z < 0.5) {
    // Distance to the ground for the ray (r,mu), and its minimum and maximum
    // values over all mu - obtained for (r,-1) and (r,mu_horizon) - from which
    // we can recover mu:
    Length d_min = r - atmosphere.bottom_radius;
    Length d_max = rho;
    Length d = d_min + (d_max - d_min) * GetUnitRangeFromTextureCoord(
        1.0 - 2.0 * uvwz.z, SCATTERING_TEXTURE_MU_SIZE / 2);
    mu = d == 0.0 * m ? Number(-1.0) :
        ClampCosine(-(rho * rho + d * d) / (2.0 * r * d));
    ray_r_mu_intersects_ground = true;
  } else {
    // Distance to the top atmosphere boundary for the ray (r,mu), and its
    // minimum and maximum values over all mu - obtained for (r,1) and
    // (r,mu_horizon) - from which we can recover mu:
    Length d_min = atmosphere.top_radius - r;
    Length d_max = rho + H;
    Length d = d_min + (d_max - d_min) * GetUnitRangeFromTextureCoord(
        2.0 * uvwz.z - 1.0, SCATTERING_TEXTURE_MU_SIZE / 2);
    mu = d == 0.0 * m ? Number(1.0) :
        ClampCosine((H * H - rho * rho - d * d) / (2.0 * r * d));
    ray_r_mu_intersects_ground = false;
  }

  Number x_mu_s =
      GetUnitRangeFromTextureCoord(uvwz.y, SCATTERING_TEXTURE_MU_S_SIZE);
  Length d_min = atmosphere.top_radius - atmosphere.bottom_radius;
  Length d_max = H;
  Length D = DistanceToTopAtmosphereBoundary(
      atmosphere, atmosphere.bottom_radius, atmosphere.mu_s_min);
  Number A = (D - d_min) / (d_max - d_min);
  Number a = (A - x_mu_s * A) / (1.0 + x_mu_s * A);
  Length d = d_min + min(a, A) * (d_max - d_min);
  mu_s = d == 0.0 * m ? Number(1.0) :
     ClampCosine((H * H - d * d) / (2.0 * atmosphere.bottom_radius * d));

  nu = ClampCosine(uvwz.x * 2.0 - 1.0);
}

void GetRMuMuSNuFromScatteringTextureFragCoord(
    const AtmosphereParameters atmosphere, const vec3 frag_coord,
    out Length r, out Number mu, out Number mu_s, out Number nu,
    out bool ray_r_mu_intersects_ground) {
  const vec4 SCATTERING_TEXTURE_SIZE = vec4(
      SCATTERING_TEXTURE_NU_SIZE - 1,
      SCATTERING_TEXTURE_MU_S_SIZE,
      SCATTERING_TEXTURE_MU_SIZE,
      SCATTERING_TEXTURE_R_SIZE);
  Number frag_coord_nu =
      floor(frag_coord.x / Number(SCATTERING_TEXTURE_MU_S_SIZE));
  Number frag_coord_mu_s =
      mod(frag_coord.x, Number(SCATTERING_TEXTURE_MU_S_SIZE));
  vec4 uvwz =
      vec4(frag_coord_nu, frag_coord_mu_s, frag_coord.y, frag_coord.z) /
          SCATTERING_TEXTURE_SIZE;
  GetRMuMuSNuFromScatteringTextureUvwz(
      atmosphere, uvwz, r, mu, mu_s, nu, ray_r_mu_intersects_ground);
  // Clamp nu to its valid range of values, given mu and mu_s.
  nu = clamp(nu, mu * mu_s - sqrt((1.0 - mu * mu) * (1.0 - mu_s * mu_s)),
      mu * mu_s + sqrt((1.0 - mu * mu) * (1.0 - mu_s * mu_s)));
}

void ComputeSingleScatteringTexture(const AtmosphereParameters atmosphere,
    const TransmittanceTexture transmittance_texture, const vec3 frag_coord,
    out IrradianceSpectrum rayleigh, out IrradianceSpectrum mie) {
  Length r;
  Number mu;
  Number mu_s;
  Number nu;
  bool ray_r_mu_intersects_ground;
  GetRMuMuSNuFromScatteringTextureFragCoord(atmosphere, frag_coord,
      r, mu, mu_s, nu, ray_r_mu_intersects_ground);
  ComputeSingleScattering(atmosphere, transmittance_texture,
      r, mu, mu_s, nu, ray_r_mu_intersects_ground, rayleigh, mie);
}

AbstractSpectrum GetScattering(
    const AtmosphereParameters atmosphere,
    const AbstractScatteringTexture scattering_texture,
    const Length r, const Number mu, const Number mu_s, const Number nu,
    const bool ray_r_mu_intersects_ground) {
  vec4 uvwz = GetScatteringTextureUvwzFromRMuMuSNu(
      atmosphere, r, mu, mu_s, nu, ray_r_mu_intersects_ground);
  Number tex_coord_x = uvwz.x * Number(SCATTERING_TEXTURE_NU_SIZE - 1);
  Number tex_x = floor(tex_coord_x);
  Number lerp = tex_coord_x - tex_x;
  vec3 uvw0 = vec3((tex_x + uvwz.y) / Number(SCATTERING_TEXTURE_NU_SIZE),
      uvwz.z, uvwz.w);
  vec3 uvw1 = vec3((tex_x + 1.0 + uvwz.y) / Number(SCATTERING_TEXTURE_NU_SIZE),
      uvwz.z, uvwz.w);
  return AbstractSpectrum(texture(scattering_texture, uvw0) * (1.0 - lerp) +
      texture(scattering_texture, uvw1) * lerp);
}

RadianceSpectrum GetScattering(
    const AtmosphereParameters atmosphere,
    const ReducedScatteringTexture single_rayleigh_scattering_texture,
    const ReducedScatteringTexture single_mie_scattering_texture,
    const ScatteringTexture multiple_scattering_texture,
    const Length r, const Number mu, const Number mu_s, const Number nu,
    const bool ray_r_mu_intersects_ground,
    const int scattering_order) {
  if (scattering_order == 1) {
    IrradianceSpectrum rayleigh = GetScattering(
        atmosphere, single_rayleigh_scattering_texture, r, mu, mu_s, nu,
        ray_r_mu_intersects_ground);
    IrradianceSpectrum mie = GetScattering(
        atmosphere, single_mie_scattering_texture, r, mu, mu_s, nu,
        ray_r_mu_intersects_ground);
    return rayleigh * RayleighPhaseFunction(nu) +
        mie * MiePhaseFunction(atmosphere.mie_phase_function_g, nu);
  } else {
    return GetScattering(
        atmosphere, multiple_scattering_texture, r, mu, mu_s, nu,
        ray_r_mu_intersects_ground);
  }
}

IrradianceSpectrum GetIrradiance(
    const AtmosphereParameters atmosphere,
    const IrradianceTexture irradiance_texture,
    const Length r, const Number mu_s);

RadianceDensitySpectrum ComputeScatteringDensity(
    const AtmosphereParameters atmosphere,
    const TransmittanceTexture transmittance_texture,
    const ReducedScatteringTexture single_rayleigh_scattering_texture,
    const ReducedScatteringTexture single_mie_scattering_texture,
    const ScatteringTexture multiple_scattering_texture,
    const IrradianceTexture irradiance_texture,
    const Length r, const Number mu, const Number mu_s, const Number nu,
    const int scattering_order) {
  assert(r >= atmosphere.bottom_radius && r <= atmosphere.top_radius);
  assert(mu >= -1.0 && mu <= 1.0);
  assert(mu_s >= -1.0 && mu_s <= 1.0);
  assert(nu >= -1.0 && nu <= 1.0);
  assert(scattering_order >= 2);

  // Compute unit direction vectors for the zenith, the view direction omega and
  // and the sun direction omega_s, such that the cosine of the view-zenith
  // angle is mu, the cosine of the sun-zenith angle is mu_s, and the cosine of
  // the view-sun angle is nu. The goal is to simplify computations below.
  vec3 zenith_direction = vec3(0.0, 0.0, 1.0);
  vec3 omega = vec3(sqrt(1.0 - mu * mu), 0.0, mu);
  Number sun_dir_x = omega.x == 0.0 ? 0.0 : (nu - mu * mu_s) / omega.x;
  Number sun_dir_y = sqrt(max(1.0 - sun_dir_x * sun_dir_x - mu_s * mu_s, 0.0));
  vec3 omega_s = vec3(sun_dir_x, sun_dir_y, mu_s);

  const int SAMPLE_COUNT = 16;
  const Angle dphi = pi / Number(SAMPLE_COUNT);
  const Angle dtheta = pi / Number(SAMPLE_COUNT);
  RadianceDensitySpectrum rayleigh_mie =
      RadianceDensitySpectrum(0.0 * watt_per_cubic_meter_per_sr_per_nm);

  // Nested loops for the integral over all the incident directions omega_i.
  for (int l = 0; l < SAMPLE_COUNT; ++l) {
    Angle theta = (Number(l) + 0.5) * dtheta;
    Number cos_theta = cos(theta);
    Number sin_theta = sin(theta);
    bool ray_r_theta_intersects_ground =
        RayIntersectsGround(atmosphere, r, cos_theta);

    // The distance and transmittance to the ground only depend on theta, so we
    // can compute them in the outer loop for efficiency.
    Length distance_to_ground = 0.0 * m;
    DimensionlessSpectrum transmittance_to_ground = DimensionlessSpectrum(0.0);
    DimensionlessSpectrum ground_albedo = DimensionlessSpectrum(0.0);
    if (ray_r_theta_intersects_ground) {
      distance_to_ground =
          DistanceToBottomAtmosphereBoundary(atmosphere, r, cos_theta);
      transmittance_to_ground =
          GetTransmittance(atmosphere, transmittance_texture, r, cos_theta,
              distance_to_ground, true /* ray_intersects_ground */);
      ground_albedo = atmosphere.ground_albedo;
    }

    for (int m = 0; m < 2 * SAMPLE_COUNT; ++m) {
      Angle phi = (Number(m) + 0.5) * dphi;
      vec3 omega_i =
          vec3(cos(phi) * sin_theta, sin(phi) * sin_theta, cos_theta);
      SolidAngle domega_i = (dtheta / rad) * (dphi / rad) * sin(theta) * sr;

      // The radiance L_i arriving from direction omega_i after n-1 bounces is
      // the sum of a term given by the precomputed scattering texture for the
      // (n-1)-th order:
      Number nu1 = dot(omega_s, omega_i);
      RadianceSpectrum incident_radiance = GetScattering(atmosphere,
          single_rayleigh_scattering_texture, single_mie_scattering_texture,
          multiple_scattering_texture, r, omega_i.z, mu_s, nu1,
          ray_r_theta_intersects_ground, scattering_order - 1);

      // and of the contribution from the light paths with n-1 bounces and whose
      // last bounce is on the ground. This contribution is the product of the
      // transmittance to the ground, the ground albedo, the ground BRDF, and
      // the irradiance received on the ground after n-2 bounces.
      vec3 ground_normal =
          normalize(zenith_direction * r + omega_i * distance_to_ground);
      IrradianceSpectrum ground_irradiance = GetIrradiance(
          atmosphere, irradiance_texture, atmosphere.bottom_radius,
          dot(ground_normal, omega_s));
      incident_radiance += transmittance_to_ground *
          ground_albedo * (1.0 / (PI * sr)) * ground_irradiance;

      // The radiance finally scattered from direction omega_i towards direction
      // -omega is the product of the incident radiance, the scattering
      // coefficient, and the phase function for directions omega and omega_i
      // (all this summed over all particle types, i.e. Rayleigh and Mie).
      Number nu2 = dot(omega, omega_i);
      Number rayleigh_density = GetProfileDensity(
          atmosphere.rayleigh_density, r - atmosphere.bottom_radius);
      Number mie_density = GetProfileDensity(
          atmosphere.mie_density, r - atmosphere.bottom_radius);
      rayleigh_mie += incident_radiance * (
          atmosphere.rayleigh_scattering * rayleigh_density *
              RayleighPhaseFunction(nu2) +
          atmosphere.mie_scattering * mie_density *
              MiePhaseFunction(atmosphere.mie_phase_function_g, nu2)) *
          domega_i;
    }
  }
  return rayleigh_mie;
}

RadianceSpectrum ComputeMultipleScattering(
    const AtmosphereParameters atmosphere,
    const TransmittanceTexture transmittance_texture,
    const ScatteringDensityTexture scattering_density_texture,
    const Length r, const Number mu, const Number mu_s, const Number nu,
    const bool ray_r_mu_intersects_ground) {
  assert(r >= atmosphere.bottom_radius && r <= atmosphere.top_radius);
  assert(mu >= -1.0 && mu <= 1.0);
  assert(mu_s >= -1.0 && mu_s <= 1.0);
  assert(nu >= -1.0 && nu <= 1.0);

  // Number of intervals for the numerical integration.
  const int SAMPLE_COUNT = 50;
  // The integration step, i.e. the length of each integration interval.
  Length dx =
      DistanceToNearestAtmosphereBoundary(
          atmosphere, r, mu, ray_r_mu_intersects_ground) /
              Number(SAMPLE_COUNT);
  // Integration loop.
  RadianceSpectrum rayleigh_mie_sum =
      RadianceSpectrum(0.0 * watt_per_square_meter_per_sr_per_nm);
  for (int i = 0; i <= SAMPLE_COUNT; ++i) {
    Length d_i = Number(i) * dx;

    // The r, mu and mu_s parameters at the current integration point (see the
    // single scattering section for a detailed explanation).
    Length r_i =
        ClampRadius(atmosphere, sqrt(d_i * d_i + 2.0 * r * mu * d_i + r * r));
    Number mu_i = ClampCosine((r * mu + d_i) / r_i);
    Number mu_s_i = ClampCosine((r * mu_s + d_i * nu) / r_i);

    // The Rayleigh and Mie multiple scattering at the current sample point.
    RadianceSpectrum rayleigh_mie_i =
        GetScattering(
            atmosphere, scattering_density_texture, r_i, mu_i, mu_s_i, nu,
            ray_r_mu_intersects_ground) *
        GetTransmittance(
            atmosphere, transmittance_texture, r, mu, d_i,
            ray_r_mu_intersects_ground) *
        dx;
    // Sample weight (from the trapezoidal rule).
    Number weight_i = (i == 0 || i == SAMPLE_COUNT) ? 0.5 : 1.0;
    rayleigh_mie_sum += rayleigh_mie_i * weight_i;
  }
  return rayleigh_mie_sum;
}

RadianceDensitySpectrum ComputeScatteringDensityTexture(
    const AtmosphereParameters atmosphere,
    const TransmittanceTexture transmittance_texture,
    const ReducedScatteringTexture single_rayleigh_scattering_texture,
    const ReducedScatteringTexture single_mie_scattering_texture,
    const ScatteringTexture multiple_scattering_texture,
    const IrradianceTexture irradiance_texture,
    const vec3 frag_coord, const int scattering_order) {
  Length r;
  Number mu;
  Number mu_s;
  Number nu;
  bool ray_r_mu_intersects_ground;
  GetRMuMuSNuFromScatteringTextureFragCoord(atmosphere, frag_coord,
      r, mu, mu_s, nu, ray_r_mu_intersects_ground);
  return ComputeScatteringDensity(atmosphere, transmittance_texture,
      single_rayleigh_scattering_texture, single_mie_scattering_texture,
      multiple_scattering_texture, irradiance_texture, r, mu, mu_s, nu,
      scattering_order);
}

RadianceSpectrum ComputeMultipleScatteringTexture(
    const AtmosphereParameters atmosphere,
    const TransmittanceTexture transmittance_texture,
    const ScatteringDensityTexture scattering_density_texture,
    const vec3 frag_coord, out Number nu) {
  Length r;
  Number mu;
  Number mu_s;
  bool ray_r_mu_intersects_ground;
  GetRMuMuSNuFromScatteringTextureFragCoord(atmosphere, frag_coord,
      r, mu, mu_s, nu, ray_r_mu_intersects_ground);
  return ComputeMultipleScattering(atmosphere, transmittance_texture,
      scattering_density_texture, r, mu, mu_s, nu,
      ray_r_mu_intersects_ground);
}

IrradianceSpectrum ComputeDirectIrradiance(
    const AtmosphereParameters atmosphere,
    const TransmittanceTexture transmittance_texture,
    const Length r, const Number mu_s) {
  assert(r >= atmosphere.bottom_radius && r <= atmosphere.top_radius);
  assert(mu_s >= -1.0 && mu_s <= 1.0);

  Number alpha_s = atmosphere.sun_angular_radius / rad;
  // Approximate average of the cosine factor mu_s over the visible fraction of
  // the Sun disc.
  Number average_cosine_factor =
    mu_s < -alpha_s ? 0.0 : (mu_s > alpha_s ? mu_s :
        (mu_s + alpha_s) * (mu_s + alpha_s) / (4.0 * alpha_s));

  return atmosphere.solar_irradiance *
      GetTransmittanceToTopAtmosphereBoundary(
          atmosphere, transmittance_texture, r, mu_s) * average_cosine_factor;

}

IrradianceSpectrum ComputeIndirectIrradiance(
    const AtmosphereParameters atmosphere,
    const ReducedScatteringTexture single_rayleigh_scattering_texture,
    const ReducedScatteringTexture single_mie_scattering_texture,
    const ScatteringTexture multiple_scattering_texture,
    const Length r, const Number mu_s, const int scattering_order) {
  assert(r >= atmosphere.bottom_radius && r <= atmosphere.top_radius);
  assert(mu_s >= -1.0 && mu_s <= 1.0);
  assert(scattering_order >= 1);

  const int SAMPLE_COUNT = 32;
  const Angle dphi = pi / Number(SAMPLE_COUNT);
  const Angle dtheta = pi / Number(SAMPLE_COUNT);

  IrradianceSpectrum result =
      IrradianceSpectrum(0.0 * watt_per_square_meter_per_nm);
  vec3 omega_s = vec3(sqrt(1.0 - mu_s * mu_s), 0.0, mu_s);
  for (int j = 0; j < SAMPLE_COUNT / 2; ++j) {
    Angle theta = (Number(j) + 0.5) * dtheta;
    for (int i = 0; i < 2 * SAMPLE_COUNT; ++i) {
      Angle phi = (Number(i) + 0.5) * dphi;
      vec3 omega =
          vec3(cos(phi) * sin(theta), sin(phi) * sin(theta), cos(theta));
      SolidAngle domega = (dtheta / rad) * (dphi / rad) * sin(theta) * sr;

      Number nu = dot(omega, omega_s);
      result += GetScattering(atmosphere, single_rayleigh_scattering_texture,
          single_mie_scattering_texture, multiple_scattering_texture,
          r, omega.z, mu_s, nu, false /* ray_r_theta_intersects_ground */,
          scattering_order) *
              omega.z * domega;
    }
  }
  return result;
}

void GetRMuSFromIrradianceTextureUv(const AtmosphereParameters atmosphere,
    const vec2 uv, out Length r, out Number mu_s) {
  assert(uv.x >= 0.0 && uv.x <= 1.0);
  assert(uv.y >= 0.0 && uv.y <= 1.0);
  Number x_mu_s = GetUnitRangeFromTextureCoord(uv.x, IRRADIANCE_TEXTURE_WIDTH);
  Number x_r = GetUnitRangeFromTextureCoord(uv.y, IRRADIANCE_TEXTURE_HEIGHT);
  r = atmosphere.bottom_radius +
      x_r * (atmosphere.top_radius - atmosphere.bottom_radius);
  mu_s = ClampCosine(2.0 * x_mu_s - 1.0);
}

const vec2 IRRADIANCE_TEXTURE_SIZE =
    vec2(IRRADIANCE_TEXTURE_WIDTH, IRRADIANCE_TEXTURE_HEIGHT);

IrradianceSpectrum ComputeDirectIrradianceTexture(
    const AtmosphereParameters atmosphere,
    const TransmittanceTexture transmittance_texture,
    const vec2 frag_coord) {
  Length r;
  Number mu_s;
  GetRMuSFromIrradianceTextureUv(
      atmosphere, frag_coord / IRRADIANCE_TEXTURE_SIZE, r, mu_s);
  return ComputeDirectIrradiance(atmosphere, transmittance_texture, r, mu_s);
}

IrradianceSpectrum ComputeIndirectIrradianceTexture(
    const AtmosphereParameters atmosphere,
    const ReducedScatteringTexture single_rayleigh_scattering_texture,
    const ReducedScatteringTexture single_mie_scattering_texture,
    const ScatteringTexture multiple_scattering_texture,
    const vec2 frag_coord, const int scattering_order) {
  Length r;
  Number mu_s;
  GetRMuSFromIrradianceTextureUv(
      atmosphere, frag_coord / IRRADIANCE_TEXTURE_SIZE, r, mu_s);
  return ComputeIndirectIrradiance(atmosphere,
      single_rayleigh_scattering_texture, single_mie_scattering_texture,
      multiple_scattering_texture, r, mu_s, scattering_order);
}
`;

// node_modules/@takram/three-atmosphere/build/shared.js
var Mt = "6ad51c78a0d059c05da26c5b5addd73ad48ba618";
var Mi = `https://media.githubusercontent.com/media/takram-design-engineering/three-geospatial/${Mt}/packages/atmosphere/assets`;
var yi = `https://media.githubusercontent.com/media/takram-design-engineering/three-geospatial/${Mt}/packages/atmosphere/assets/stars.bin`;
var s0 = 64;
var c0 = 16;
var se = 32;
var ce = 128;
var ue = 32;
var le = 8;
var n0 = le * ue;
var r0 = ce;
var i0 = se;
var u0 = 256;
var l0 = 64;
var ee = 1 / 1e3;
var Ci = 100;
var Di = new Matrix3(
  3.2406255,
  -1.537208,
  -0.4986286,
  -0.9689307,
  1.8757561,
  0.0415175,
  0.0557101,
  -0.2040211,
  1.0569959
);
var Pn = new Vector3(0.2126, 0.7152, 0.0722);
var Nn = [
  "solarIrradiance",
  "sunAngularRadius",
  "bottomRadius",
  "topRadius",
  "rayleighDensity",
  "rayleighScattering",
  "mieDensity",
  "mieScattering",
  "mieExtinction",
  "miePhaseFunctionG",
  "absorptionDensity",
  "absorptionExtinction",
  "groundAlbedo",
  "muSMin",
  "skyRadianceToLuminance",
  "sunRadianceToLuminance"
];
function On(n3, e3) {
  if (e3 != null)
    for (const t2 of Nn) {
      const r3 = e3[t2];
      r3 != null && (n3[t2] instanceof Vector3 ? n3[t2].copy(r3) : n3[t2] = r3);
    }
}
var g0 = class {
  constructor(e3, t2, r3, i2, o2) {
    this.width = e3, this.expTerm = t2, this.expScale = r3, this.linearTerm = i2, this.constantTerm = o2;
  }
  // eslint-disable-next-line @typescript-eslint/explicit-function-return-type
  toUniform() {
    return new Uniform({
      width: this.width,
      exp_term: this.expTerm,
      exp_scale: this.expScale,
      linear_term: this.linearTerm,
      constant_term: this.constantTerm
    });
  }
};
var ie = class ie2 {
  constructor(e3) {
    this.solarIrradiance = new Vector3(1.474, 1.8504, 1.91198), this.sunAngularRadius = 4675e-6, this.bottomRadius = 636e4, this.topRadius = 642e4, this.rayleighDensity = [
      new g0(0, 0, 0, 0, 0),
      new g0(0, 1, -0.125, 0, 0)
    ], this.rayleighScattering = new Vector3(5802e-6, 0.013558, 0.0331), this.mieDensity = [
      new g0(0, 0, 0, 0, 0),
      new g0(0, 1, -0.833333, 0, 0)
    ], this.mieScattering = new Vector3(3996e-6, 3996e-6, 3996e-6), this.mieExtinction = new Vector3(444e-5, 444e-5, 444e-5), this.miePhaseFunctionG = 0.8, this.absorptionDensity = [
      new g0(25, 0, 0, 1 / 15, -2 / 3),
      new g0(0, 0, 0, -1 / 15, 8 / 3)
    ], this.absorptionExtinction = new Vector3(65e-5, 1881e-6, 85e-6), this.groundAlbedo = new Color().setScalar(0.1), this.muSMin = Math.cos(Eo(120)), this.sunRadianceToLuminance = new Vector3(98242.786222, 69954.398112, 66475.012354), this.skyRadianceToLuminance = new Vector3(114974.916437, 71305.954816, 65310.548555), this.sunRadianceToRelativeLuminance = new Vector3(), this.skyRadianceToRelativeLuminance = new Vector3(), On(this, e3);
    const t2 = Pn.dot(this.sunRadianceToLuminance);
    this.sunRadianceToRelativeLuminance.copy(this.sunRadianceToLuminance).divideScalar(t2), this.skyRadianceToRelativeLuminance.copy(this.skyRadianceToLuminance).divideScalar(t2);
  }
  // eslint-disable-next-line @typescript-eslint/explicit-function-return-type
  toUniform() {
    return new Uniform({
      solar_irradiance: this.solarIrradiance,
      sun_angular_radius: this.sunAngularRadius,
      bottom_radius: this.bottomRadius * ee,
      top_radius: this.topRadius * ee,
      rayleigh_density: {
        layers: this.rayleighDensity.map((e3) => e3.toUniform().value)
      },
      rayleigh_scattering: this.rayleighScattering,
      mie_density: {
        layers: this.mieDensity.map((e3) => e3.toUniform().value)
      },
      mie_scattering: this.mieScattering,
      mie_extinction: this.mieExtinction,
      mie_phase_function_g: this.miePhaseFunctionG,
      absorption_density: {
        layers: this.absorptionDensity.map((e3) => e3.toUniform().value)
      },
      absorption_extinction: this.absorptionExtinction,
      ground_albedo: this.groundAlbedo,
      mu_s_min: this.muSMin
    });
  }
};
ie.DEFAULT = new ie();
var J = ie;
var Ln = new Vector3();
function ze(n3, e3, t2, r3) {
  const i2 = t2.projectOnSurface(
    n3,
    Ln
  );
  return i2 != null ? t2.getOsculatingSphereCenter(i2, e3, r3).negate() : r3.setScalar(0);
}
var Hn = `precision highp sampler2DArray;

#include "core/depth"
#include "core/math"
#include "core/packing"
#include "core/transform"
#ifdef HAS_SHADOW
#include "core/raySphereIntersection"
#include "core/cascadedShadowMaps"
#include "core/interleavedGradientNoise"
#include "core/vogelDisk"
#endif // HAS_SHADOW

#include "bruneton/definitions"

uniform AtmosphereParameters ATMOSPHERE;
uniform vec3 SUN_SPECTRAL_RADIANCE_TO_LUMINANCE;
uniform vec3 SKY_SPECTRAL_RADIANCE_TO_LUMINANCE;

uniform sampler2D transmittance_texture;
uniform sampler3D scattering_texture;
uniform sampler2D irradiance_texture;
uniform sampler3D single_mie_scattering_texture;
uniform sampler3D higher_order_scattering_texture;

#include "bruneton/common"
#include "bruneton/runtime"

#include "sky"

uniform sampler2D normalBuffer;

uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat4 inverseProjectionMatrix;
uniform mat4 inverseViewMatrix;
uniform float bottomRadius;
uniform mat4 worldToECEFMatrix;
uniform float geometricErrorCorrectionAmount;
uniform vec3 sunDirection;
uniform vec3 moonDirection;
uniform float moonAngularRadius;
uniform float lunarRadianceScale;
uniform float albedoScale;

#ifdef HAS_LIGHTING_MASK
uniform sampler2D lightingMaskBuffer;
#endif // HAS_LIGHTING_MASK

// prettier-ignore
#define LIGHTING_MASK_CHANNEL_ LIGHTING_MASK_CHANNEL

#ifdef HAS_OVERLAY
uniform sampler2D overlayBuffer;
#endif // HAS_OVERLAY

#ifdef HAS_SHADOW
uniform sampler2DArray shadowBuffer;
uniform vec2 shadowIntervals[SHADOW_CASCADE_COUNT];
uniform mat4 shadowMatrices[SHADOW_CASCADE_COUNT];
uniform mat4 inverseShadowMatrices[SHADOW_CASCADE_COUNT];
uniform float shadowFar;
uniform float shadowTopHeight;
uniform float shadowRadius;
uniform sampler3D stbnTexture;
uniform int frame;
#endif // HAS_SHADOW

#ifdef HAS_SHADOW_LENGTH
uniform sampler2D shadowLengthBuffer;
#endif // HAS_SHADOW_LENGTH

varying vec3 vCameraPosition;
varying vec3 vRayDirection;
varying vec3 vGeometryAltitudeCorrection;
varying vec3 vEllipsoidRadiiSquared;

vec3 readNormal(const vec2 uv) {
  #ifdef OCT_ENCODED_NORMAL
  return unpackVec2ToNormal(texture(normalBuffer, uv).xy);
  #else // OCT_ENCODED_NORMAL
  return 2.0 * texture(normalBuffer, uv).xyz - 1.0;
  #endif // OCT_ENCODED_NORMAL
}

void correctGeometricError(inout vec3 positionECEF, inout vec3 normalECEF) {
  // TODO: The error is pronounced at the edge of the ellipsoid due to the
  // large difference between the sphere position and the unprojected position
  // at the current fragment. Calculating the sphere position from the fragment
  // UV may resolve this.

  // Correct way is slerp, but this will be small-angle interpolation anyways.
  vec3 sphereNormal = normalize(positionECEF / vEllipsoidRadiiSquared);
  vec3 spherePosition = ATMOSPHERE.bottom_radius * sphereNormal;
  normalECEF = mix(normalECEF, sphereNormal, geometricErrorCorrectionAmount);
  positionECEF = mix(positionECEF, spherePosition, geometricErrorCorrectionAmount);
}

#if defined(SUN_LIGHT) || defined(SKY_LIGHT)

vec3 getSunSkyIrradiance(
  const vec3 positionECEF,
  const vec3 normal,
  const vec3 inputColor,
  const float sunTransmittance
) {
  // Assume lambertian BRDF. If both SUN_LIGHT and SKY_LIGHT are not defined,
  // regard the inputColor as radiance at the texel.
  vec3 diffuse = inputColor * albedoScale * RECIPROCAL_PI;
  vec3 skyIrradiance;
  vec3 sunIrradiance = GetSunAndSkyIrradiance(positionECEF, normal, sunDirection, skyIrradiance);

  #ifdef HAS_SHADOW
  sunIrradiance *= sunTransmittance;
  #endif // HAS_SHADOW

  #if defined(SUN_LIGHT) && defined(SKY_LIGHT)
  return diffuse * (sunIrradiance + skyIrradiance);
  #elif defined(SUN_LIGHT)
  return diffuse * sunIrradiance;
  #elif defined(SKY_LIGHT)
  return diffuse * skyIrradiance;
  #endif // defined(SUN_LIGHT) && defined(SKY_LIGHT)
}

#endif // defined(SUN_LIGHT) || defined(SKY_LIGHT)

#if defined(TRANSMITTANCE) || defined(INSCATTER)

void applyTransmittanceInscatter(const vec3 positionECEF, float shadowLength, inout vec3 radiance) {
  vec3 transmittance;
  vec3 inscatter = GetSkyRadianceToPoint(
    vCameraPosition,
    positionECEF,
    shadowLength,
    sunDirection,
    transmittance
  );
  #ifdef TRANSMITTANCE
  radiance = radiance * transmittance;
  #endif // TRANSMITTANCE
  #ifdef INSCATTER
  radiance = radiance + inscatter;
  #endif // INSCATTER
}

#endif // defined(TRANSMITTANCE) || defined(INSCATTER)

#ifdef HAS_SHADOW

float getSTBN() {
  ivec3 size = textureSize(stbnTexture, 0);
  vec3 scale = 1.0 / vec3(size);
  return texture(stbnTexture, vec3(gl_FragCoord.xy, float(frame % size.z)) * scale).r;
}

vec2 getShadowUv(const vec3 worldPosition, const int cascadeIndex) {
  vec4 clip = shadowMatrices[cascadeIndex] * vec4(worldPosition, 1.0);
  clip /= clip.w;
  return clip.xy * 0.5 + 0.5;
}

float getDistanceToShadowTop(const vec3 positionECEF) {
  // Distance to the top of the shadows along the sun direction, which matches
  // the ray origin of BSM.
  return raySphereSecondIntersection(
    positionECEF / METER_TO_LENGTH_UNIT, // TODO: Make units consistent
    sunDirection,
    vec3(0.0),
    bottomRadius + shadowTopHeight
  );
}

float readShadowOpticalDepth(const vec2 uv, const float distanceToTop, const int cascadeIndex) {
  // r: frontDepth, g: meanExtinction, b: maxOpticalDepth, a: maxOpticalDepthTail
  vec4 shadow = texture(shadowBuffer, vec3(uv, float(cascadeIndex)));
  // Omit adding maxOpticalDepthTail to avoid pronounced aliasing. Ground
  // shadow will be attenuated by inscatter anyways.
  return min(shadow.b, shadow.g * max(0.0, distanceToTop - shadow.r));
}

float sampleShadowOpticalDepthPCF(
  const vec3 worldPosition,
  const float distanceToTop,
  const float radius,
  const int cascadeIndex
) {
  vec2 uv = getShadowUv(worldPosition, cascadeIndex);
  if (uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0) {
    return 0.0;
  }

  vec2 texelSize = vec2(1.0) / vec2(textureSize(shadowBuffer, 0).xy);
  float sum = 0.0;
  vec2 offset;
  #pragma unroll_loop_start
  for (int i = 0; i < 16; ++i) {
    #if UNROLLED_LOOP_INDEX < SHADOW_SAMPLE_COUNT
    offset = vogelDisk(
      UNROLLED_LOOP_INDEX,
      SHADOW_SAMPLE_COUNT,
      interleavedGradientNoise(gl_FragCoord.xy) * PI2
    );
    sum += readShadowOpticalDepth(uv + offset * radius * texelSize, distanceToTop, cascadeIndex);
    #endif // UNROLLED_LOOP_INDEX < SHADOW_SAMPLE_COUNT
  }
  #pragma unroll_loop_end
  return sum / float(SHADOW_SAMPLE_COUNT);
}

float sampleShadowOpticalDepth(
  const vec3 worldPosition,
  const vec3 positionECEF,
  const float radius,
  const float jitter
) {
  float distanceToTop = getDistanceToShadowTop(positionECEF);
  if (distanceToTop <= 0.0) {
    return 0.0;
  }
  int cascadeIndex = getFadedCascadeIndex(
    viewMatrix,
    worldPosition,
    shadowIntervals,
    cameraNear,
    shadowFar,
    jitter
  );
  return cascadeIndex >= 0
    ? sampleShadowOpticalDepthPCF(worldPosition, distanceToTop, radius, cascadeIndex)
    : 0.0;
}

float getShadowRadius(const vec3 worldPosition) {
  vec4 clip = shadowMatrices[0] * vec4(worldPosition, 1.0);
  clip /= clip.w;

  // Offset by 1px in each direction in shadow's clip coordinates.
  vec2 shadowSize = vec2(textureSize(shadowBuffer, 0));
  vec3 offset = vec3(2.0 / shadowSize, 0.0);
  vec4 clipX = clip + offset.xzzz;
  vec4 clipY = clip + offset.zyzz;

  // Convert back to world space.
  vec4 worldX = inverseShadowMatrices[0] * clipX;
  vec4 worldY = inverseShadowMatrices[0] * clipY;

  // Project into the main camera's clip space.
  mat4 viewProjectionMatrix = projectionMatrix * viewMatrix;
  vec4 projected = viewProjectionMatrix * vec4(worldPosition, 1.0);
  vec4 projectedX = viewProjectionMatrix * worldX;
  vec4 projectedY = viewProjectionMatrix * worldY;
  projected /= projected.w;
  projectedX /= projectedX.w;
  projectedY /= projectedY.w;

  // Take the mean of pixel sizes.
  vec2 center = (projected.xy * 0.5 + 0.5) * resolution;
  vec2 offsetX = (projectedX.xy * 0.5 + 0.5) * resolution;
  vec2 offsetY = (projectedY.xy * 0.5 + 0.5) * resolution;
  float size = max(length(offsetX - center), length(offsetY - center));

  return remapClamped(size, 10.0, 50.0, 0.0, shadowRadius);
}

#endif // HAS_SHADOW

void mainImage(const vec4 inputColor, const vec2 uv, out vec4 outputColor) {
  #if defined(HAS_LIGHTING_MASK) && defined(DEBUG_SHOW_LIGHTING_MASK)
  outputColor.rgb = vec3(texture(lightingMaskBuffer, uv).LIGHTING_MASK_CHANNEL_);
  outputColor.a = 1.0;
  return;
  #endif // defined(HAS_LIGHTING_MASK) && defined(DEBUG_SHOW_LIGHTING_MASK)

  float shadowLength = 0.0;
  #ifdef HAS_SHADOW_LENGTH
  shadowLength = texture(shadowLengthBuffer, uv).r;
  #endif // HAS_SHADOW_LENGTH

  #ifdef HAS_OVERLAY
  vec4 overlay = texture(overlayBuffer, uv);
  if (overlay.a == 1.0) {
    outputColor = overlay;
    return;
  }
  #endif // HAS_OVERLAY

  float depth = readDepth(uv);
  if (depth >= 1.0 - 1e-8) {
    #ifdef SKY
    vec3 rayDirection = normalize(vRayDirection);
    outputColor.rgb = getSkyRadiance(
      vCameraPosition,
      rayDirection,
      shadowLength,
      sunDirection,
      moonDirection,
      moonAngularRadius,
      lunarRadianceScale
    );
    outputColor.a = 1.0;
    #else // SKY
    outputColor = inputColor;
    #endif // SKY

    #ifdef HAS_OVERLAY
    outputColor.rgb = outputColor.rgb * (1.0 - overlay.a) + overlay.rgb;
    #endif // HAS_OVERLAY
    return;
  }
  depth = reverseLogDepth(depth, cameraNear, cameraFar);

  // Reconstruct position and normal in world space.
  vec3 viewPosition = screenToView(
    uv,
    depth,
    getViewZ(depth),
    projectionMatrix,
    inverseProjectionMatrix
  );
  vec3 viewNormal;
  #ifdef RECONSTRUCT_NORMAL
  vec3 dx = dFdx(viewPosition);
  vec3 dy = dFdy(viewPosition);
  viewNormal = normalize(cross(dx, dy));
  #else // RECONSTRUCT_NORMAL
  viewNormal = readNormal(uv);
  #endif // RECONSTRUCT_NORMAL

  vec3 worldPosition = (inverseViewMatrix * vec4(viewPosition, 1.0)).xyz;
  vec3 worldNormal = (inverseViewMatrix * vec4(viewNormal, 0.0)).xyz;
  vec3 positionECEF = (worldToECEFMatrix * vec4(worldPosition, 1.0)).xyz;
  positionECEF = positionECEF * METER_TO_LENGTH_UNIT + vGeometryAltitudeCorrection;
  vec3 normalECEF = (worldToECEFMatrix * vec4(worldNormal, 0.0)).xyz;

  #ifdef CORRECT_GEOMETRIC_ERROR
  correctGeometricError(positionECEF, normalECEF);
  #endif // CORRECT_GEOMETRIC_ERROR

  #ifdef HAS_SHADOW
  float stbn = getSTBN();
  float radius = getShadowRadius(worldPosition);
  float opticalDepth = sampleShadowOpticalDepth(worldPosition, positionECEF, radius, stbn);
  float sunTransmittance = exp(-opticalDepth);
  #else // HAS_SHADOW
  float sunTransmittance = 1.0;
  #endif // HAS_SHADOW

  vec3 radiance;
  #if defined(SUN_LIGHT) || defined(SKY_LIGHT)
  radiance = getSunSkyIrradiance(positionECEF, normalECEF, inputColor.rgb, sunTransmittance);
  #ifdef HAS_LIGHTING_MASK
  float lightingMask = texture(lightingMaskBuffer, uv).LIGHTING_MASK_CHANNEL_;
  radiance = mix(inputColor.rgb, radiance, lightingMask);
  #endif // HAS_LIGHTING_MASK
  #else // defined(SUN_LIGHT) || defined(SKY_LIGHT)
  radiance = inputColor.rgb;
  #endif // defined(SUN_LIGHT) || defined(SKY_LIGHT)

  #if defined(TRANSMITTANCE) || defined(INSCATTER)
  applyTransmittanceInscatter(positionECEF, shadowLength, radiance);
  #endif // defined(TRANSMITTANCE) || defined(INSCATTER)

  outputColor = vec4(radiance, inputColor.a);

  #ifdef HAS_OVERLAY
  outputColor.rgb = outputColor.rgb * (1.0 - overlay.a) + overlay.rgb;
  #endif // HAS_OVERLAY
}
`;
var Un = `uniform mat4 inverseViewMatrix;
uniform mat4 inverseProjectionMatrix;
uniform vec3 cameraPosition;
uniform mat4 worldToECEFMatrix;
uniform vec3 altitudeCorrection;
uniform float geometricErrorCorrectionAmount;
uniform vec3 ellipsoidRadii;

varying vec3 vCameraPosition;
varying vec3 vRayDirection;
varying vec3 vGeometryAltitudeCorrection;
varying vec3 vEllipsoidRadiiSquared;

void getCameraRay(out vec3 origin, out vec3 direction) {
  bool isPerspective = inverseProjectionMatrix[2][3] != 0.0; // 4th entry in the 3rd column

  if (isPerspective) {
    // Calculate the camera ray for a perspective camera.
    vec4 viewPosition = inverseProjectionMatrix * vec4(position, 1.0);
    vec4 worldDirection = inverseViewMatrix * vec4(viewPosition.xyz, 0.0);
    origin = cameraPosition;
    direction = worldDirection.xyz;
  } else {
    // Unprojected points to calculate direction.
    vec4 nearPoint = inverseProjectionMatrix * vec4(position.xy, -1.0, 1.0);
    vec4 farPoint = inverseProjectionMatrix * vec4(position.xy, -0.9, 1.0);
    nearPoint /= nearPoint.w;
    farPoint /= farPoint.w;

    // Calculate world values.
    vec4 worldDirection = inverseViewMatrix * vec4(farPoint.xyz - nearPoint.xyz, 0.0);
    vec4 worldOrigin = inverseViewMatrix * nearPoint;

    // Outputs
    direction = worldDirection.xyz;
    origin = worldOrigin.xyz;
  }
}

void mainSupport() {
  vec3 direction, origin;
  getCameraRay(origin, direction);

  vec3 cameraPositionECEF = (worldToECEFMatrix * vec4(origin, 1.0)).xyz;
  vCameraPosition = (cameraPositionECEF + altitudeCorrection) * METER_TO_LENGTH_UNIT;
  vRayDirection = (worldToECEFMatrix * vec4(direction, 0.0)).xyz;

  vGeometryAltitudeCorrection = altitudeCorrection * METER_TO_LENGTH_UNIT;
  // Gradually turn off the altitude correction on geometries as the geometric
  // error correction takes effect, because that on the ideal sphere will be
  // over corrected.
  // See: https://github.com/takram-design-engineering/three-geospatial/pull/23#issuecomment-2542914656
  #ifdef CORRECT_GEOMETRIC_ERROR
  vGeometryAltitudeCorrection *= 1.0 - geometricErrorCorrectionAmount;
  #endif // CORRECT_GEOMETRIC_ERROR

  vec3 radii = ellipsoidRadii * METER_TO_LENGTH_UNIT;
  vEllipsoidRadiiSquared = radii * radii;
}
`;
var yt = `vec3 getLunarRadiance(const float moonAngularRadius) {
  // Not a physical number but the order of 10^-6 relative to the sun may fit.
  vec3 radiance =
    ATMOSPHERE.solar_irradiance *
    0.000002 /
    (PI * moonAngularRadius * moonAngularRadius) *
    SUN_SPECTRAL_RADIANCE_TO_LUMINANCE;
  return radiance;
}

float intersectSphere(const vec3 ray, const vec3 point, const float radius) {
  vec3 P = -point;
  float PoR = dot(P, ray);
  float D = dot(P, P) - radius * radius;
  return -PoR - sqrt(PoR * PoR - D);
}

float orenNayarDiffuse(const vec3 L, const vec3 V, const vec3 N) {
  float NoL = dot(N, L);
  float NoV = dot(N, V);
  float s = dot(L, V) - NoL * NoV;
  float t = mix(1.0, max(NoL, NoV), step(0.0, s));
  return max(0.0, NoL) * (0.62406015 + 0.41284404 * s / t);
}

vec3 getSkyRadiance(
  const vec3 cameraPosition,
  const vec3 rayDirection,
  const float shadowLength,
  const vec3 sunDirection,
  const vec3 moonDirection,
  const float moonAngularRadius,
  const float lunarRadianceScale
) {
  vec3 transmittance;
  vec3 radiance = GetSkyRadiance(
    cameraPosition,
    rayDirection,
    shadowLength,
    sunDirection,
    transmittance
  );

  // Rendering celestial objects without perspective doesn't make sense.
  #ifdef PERSPECTIVE_CAMERA

  #if defined(SUN) || defined(MOON)
  vec3 ddx = dFdx(rayDirection);
  vec3 ddy = dFdy(rayDirection);
  float fragmentAngle = length(ddx + ddy) / length(rayDirection);
  #endif // defined(SUN) || defined(MOON)

  #ifdef SUN
  float viewDotSun = dot(rayDirection, sunDirection);
  if (viewDotSun > cos(ATMOSPHERE.sun_angular_radius)) {
    float angle = acos(clamp(viewDotSun, -1.0, 1.0));
    float antialias = smoothstep(
      ATMOSPHERE.sun_angular_radius,
      ATMOSPHERE.sun_angular_radius - fragmentAngle,
      angle
    );
    radiance += transmittance * GetSolarRadiance() * antialias;
  }
  #endif // SUN

  #ifdef MOON
  float intersection = intersectSphere(rayDirection, moonDirection, moonAngularRadius);
  if (intersection > 0.0) {
    vec3 normal = normalize(moonDirection - rayDirection * intersection);
    float diffuse = orenNayarDiffuse(-sunDirection, rayDirection, normal);
    float viewDotMoon = dot(rayDirection, moonDirection);
    float angle = acos(clamp(viewDotMoon, -1.0, 1.0));
    float antialias = smoothstep(moonAngularRadius, moonAngularRadius - fragmentAngle, angle);
    radiance +=
      transmittance *
      getLunarRadiance(moonAngularRadius) *
      lunarRadianceScale *
      diffuse *
      antialias;
  }
  #endif // MOON

  #endif // PERSPECTIVE_CAMERA

  return radiance;
}
`;
var bn = Object.defineProperty;
var O = (n3, e3, t2, r3) => {
  for (var i2 = void 0, o2 = n3.length - 1, a2; o2 >= 0; o2--)
    (a2 = n3[o2]) && (i2 = a2(e3, t2, i2) || i2);
  return i2 && bn(e3, t2, i2), i2;
};
var Gn = new Vector3();
var Fn = new Vector3();
var zn = new C();
var kn = {
  blendFunction: BlendFunction.NORMAL,
  octEncodedNormal: false,
  reconstructNormal: false,
  ellipsoid: b.WGS84,
  correctAltitude: true,
  correctGeometricError: true,
  sunLight: false,
  skyLight: false,
  transmittance: true,
  inscatter: true,
  albedoScale: 1,
  sky: false,
  sun: true,
  moon: true,
  moonAngularRadius: 45e-4,
  //  15.5 arcminutes
  lunarRadianceScale: 1,
  ground: true
};
var L2 = class extends Effect {
  constructor(e3 = new Camera(), t2, r3 = J.DEFAULT) {
    const {
      blendFunction: i2,
      normalBuffer: o2 = null,
      octEncodedNormal: a2,
      reconstructNormal: c3,
      irradianceTexture: s = null,
      scatteringTexture: d2 = null,
      transmittanceTexture: h2 = null,
      singleMieScatteringTexture: m3 = null,
      higherOrderScatteringTexture: f2 = null,
      ellipsoid: T2,
      correctAltitude: p3,
      correctGeometricError: E,
      sunDirection: R,
      sunIrradiance: D2,
      sunLight: P2,
      skyIrradiance: N,
      skyLight: H,
      transmittance: G,
      inscatter: B,
      irradianceScale: F,
      albedoScale: H0,
      sky: M0,
      sun: U0,
      moon: b0,
      moonDirection: Q,
      moonAngularRadius: G0,
      lunarRadianceScale: F0,
      ground: h0
    } = { ...kn, ...t2 };
    super(
      "AerialPerspectiveEffect",
      $o(
        io(Hn, {
          core: {
            depth: d,
            packing: p,
            math: f,
            transform: h,
            raySphereIntersection: u,
            cascadedShadowMaps: m2,
            interleavedGradientNoise: x,
            vogelDisk: _
          },
          bruneton: {
            common: e2,
            definitions: t,
            runtime: n2
          },
          sky: yt
        })
      ),
      {
        blendFunction: i2,
        vertexShader: Un,
        attributes: EffectAttribute.DEPTH,
        // prettier-ignore
        uniforms: new Map(
          Object.entries({
            normalBuffer: new Uniform(o2),
            projectionMatrix: new Uniform(new Matrix4()),
            viewMatrix: new Uniform(new Matrix4()),
            inverseProjectionMatrix: new Uniform(new Matrix4()),
            inverseViewMatrix: new Uniform(new Matrix4()),
            cameraPosition: new Uniform(new Vector3()),
            bottomRadius: new Uniform(r3.bottomRadius),
            ellipsoidRadii: new Uniform(new Vector3()),
            worldToECEFMatrix: new Uniform(new Matrix4()),
            altitudeCorrection: new Uniform(new Vector3()),
            geometricErrorCorrectionAmount: new Uniform(0),
            sunDirection: new Uniform((R == null ? void 0 : R.clone()) ?? new Vector3()),
            albedoScale: new Uniform(F ?? H0),
            moonDirection: new Uniform((Q == null ? void 0 : Q.clone()) ?? new Vector3()),
            moonAngularRadius: new Uniform(G0),
            lunarRadianceScale: new Uniform(F0),
            // Composition and shadow
            overlayBuffer: new Uniform(null),
            shadowBuffer: new Uniform(null),
            shadowMapSize: new Uniform(new Vector2()),
            shadowIntervals: new Uniform([]),
            shadowMatrices: new Uniform([]),
            inverseShadowMatrices: new Uniform([]),
            shadowFar: new Uniform(0),
            shadowTopHeight: new Uniform(0),
            shadowRadius: new Uniform(3),
            stbnTexture: new Uniform(null),
            frame: new Uniform(0),
            shadowLengthBuffer: new Uniform(null),
            // Lighting mask
            lightingMaskBuffer: new Uniform(null),
            // Uniforms for atmosphere functions
            ATMOSPHERE: r3.toUniform(),
            SUN_SPECTRAL_RADIANCE_TO_LUMINANCE: new Uniform(r3.sunRadianceToRelativeLuminance),
            SKY_SPECTRAL_RADIANCE_TO_LUMINANCE: new Uniform(r3.skyRadianceToRelativeLuminance),
            irradiance_texture: new Uniform(s),
            scattering_texture: new Uniform(d2),
            transmittance_texture: new Uniform(h2),
            single_mie_scattering_texture: new Uniform(null),
            higher_order_scattering_texture: new Uniform(null)
          })
        ),
        // prettier-ignore
        defines: /* @__PURE__ */ new Map([
          ["TRANSMITTANCE_TEXTURE_WIDTH", u0.toFixed(0)],
          ["TRANSMITTANCE_TEXTURE_HEIGHT", l0.toFixed(0)],
          ["SCATTERING_TEXTURE_R_SIZE", se.toFixed(0)],
          ["SCATTERING_TEXTURE_MU_SIZE", ce.toFixed(0)],
          ["SCATTERING_TEXTURE_MU_S_SIZE", ue.toFixed(0)],
          ["SCATTERING_TEXTURE_NU_SIZE", le.toFixed(0)],
          ["IRRADIANCE_TEXTURE_WIDTH", s0.toFixed(0)],
          ["IRRADIANCE_TEXTURE_HEIGHT", c0.toFixed(0)],
          ["METER_TO_LENGTH_UNIT", ee.toFixed(7)]
        ])
      }
    ), this.camera = e3, this.atmosphere = r3, this.overlay = null, this.shadow = null, this.shadowLength = null, this.lightingMask = null, this.combinedScatteringTextures = false, this.hasHigherOrderScatteringTexture = false, this.shadowSampleCount = 8, this.octEncodedNormal = a2, this.reconstructNormal = c3, this.singleMieScatteringTexture = m3, this.higherOrderScatteringTexture = f2, this.ellipsoid = T2, this.correctAltitude = p3, this.correctGeometricError = E, this.sunLight = D2 ?? P2, this.skyLight = N ?? H, this.transmittance = G, this.inscatter = B, this.sky = M0, this.sun = U0, this.moon = b0, this.ground = h0;
  }
  get mainCamera() {
    return this.camera;
  }
  set mainCamera(e3) {
    this.camera = e3;
  }
  copyCameraSettings(e3) {
    const {
      projectionMatrix: t2,
      matrixWorldInverse: r3,
      projectionMatrixInverse: i2,
      matrixWorld: o2
    } = e3, a2 = this.uniforms;
    a2.get("projectionMatrix").value.copy(t2), a2.get("viewMatrix").value.copy(r3), a2.get("inverseProjectionMatrix").value.copy(i2), a2.get("inverseViewMatrix").value.copy(o2);
    const c3 = e3.getWorldPosition(
      a2.get("cameraPosition").value
    ), s = a2.get("worldToECEFMatrix").value, d2 = Gn.copy(c3).applyMatrix4(s);
    try {
      const m3 = zn.setFromECEF(d2).height, f2 = Fn.set(0, this.ellipsoid.maximumRadius, -Math.max(0, m3)).applyMatrix4(t2);
      a2.get("geometricErrorCorrectionAmount").value = Co(
        Oo(f2.y, 41.5, 13.8, 0, 1)
      );
    } catch {
      return;
    }
    const h2 = a2.get("altitudeCorrection");
    this.correctAltitude ? ze(
      d2,
      this.atmosphere.bottomRadius,
      this.ellipsoid,
      h2.value
    ) : h2.value.setScalar(0);
  }
  updateOverlay() {
    let e3 = false;
    const { uniforms: t2, defines: r3, overlay: i2 } = this, o2 = r3.has("HAS_OVERLAY"), a2 = i2 != null;
    return a2 !== o2 && (a2 ? r3.set("HAS_OVERLAY", "1") : (r3.delete("HAS_OVERLAY"), t2.get("overlayBuffer").value = null), e3 = true), a2 && (t2.get("overlayBuffer").value = i2.map), e3;
  }
  updateShadow() {
    let e3 = false;
    const { uniforms: t2, defines: r3, shadow: i2 } = this, o2 = r3.has("HAS_SHADOW"), a2 = i2 != null;
    if (a2 !== o2 && (a2 ? r3.set("HAS_SHADOW", "1") : (r3.delete("HAS_SHADOW"), t2.get("shadowBuffer").value = null), e3 = true), a2) {
      const c3 = r3.get("SHADOW_CASCADE_COUNT"), s = `${i2.cascadeCount}`;
      c3 !== s && (r3.set("SHADOW_CASCADE_COUNT", i2.cascadeCount.toFixed(0)), e3 = true), t2.get("shadowBuffer").value = i2.map, t2.get("shadowMapSize").value = i2.mapSize, t2.get("shadowIntervals").value = i2.intervals, t2.get("shadowMatrices").value = i2.matrices, t2.get("inverseShadowMatrices").value = i2.inverseMatrices, t2.get("shadowFar").value = i2.far, t2.get("shadowTopHeight").value = i2.topHeight;
    }
    return e3;
  }
  updateShadowLength() {
    let e3 = false;
    const { uniforms: t2, defines: r3, shadowLength: i2 } = this, o2 = r3.has("HAS_SHADOW_LENGTH"), a2 = i2 != null;
    return a2 !== o2 && (a2 ? r3.set("HAS_SHADOW_LENGTH", "1") : (r3.delete("HAS_SHADOW_LENGTH"), t2.get("shadowLengthBuffer").value = null), e3 = true), a2 && (t2.get("shadowLengthBuffer").value = i2.map), e3;
  }
  updateLightingMask() {
    let e3 = false;
    const { uniforms: t2, defines: r3, lightingMask: i2 } = this, o2 = r3.has("HAS_LIGHTING_MASK"), a2 = i2 != null;
    if (a2 !== o2 && (a2 ? r3.set("HAS_LIGHTING_MASK", "1") : (r3.delete("HAS_LIGHTING_MASK"), t2.get("lightingMaskBuffer").value = null), e3 = true), a2) {
      t2.get("lightingMaskBuffer").value = i2.map;
      const c3 = r3.get("LIGHTING_MASK_CHANNEL"), s = i2.channel;
      s !== c3 && (/^[rgba]$/.test(s) ? (r3.set("LIGHTING_MASK_CHANNEL", s), e3 = true) : console.error(`Expression validation failed: ${s}`));
    }
    return e3;
  }
  update(e3, t2, r3) {
    this.copyCameraSettings(this.camera);
    let i2 = false;
    i2 || (i2 = this.updateOverlay()), i2 || (i2 = this.updateShadow()), i2 || (i2 = this.updateShadowLength()), i2 || (i2 = this.updateLightingMask()), i2 && this.setChanged(), ++this.uniforms.get("frame").value;
  }
  get normalBuffer() {
    return this.uniforms.get("normalBuffer").value;
  }
  set normalBuffer(e3) {
    this.uniforms.get("normalBuffer").value = e3;
  }
  get irradianceTexture() {
    return this.uniforms.get("irradiance_texture").value;
  }
  set irradianceTexture(e3) {
    this.uniforms.get("irradiance_texture").value = e3;
  }
  get scatteringTexture() {
    return this.uniforms.get("scattering_texture").value;
  }
  set scatteringTexture(e3) {
    this.uniforms.get("scattering_texture").value = e3;
  }
  get transmittanceTexture() {
    return this.uniforms.get("transmittance_texture").value;
  }
  set transmittanceTexture(e3) {
    this.uniforms.get("transmittance_texture").value = e3;
  }
  get singleMieScatteringTexture() {
    return this.uniforms.get("single_mie_scattering_texture").value;
  }
  set singleMieScatteringTexture(e3) {
    this.uniforms.get("single_mie_scattering_texture").value = e3, this.combinedScatteringTextures = e3 == null;
  }
  get higherOrderScatteringTexture() {
    return this.uniforms.get("higher_order_scattering_texture").value;
  }
  set higherOrderScatteringTexture(e3) {
    this.uniforms.get("higher_order_scattering_texture").value = e3, this.hasHigherOrderScatteringTexture = e3 != null;
  }
  get ellipsoid() {
    return this._ellipsoid;
  }
  set ellipsoid(e3) {
    this._ellipsoid = e3, this.uniforms.get("ellipsoidRadii").value.copy(e3.radii);
  }
  get worldToECEFMatrix() {
    return this.uniforms.get("worldToECEFMatrix").value;
  }
  get sunDirection() {
    return this.uniforms.get("sunDirection").value;
  }
  /** @deprecated Use sunLight instead. */
  get sunIrradiance() {
    return this.sunLight;
  }
  /** @deprecated Use sunLight instead. */
  set sunIrradiance(e3) {
    this.sunLight = e3;
  }
  /** @deprecated Use skyLight instead. */
  get skyIrradiance() {
    return this.skyLight;
  }
  /** @deprecated Use skyLight instead. */
  set skyIrradiance(e3) {
    this.skyLight = e3;
  }
  /** @deprecated Use albedoScale instead. */
  get irradianceScale() {
    return this.albedoScale;
  }
  /** @deprecated Use albedoScale instead. */
  set irradianceScale(e3) {
    this.albedoScale = e3;
  }
  get albedoScale() {
    return this.uniforms.get("albedoScale").value;
  }
  set albedoScale(e3) {
    this.uniforms.get("albedoScale").value = e3;
  }
  get moonDirection() {
    return this.uniforms.get("moonDirection").value;
  }
  get moonAngularRadius() {
    return this.uniforms.get("moonAngularRadius").value;
  }
  set moonAngularRadius(e3) {
    this.uniforms.get("moonAngularRadius").value = e3;
  }
  get lunarRadianceScale() {
    return this.uniforms.get("lunarRadianceScale").value;
  }
  set lunarRadianceScale(e3) {
    this.uniforms.get("lunarRadianceScale").value = e3;
  }
  get stbnTexture() {
    return this.uniforms.get("stbnTexture").value;
  }
  set stbnTexture(e3) {
    this.uniforms.get("stbnTexture").value = e3;
  }
  get shadowRadius() {
    return this.uniforms.get("shadowRadius").value;
  }
  set shadowRadius(e3) {
    this.uniforms.get("shadowRadius").value = e3;
  }
};
O([
  xo("OCT_ENCODED_NORMAL")
], L2.prototype, "octEncodedNormal");
O([
  xo("RECONSTRUCT_NORMAL")
], L2.prototype, "reconstructNormal");
O([
  xo("COMBINED_SCATTERING_TEXTURES")
], L2.prototype, "combinedScatteringTextures");
O([
  xo("HAS_HIGHER_ORDER_SCATTERING_TEXTURE")
], L2.prototype, "hasHigherOrderScatteringTexture");
O([
  xo("CORRECT_GEOMETRIC_ERROR")
], L2.prototype, "correctGeometricError");
O([
  xo("SUN_LIGHT")
], L2.prototype, "sunLight");
O([
  xo("SKY_LIGHT")
], L2.prototype, "skyLight");
O([
  xo("TRANSMITTANCE")
], L2.prototype, "transmittance");
O([
  xo("INSCATTER")
], L2.prototype, "inscatter");
O([
  xo("SKY")
], L2.prototype, "sky");
O([
  xo("SUN")
], L2.prototype, "sun");
O([
  xo("MOON")
], L2.prototype, "moon");
O([
  xo("GROUND")
], L2.prototype, "ground");
O([
  Fo("SHADOW_SAMPLE_COUNT", { min: 1, max: 16 })
], L2.prototype, "shadowSampleCount");
var Bn = Object.defineProperty;
var Ct = (n3, e3, t2, r3) => {
  for (var i2 = void 0, o2 = n3.length - 1, a2; o2 >= 0; o2--)
    (a2 = n3[o2]) && (i2 = a2(e3, t2, i2) || i2);
  return i2 && Bn(e3, t2, i2), i2;
};
var Vn = new Vector3();
function Wn(n3, e3) {
  let t2 = "", r3 = "";
  for (let i2 = 1; i2 < e3; ++i2)
    t2 += `layout(location = ${i2}) out float renderTarget${i2};
`, r3 += `renderTarget${i2} = 0.0;
`;
  return n3.replace("#include <mrt_layout>", t2).replace("#include <mrt_output>", r3);
}
var ke = {
  ellipsoid: b.WGS84,
  correctAltitude: true,
  renderTargetCount: 1
};
var de = class extends RawShaderMaterial {
  constructor(e3, t2 = J.DEFAULT) {
    const {
      irradianceTexture: r3 = null,
      scatteringTexture: i2 = null,
      transmittanceTexture: o2 = null,
      singleMieScatteringTexture: a2 = null,
      higherOrderScatteringTexture: c3 = null,
      ellipsoid: s,
      correctAltitude: d2,
      sunDirection: h2,
      sunAngularRadius: m3,
      renderTargetCount: f2,
      ...T2
    } = { ...ke, ...e3 };
    super({
      toneMapped: false,
      depthWrite: false,
      depthTest: false,
      ...T2,
      // prettier-ignore
      uniforms: {
        cameraPosition: new Uniform(new Vector3()),
        worldToECEFMatrix: new Uniform(new Matrix4()),
        altitudeCorrection: new Uniform(new Vector3()),
        sunDirection: new Uniform((h2 == null ? void 0 : h2.clone()) ?? new Vector3()),
        // Uniforms for atmosphere functions
        ATMOSPHERE: t2.toUniform(),
        SUN_SPECTRAL_RADIANCE_TO_LUMINANCE: new Uniform(t2.sunRadianceToRelativeLuminance),
        SKY_SPECTRAL_RADIANCE_TO_LUMINANCE: new Uniform(t2.skyRadianceToRelativeLuminance),
        irradiance_texture: new Uniform(r3),
        scattering_texture: new Uniform(i2),
        transmittance_texture: new Uniform(o2),
        single_mie_scattering_texture: new Uniform(null),
        higher_order_scattering_texture: new Uniform(null),
        ...T2.uniforms
      },
      defines: {
        PI: `${Math.PI}`,
        TRANSMITTANCE_TEXTURE_WIDTH: u0.toFixed(0),
        TRANSMITTANCE_TEXTURE_HEIGHT: l0.toFixed(0),
        SCATTERING_TEXTURE_R_SIZE: se.toFixed(0),
        SCATTERING_TEXTURE_MU_SIZE: ce.toFixed(0),
        SCATTERING_TEXTURE_MU_S_SIZE: ue.toFixed(0),
        SCATTERING_TEXTURE_NU_SIZE: le.toFixed(0),
        IRRADIANCE_TEXTURE_WIDTH: s0.toFixed(0),
        IRRADIANCE_TEXTURE_HEIGHT: c0.toFixed(0),
        METER_TO_LENGTH_UNIT: ee.toFixed(7),
        ...T2.defines
      }
    }), this.atmosphere = t2, this.combinedScatteringTextures = false, this.hasHigherOrderScatteringTexture = false, this.singleMieScatteringTexture = a2, this.higherOrderScatteringTexture = c3, this.ellipsoid = s, this.correctAltitude = d2, m3 != null && (this.sunAngularRadius = m3), this.renderTargetCount = f2;
  }
  copyCameraSettings(e3) {
    const t2 = this.uniforms, r3 = e3.getWorldPosition(
      t2.cameraPosition.value
    ), i2 = Vn.copy(r3).applyMatrix4(t2.worldToECEFMatrix.value), o2 = t2.altitudeCorrection.value;
    this.correctAltitude ? ze(
      i2,
      this.atmosphere.bottomRadius,
      this.ellipsoid,
      o2
    ) : o2.setScalar(0);
  }
  onBeforeCompile(e3, t2) {
    e3.fragmentShader = Wn(
      e3.fragmentShader,
      this.renderTargetCount
    );
  }
  onBeforeRender(e3, t2, r3, i2, o2, a2) {
    this.copyCameraSettings(r3);
  }
  get irradianceTexture() {
    return this.uniforms.irradiance_texture.value;
  }
  set irradianceTexture(e3) {
    this.uniforms.irradiance_texture.value = e3;
  }
  get scatteringTexture() {
    return this.uniforms.scattering_texture.value;
  }
  set scatteringTexture(e3) {
    this.uniforms.scattering_texture.value = e3;
  }
  get transmittanceTexture() {
    return this.uniforms.transmittance_texture.value;
  }
  set transmittanceTexture(e3) {
    this.uniforms.transmittance_texture.value = e3;
  }
  get singleMieScatteringTexture() {
    return this.uniforms.single_mie_scattering_texture.value;
  }
  set singleMieScatteringTexture(e3) {
    this.uniforms.single_mie_scattering_texture.value = e3, this.combinedScatteringTextures = e3 == null;
  }
  get higherOrderScatteringTexture() {
    return this.uniforms.higher_order_scattering_texture.value;
  }
  set higherOrderScatteringTexture(e3) {
    this.uniforms.higher_order_scattering_texture.value = e3, this.hasHigherOrderScatteringTexture = e3 != null;
  }
  get worldToECEFMatrix() {
    return this.uniforms.worldToECEFMatrix.value;
  }
  get sunDirection() {
    return this.uniforms.sunDirection.value;
  }
  get sunAngularRadius() {
    return this.uniforms.ATMOSPHERE.value.sun_angular_radius;
  }
  set sunAngularRadius(e3) {
    this.uniforms.ATMOSPHERE.value.sun_angular_radius = e3;
  }
  /** @package */
  get renderTargetCount() {
    return this._renderTargetCount;
  }
  /** @package */
  set renderTargetCount(e3) {
    e3 !== this.renderTargetCount && (this._renderTargetCount = e3, this.needsUpdate = true);
  }
};
Ct([
  xo("COMBINED_SCATTERING_TEXTURES")
], de.prototype, "combinedScatteringTextures");
Ct([
  xo("HAS_HIGHER_ORDER_SCATTERING_TEXTURE")
], de.prototype, "hasHigherOrderScatteringTexture");
var jn = 173.1446326846693;
var Dt = 14959787069098932e-8;
var a0 = 0.017453292519943295;
var Xn = 365.24217;
var nt = /* @__PURE__ */ new Date("2000-01-01T12:00:00Z");
var W = 2 * Math.PI;
var q = 3600 * (180 / Math.PI);
var v0 = 484813681109536e-20;
var Yn = 10800 * 60;
var Kn = 2 * Yn;
var $n = 6378.1366;
var qn = $n / Dt;
var Zn = 81.30056;
var Be = 2959122082855911e-19;
var Me = 2825345909524226e-22;
var ye = 8459715185680659e-23;
var Ce = 1292024916781969e-23;
var De = 1524358900784276e-23;
function J0(n3) {
  if (!Number.isFinite(n3))
    throw console.trace(), `Value is not a finite number: ${n3}`;
  return n3;
}
function p0(n3) {
  return n3 - Math.floor(n3);
}
var v4;
(function(n3) {
  n3.Sun = "Sun", n3.Moon = "Moon", n3.Mercury = "Mercury", n3.Venus = "Venus", n3.Earth = "Earth", n3.Mars = "Mars", n3.Jupiter = "Jupiter", n3.Saturn = "Saturn", n3.Uranus = "Uranus", n3.Neptune = "Neptune", n3.Pluto = "Pluto", n3.SSB = "SSB", n3.EMB = "EMB", n3.Star1 = "Star1", n3.Star2 = "Star2", n3.Star3 = "Star3", n3.Star4 = "Star4", n3.Star5 = "Star5", n3.Star6 = "Star6", n3.Star7 = "Star7", n3.Star8 = "Star8";
})(v4 || (v4 = {}));
var Jn = [
  v4.Star1,
  v4.Star2,
  v4.Star3,
  v4.Star4,
  v4.Star5,
  v4.Star6,
  v4.Star7,
  v4.Star8
];
var Qn = [
  { ra: 0, dec: 0, dist: 0 },
  { ra: 0, dec: 0, dist: 0 },
  { ra: 0, dec: 0, dist: 0 },
  { ra: 0, dec: 0, dist: 0 },
  { ra: 0, dec: 0, dist: 0 },
  { ra: 0, dec: 0, dist: 0 },
  { ra: 0, dec: 0, dist: 0 },
  { ra: 0, dec: 0, dist: 0 }
];
function er(n3) {
  const e3 = Jn.indexOf(n3);
  return e3 >= 0 ? Qn[e3] : null;
}
function It(n3) {
  const e3 = er(n3);
  return e3 && e3.dist > 0 ? e3 : null;
}
var K;
(function(n3) {
  n3[n3.From2000 = 0] = "From2000", n3[n3.Into2000 = 1] = "Into2000";
})(K || (K = {}));
var E0 = {
  Mercury: [
    [
      [
        [4.40250710144, 0, 0],
        [0.40989414977, 1.48302034195, 26087.9031415742],
        [0.050462942, 4.47785489551, 52175.8062831484],
        [0.00855346844, 1.16520322459, 78263.70942472259],
        [0.00165590362, 4.11969163423, 104351.61256629678],
        [34561897e-11, 0.77930768443, 130439.51570787099],
        [7583476e-11, 3.71348404924, 156527.41884944518]
      ],
      [
        [26087.90313685529, 0, 0],
        [0.01131199811, 6.21874197797, 26087.9031415742],
        [0.00292242298, 3.04449355541, 52175.8062831484],
        [75775081e-11, 6.08568821653, 78263.70942472259],
        [19676525e-11, 2.80965111777, 104351.61256629678]
      ]
    ],
    [
      [
        [0.11737528961, 1.98357498767, 26087.9031415742],
        [0.02388076996, 5.03738959686, 52175.8062831484],
        [0.01222839532, 3.14159265359, 0],
        [0.0054325181, 1.79644363964, 78263.70942472259],
        [0.0012977877, 4.83232503958, 104351.61256629678],
        [31866927e-11, 1.58088495658, 130439.51570787099],
        [7963301e-11, 4.60972126127, 156527.41884944518]
      ],
      [
        [0.00274646065, 3.95008450011, 26087.9031415742],
        [99737713e-11, 3.14159265359, 0]
      ]
    ],
    [
      [
        [0.39528271651, 0, 0],
        [0.07834131818, 6.19233722598, 26087.9031415742],
        [0.00795525558, 2.95989690104, 52175.8062831484],
        [0.00121281764, 6.01064153797, 78263.70942472259],
        [21921969e-11, 2.77820093972, 104351.61256629678],
        [4354065e-11, 5.82894543774, 130439.51570787099]
      ],
      [
        [0.0021734774, 4.65617158665, 26087.9031415742],
        [44141826e-11, 1.42385544001, 52175.8062831484]
      ]
    ]
  ],
  Venus: [
    [
      [
        [3.17614666774, 0, 0],
        [0.01353968419, 5.59313319619, 10213.285546211],
        [89891645e-11, 5.30650047764, 20426.571092422],
        [5477194e-11, 4.41630661466, 7860.4193924392],
        [3455741e-11, 2.6996444782, 11790.6290886588],
        [2372061e-11, 2.99377542079, 3930.2096962196],
        [1317168e-11, 5.18668228402, 26.2983197998],
        [1664146e-11, 4.25018630147, 1577.3435424478],
        [1438387e-11, 4.15745084182, 9683.5945811164],
        [1200521e-11, 6.15357116043, 30639.856638633]
      ],
      [
        [10213.28554621638, 0, 0],
        [95617813e-11, 2.4640651111, 10213.285546211],
        [7787201e-11, 0.6247848222, 20426.571092422]
      ]
    ],
    [
      [
        [0.05923638472, 0.26702775812, 10213.285546211],
        [40107978e-11, 1.14737178112, 20426.571092422],
        [32814918e-11, 3.14159265359, 0]
      ],
      [
        [0.00287821243, 1.88964962838, 10213.285546211]
      ]
    ],
    [
      [
        [0.72334820891, 0, 0],
        [0.00489824182, 4.02151831717, 10213.285546211],
        [1658058e-11, 4.90206728031, 20426.571092422],
        [1378043e-11, 1.12846591367, 11790.6290886588],
        [1632096e-11, 2.84548795207, 7860.4193924392],
        [498395e-11, 2.58682193892, 9683.5945811164],
        [221985e-11, 2.01346696541, 19367.1891622328],
        [237454e-11, 2.55136053886, 15720.8387848784]
      ],
      [
        [34551041e-11, 0.89198706276, 10213.285546211]
      ]
    ]
  ],
  Earth: [
    [
      [
        [1.75347045673, 0, 0],
        [0.03341656453, 4.66925680415, 6283.0758499914],
        [34894275e-11, 4.62610242189, 12566.1516999828],
        [3417572e-11, 2.82886579754, 3.523118349],
        [3497056e-11, 2.74411783405, 5753.3848848968],
        [3135899e-11, 3.62767041756, 77713.7714681205],
        [2676218e-11, 4.41808345438, 7860.4193924392],
        [2342691e-11, 6.13516214446, 3930.2096962196],
        [1273165e-11, 2.03709657878, 529.6909650946],
        [1324294e-11, 0.74246341673, 11506.7697697936],
        [901854e-11, 2.04505446477, 26.2983197998],
        [1199167e-11, 1.10962946234, 1577.3435424478],
        [857223e-11, 3.50849152283, 398.1490034082],
        [779786e-11, 1.17882681962, 5223.6939198022],
        [99025e-10, 5.23268072088, 5884.9268465832],
        [753141e-11, 2.53339052847, 5507.5532386674],
        [505267e-11, 4.58292599973, 18849.2275499742],
        [492392e-11, 4.20505711826, 775.522611324],
        [356672e-11, 2.91954114478, 0.0673103028],
        [284125e-11, 1.89869240932, 796.2980068164],
        [242879e-11, 0.34481445893, 5486.777843175],
        [317087e-11, 5.84901948512, 11790.6290886588],
        [271112e-11, 0.31486255375, 10977.078804699],
        [206217e-11, 4.80646631478, 2544.3144198834],
        [205478e-11, 1.86953770281, 5573.1428014331],
        [202318e-11, 2.45767790232, 6069.7767545534],
        [126225e-11, 1.08295459501, 20.7753954924],
        [155516e-11, 0.83306084617, 213.299095438]
      ],
      [
        [6283.0758499914, 0, 0],
        [0.00206058863, 2.67823455808, 6283.0758499914],
        [4303419e-11, 2.63512233481, 12566.1516999828]
      ],
      [
        [8721859e-11, 1.07253635559, 6283.0758499914]
      ]
    ],
    [
      [],
      [
        [0.00227777722, 3.4137662053, 6283.0758499914],
        [3805678e-11, 3.37063423795, 12566.1516999828]
      ]
    ],
    [
      [
        [1.00013988784, 0, 0],
        [0.01670699632, 3.09846350258, 6283.0758499914],
        [13956024e-11, 3.05524609456, 12566.1516999828],
        [308372e-10, 5.19846674381, 77713.7714681205],
        [1628463e-11, 1.17387558054, 5753.3848848968],
        [1575572e-11, 2.84685214877, 7860.4193924392],
        [924799e-11, 5.45292236722, 11506.7697697936],
        [542439e-11, 4.56409151453, 3930.2096962196],
        [47211e-10, 3.66100022149, 5884.9268465832],
        [85831e-11, 1.27079125277, 161000.6857376741],
        [57056e-11, 2.01374292245, 83996.84731811189],
        [55736e-11, 5.2415979917, 71430.69561812909],
        [174844e-11, 3.01193636733, 18849.2275499742],
        [243181e-11, 4.2734953079, 11790.6290886588]
      ],
      [
        [0.00103018607, 1.10748968172, 6283.0758499914],
        [1721238e-11, 1.06442300386, 12566.1516999828]
      ],
      [
        [4359385e-11, 5.78455133808, 6283.0758499914]
      ]
    ]
  ],
  Mars: [
    [
      [
        [6.20347711581, 0, 0],
        [0.18656368093, 5.0503710027, 3340.6124266998],
        [0.01108216816, 5.40099836344, 6681.2248533996],
        [91798406e-11, 5.75478744667, 10021.8372800994],
        [27744987e-11, 5.97049513147, 3.523118349],
        [10610235e-11, 2.93958560338, 2281.2304965106],
        [12315897e-11, 0.84956094002, 2810.9214616052],
        [8926784e-11, 4.15697846427, 0.0172536522],
        [8715691e-11, 6.11005153139, 13362.4497067992],
        [6797556e-11, 0.36462229657, 398.1490034082],
        [7774872e-11, 3.33968761376, 5621.8429232104],
        [3575078e-11, 1.6618650571, 2544.3144198834],
        [4161108e-11, 0.22814971327, 2942.4634232916],
        [3075252e-11, 0.85696614132, 191.4482661116],
        [2628117e-11, 0.64806124465, 3337.0893083508],
        [2937546e-11, 6.07893711402, 0.0673103028],
        [2389414e-11, 5.03896442664, 796.2980068164],
        [2579844e-11, 0.02996736156, 3344.1355450488],
        [1528141e-11, 1.14979301996, 6151.533888305],
        [1798806e-11, 0.65634057445, 529.6909650946],
        [1264357e-11, 3.62275122593, 5092.1519581158],
        [1286228e-11, 3.06796065034, 2146.1654164752],
        [1546404e-11, 2.91579701718, 1751.539531416],
        [1024902e-11, 3.69334099279, 8962.4553499102],
        [891566e-11, 0.18293837498, 16703.062133499],
        [858759e-11, 2.4009381194, 2914.0142358238],
        [832715e-11, 2.46418619474, 3340.5951730476],
        [83272e-10, 4.49495782139, 3340.629680352],
        [712902e-11, 3.66335473479, 1059.3819301892],
        [748723e-11, 3.82248614017, 155.4203994342],
        [723861e-11, 0.67497311481, 3738.761430108],
        [635548e-11, 2.92182225127, 8432.7643848156],
        [655162e-11, 0.48864064125, 3127.3133312618],
        [550474e-11, 3.81001042328, 0.9803210682],
        [55275e-10, 4.47479317037, 1748.016413067],
        [425966e-11, 0.55364317304, 6283.0758499914],
        [415131e-11, 0.49662285038, 213.299095438],
        [472167e-11, 3.62547124025, 1194.4470102246],
        [306551e-11, 0.38052848348, 6684.7479717486],
        [312141e-11, 0.99853944405, 6677.7017350506],
        [293198e-11, 4.22131299634, 20.7753954924],
        [302375e-11, 4.48618007156, 3532.0606928114],
        [274027e-11, 0.54222167059, 3340.545116397],
        [281079e-11, 5.88163521788, 1349.8674096588],
        [231183e-11, 1.28242156993, 3870.3033917944],
        [283602e-11, 5.7688543494, 3149.1641605882],
        [236117e-11, 5.75503217933, 3333.498879699],
        [274033e-11, 0.13372524985, 3340.6797370026],
        [299395e-11, 2.78323740866, 6254.6266625236]
      ],
      [
        [3340.61242700512, 0, 0],
        [0.01457554523, 3.60433733236, 3340.6124266998],
        [0.00168414711, 3.92318567804, 6681.2248533996],
        [20622975e-11, 4.26108844583, 10021.8372800994],
        [3452392e-11, 4.7321039319, 3.523118349],
        [2586332e-11, 4.60670058555, 13362.4497067992],
        [841535e-11, 4.45864030426, 2281.2304965106]
      ],
      [
        [58152577e-11, 2.04961712429, 3340.6124266998],
        [13459579e-11, 2.45738706163, 6681.2248533996]
      ]
    ],
    [
      [
        [0.03197134986, 3.76832042431, 3340.6124266998],
        [0.00298033234, 4.10616996305, 6681.2248533996],
        [0.00289104742, 0, 0],
        [31365539e-11, 4.4465105309, 10021.8372800994],
        [34841e-9, 4.7881254926, 13362.4497067992]
      ],
      [
        [0.00217310991, 6.04472194776, 3340.6124266998],
        [20976948e-11, 3.14159265359, 0],
        [12834709e-11, 1.60810667915, 6681.2248533996]
      ]
    ],
    [
      [
        [1.53033488271, 0, 0],
        [0.1418495316, 3.47971283528, 3340.6124266998],
        [0.00660776362, 3.81783443019, 6681.2248533996],
        [46179117e-11, 4.15595316782, 10021.8372800994],
        [8109733e-11, 5.55958416318, 2810.9214616052],
        [7485318e-11, 1.77239078402, 5621.8429232104],
        [5523191e-11, 1.3643630377, 2281.2304965106],
        [382516e-10, 4.49407183687, 13362.4497067992],
        [2306537e-11, 0.09081579001, 2544.3144198834],
        [1999396e-11, 5.36059617709, 3337.0893083508],
        [2484394e-11, 4.9254563992, 2942.4634232916],
        [1960195e-11, 4.74249437639, 3344.1355450488],
        [1167119e-11, 2.11260868341, 5092.1519581158],
        [1102816e-11, 5.00908403998, 398.1490034082],
        [899066e-11, 4.40791133207, 529.6909650946],
        [992252e-11, 5.83861961952, 6151.533888305],
        [807354e-11, 2.10217065501, 1059.3819301892],
        [797915e-11, 3.44839203899, 796.2980068164],
        [740975e-11, 1.49906336885, 2146.1654164752]
      ],
      [
        [0.01107433345, 2.03250524857, 3340.6124266998],
        [0.00103175887, 2.37071847807, 6681.2248533996],
        [128772e-9, 0, 0],
        [1081588e-10, 2.70888095665, 10021.8372800994]
      ],
      [
        [44242249e-11, 0.47930604954, 3340.6124266998],
        [8138042e-11, 0.86998389204, 6681.2248533996]
      ]
    ]
  ],
  Jupiter: [
    [
      [
        [0.59954691494, 0, 0],
        [0.09695898719, 5.06191793158, 529.6909650946],
        [0.00573610142, 1.44406205629, 7.1135470008],
        [0.00306389205, 5.41734730184, 1059.3819301892],
        [97178296e-11, 4.14264726552, 632.7837393132],
        [72903078e-11, 3.64042916389, 522.5774180938],
        [64263975e-11, 3.41145165351, 103.0927742186],
        [39806064e-11, 2.29376740788, 419.4846438752],
        [38857767e-11, 1.27231755835, 316.3918696566],
        [27964629e-11, 1.7845459182, 536.8045120954],
        [1358973e-10, 5.7748104079, 1589.0728952838],
        [8246349e-11, 3.5822792584, 206.1855484372],
        [8768704e-11, 3.63000308199, 949.1756089698],
        [7368042e-11, 5.0810119427, 735.8765135318],
        [626315e-10, 0.02497628807, 213.299095438],
        [6114062e-11, 4.51319998626, 1162.4747044078],
        [4905396e-11, 1.32084470588, 110.2063212194],
        [5305285e-11, 1.30671216791, 14.2270940016],
        [5305441e-11, 4.18625634012, 1052.2683831884],
        [4647248e-11, 4.69958103684, 3.9321532631],
        [3045023e-11, 4.31676431084, 426.598190876],
        [2609999e-11, 1.56667394063, 846.0828347512],
        [2028191e-11, 1.06376530715, 3.1813937377],
        [1764763e-11, 2.14148655117, 1066.49547719],
        [1722972e-11, 3.88036268267, 1265.5674786264],
        [1920945e-11, 0.97168196472, 639.897286314],
        [1633223e-11, 3.58201833555, 515.463871093],
        [1431999e-11, 4.29685556046, 625.6701923124],
        [973272e-11, 4.09764549134, 95.9792272178]
      ],
      [
        [529.69096508814, 0, 0],
        [0.00489503243, 4.2208293947, 529.6909650946],
        [0.00228917222, 6.02646855621, 7.1135470008],
        [30099479e-11, 4.54540782858, 1059.3819301892],
        [2072092e-10, 5.45943156902, 522.5774180938],
        [12103653e-11, 0.16994816098, 536.8045120954],
        [6067987e-11, 4.42422292017, 103.0927742186],
        [5433968e-11, 3.98480737746, 419.4846438752],
        [4237744e-11, 5.89008707199, 14.2270940016]
      ],
      [
        [47233601e-11, 4.32148536482, 7.1135470008],
        [30649436e-11, 2.929777887, 529.6909650946],
        [14837605e-11, 3.14159265359, 0]
      ]
    ],
    [
      [
        [0.02268615702, 3.55852606721, 529.6909650946],
        [0.00109971634, 3.90809347197, 1059.3819301892],
        [0.00110090358, 0, 0],
        [8101428e-11, 3.60509572885, 522.5774180938],
        [6043996e-11, 4.25883108339, 1589.0728952838],
        [6437782e-11, 0.30627119215, 536.8045120954]
      ],
      [
        [78203446e-11, 1.52377859742, 529.6909650946]
      ]
    ],
    [
      [
        [5.20887429326, 0, 0],
        [0.25209327119, 3.49108639871, 529.6909650946],
        [0.00610599976, 3.84115365948, 1059.3819301892],
        [0.00282029458, 2.57419881293, 632.7837393132],
        [0.00187647346, 2.07590383214, 522.5774180938],
        [86792905e-11, 0.71001145545, 419.4846438752],
        [72062974e-11, 0.21465724607, 536.8045120954],
        [65517248e-11, 5.9799588479, 316.3918696566],
        [29134542e-11, 1.67759379655, 103.0927742186],
        [30135335e-11, 2.16132003734, 949.1756089698],
        [23453271e-11, 3.54023522184, 735.8765135318],
        [22283743e-11, 4.19362594399, 1589.0728952838],
        [23947298e-11, 0.2745803748, 7.1135470008],
        [13032614e-11, 2.96042965363, 1162.4747044078],
        [970336e-10, 1.90669633585, 206.1855484372],
        [12749023e-11, 2.71550286592, 1052.2683831884],
        [7057931e-11, 2.18184839926, 1265.5674786264],
        [6137703e-11, 6.26418240033, 846.0828347512],
        [2616976e-11, 2.00994012876, 1581.959348283]
      ],
      [
        [0.0127180152, 2.64937512894, 529.6909650946],
        [61661816e-11, 3.00076460387, 1059.3819301892],
        [53443713e-11, 3.89717383175, 522.5774180938],
        [31185171e-11, 4.88276958012, 536.8045120954],
        [41390269e-11, 0, 0]
      ]
    ]
  ],
  Saturn: [
    [
      [
        [0.87401354025, 0, 0],
        [0.11107659762, 3.96205090159, 213.299095438],
        [0.01414150957, 4.58581516874, 7.1135470008],
        [0.00398379389, 0.52112032699, 206.1855484372],
        [0.00350769243, 3.30329907896, 426.598190876],
        [0.00206816305, 0.24658372002, 103.0927742186],
        [792713e-9, 3.84007056878, 220.4126424388],
        [23990355e-11, 4.66976924553, 110.2063212194],
        [16573588e-11, 0.43719228296, 419.4846438752],
        [14906995e-11, 5.76903183869, 316.3918696566],
        [1582029e-10, 0.93809155235, 632.7837393132],
        [14609559e-11, 1.56518472, 3.9321532631],
        [13160301e-11, 4.44891291899, 14.2270940016],
        [15053543e-11, 2.71669915667, 639.897286314],
        [13005299e-11, 5.98119023644, 11.0457002639],
        [10725067e-11, 3.12939523827, 202.2533951741],
        [5863206e-11, 0.23656938524, 529.6909650946],
        [5227757e-11, 4.20783365759, 3.1813937377],
        [6126317e-11, 1.76328667907, 277.0349937414],
        [5019687e-11, 3.17787728405, 433.7117378768],
        [459255e-10, 0.61977744975, 199.0720014364],
        [4005867e-11, 2.24479718502, 63.7358983034],
        [2953796e-11, 0.98280366998, 95.9792272178],
        [387367e-10, 3.22283226966, 138.5174968707],
        [2461186e-11, 2.03163875071, 735.8765135318],
        [3269484e-11, 0.77492638211, 949.1756089698],
        [1758145e-11, 3.2658010994, 522.5774180938],
        [1640172e-11, 5.5050445305, 846.0828347512],
        [1391327e-11, 4.02333150505, 323.5054166574],
        [1580648e-11, 4.37265307169, 309.2783226558],
        [1123498e-11, 2.83726798446, 415.5524906121],
        [1017275e-11, 3.71700135395, 227.5261894396],
        [848642e-11, 3.1915017083, 209.3669421749]
      ],
      [
        [213.2990952169, 0, 0],
        [0.01297370862, 1.82834923978, 213.299095438],
        [0.00564345393, 2.88499717272, 7.1135470008],
        [93734369e-11, 1.06311793502, 426.598190876],
        [0.00107674962, 2.27769131009, 206.1855484372],
        [40244455e-11, 2.04108104671, 220.4126424388],
        [19941774e-11, 1.2795439047, 103.0927742186],
        [10511678e-11, 2.7488034213, 14.2270940016],
        [6416106e-11, 0.38238295041, 639.897286314],
        [4848994e-11, 2.43037610229, 419.4846438752],
        [4056892e-11, 2.92133209468, 110.2063212194],
        [3768635e-11, 3.6496533078, 3.9321532631]
      ],
      [
        [0.0011644133, 1.17988132879, 7.1135470008],
        [91841837e-11, 0.0732519584, 213.299095438],
        [36661728e-11, 0, 0],
        [15274496e-11, 4.06493179167, 206.1855484372]
      ]
    ],
    [
      [
        [0.04330678039, 3.60284428399, 213.299095438],
        [0.00240348302, 2.85238489373, 426.598190876],
        [84745939e-11, 0, 0],
        [30863357e-11, 3.48441504555, 220.4126424388],
        [34116062e-11, 0.57297307557, 206.1855484372],
        [1473407e-10, 2.11846596715, 639.897286314],
        [9916667e-11, 5.79003188904, 419.4846438752],
        [6993564e-11, 4.7360468972, 7.1135470008],
        [4807588e-11, 5.43305312061, 316.3918696566]
      ],
      [
        [0.00198927992, 4.93901017903, 213.299095438],
        [36947916e-11, 3.14159265359, 0],
        [17966989e-11, 0.5197943111, 426.598190876]
      ]
    ],
    [
      [
        [9.55758135486, 0, 0],
        [0.52921382865, 2.39226219573, 213.299095438],
        [0.01873679867, 5.2354960466, 206.1855484372],
        [0.01464663929, 1.64763042902, 426.598190876],
        [0.00821891141, 5.93520042303, 316.3918696566],
        [0.00547506923, 5.0153261898, 103.0927742186],
        [0.0037168465, 2.27114821115, 220.4126424388],
        [0.00361778765, 3.13904301847, 7.1135470008],
        [0.00140617506, 5.70406606781, 632.7837393132],
        [0.00108974848, 3.29313390175, 110.2063212194],
        [69006962e-11, 5.94099540992, 419.4846438752],
        [61053367e-11, 0.94037691801, 639.897286314],
        [48913294e-11, 1.55733638681, 202.2533951741],
        [34143772e-11, 0.19519102597, 277.0349937414],
        [32401773e-11, 5.47084567016, 949.1756089698],
        [20936596e-11, 0.46349251129, 735.8765135318],
        [9796004e-11, 5.20477537945, 1265.5674786264],
        [11993338e-11, 5.98050967385, 846.0828347512],
        [208393e-9, 1.52102476129, 433.7117378768],
        [15298404e-11, 3.0594381494, 529.6909650946],
        [6465823e-11, 0.17732249942, 1052.2683831884],
        [11380257e-11, 1.7310542704, 522.5774180938],
        [3419618e-11, 4.94550542171, 1581.959348283]
      ],
      [
        [0.0618298134, 0.2584351148, 213.299095438],
        [0.00506577242, 0.71114625261, 206.1855484372],
        [0.00341394029, 5.79635741658, 426.598190876],
        [0.00188491195, 0.47215589652, 220.4126424388],
        [0.00186261486, 3.14159265359, 0],
        [0.00143891146, 1.40744822888, 7.1135470008]
      ],
      [
        [0.00436902572, 4.78671677509, 213.299095438]
      ]
    ]
  ],
  Uranus: [
    [
      [
        [5.48129294297, 0, 0],
        [0.09260408234, 0.89106421507, 74.7815985673],
        [0.01504247898, 3.6271926092, 1.4844727083],
        [0.00365981674, 1.89962179044, 73.297125859],
        [0.00272328168, 3.35823706307, 149.5631971346],
        [70328461e-11, 5.39254450063, 63.7358983034],
        [68892678e-11, 6.09292483287, 76.2660712756],
        [61998615e-11, 2.26952066061, 2.9689454166],
        [61950719e-11, 2.85098872691, 11.0457002639],
        [2646877e-10, 3.14152083966, 71.8126531507],
        [25710476e-11, 6.11379840493, 454.9093665273],
        [2107885e-10, 4.36059339067, 148.0787244263],
        [17818647e-11, 1.74436930289, 36.6485629295],
        [14613507e-11, 4.73732166022, 3.9321532631],
        [11162509e-11, 5.8268179635, 224.3447957019],
        [1099791e-10, 0.48865004018, 138.5174968707],
        [9527478e-11, 2.95516862826, 35.1640902212],
        [7545601e-11, 5.236265824, 109.9456887885],
        [4220241e-11, 3.23328220918, 70.8494453042],
        [40519e-9, 2.277550173, 151.0476698429],
        [3354596e-11, 1.0654900738, 4.4534181249],
        [2926718e-11, 4.62903718891, 9.5612275556],
        [349034e-10, 5.48306144511, 146.594251718],
        [3144069e-11, 4.75199570434, 77.7505439839],
        [2922333e-11, 5.35235361027, 85.8272988312],
        [2272788e-11, 4.36600400036, 70.3281804424],
        [2051219e-11, 1.51773566586, 0.1118745846],
        [2148602e-11, 0.60745949945, 38.1330356378],
        [1991643e-11, 4.92437588682, 277.0349937414],
        [1376226e-11, 2.04283539351, 65.2203710117],
        [1666902e-11, 3.62744066769, 380.12776796],
        [1284107e-11, 3.11347961505, 202.2533951741],
        [1150429e-11, 0.93343589092, 3.1813937377],
        [1533221e-11, 2.58594681212, 52.6901980395],
        [1281604e-11, 0.54271272721, 222.8603229936],
        [1372139e-11, 4.19641530878, 111.4301614968],
        [1221029e-11, 0.1990065003, 108.4612160802],
        [946181e-11, 1.19253165736, 127.4717966068],
        [1150989e-11, 4.17898916639, 33.6796175129]
      ],
      [
        [74.7815986091, 0, 0],
        [0.00154332863, 5.24158770553, 74.7815985673],
        [24456474e-11, 1.71260334156, 1.4844727083],
        [9258442e-11, 0.4282973235, 11.0457002639],
        [8265977e-11, 1.50218091379, 63.7358983034],
        [915016e-10, 1.41213765216, 149.5631971346]
      ]
    ],
    [
      [
        [0.01346277648, 2.61877810547, 74.7815985673],
        [623414e-9, 5.08111189648, 149.5631971346],
        [61601196e-11, 3.14159265359, 0],
        [9963722e-11, 1.61603805646, 76.2660712756],
        [992616e-10, 0.57630380333, 73.297125859]
      ],
      [
        [34101978e-11, 0.01321929936, 74.7815985673]
      ]
    ],
    [
      [
        [19.21264847206, 0, 0],
        [0.88784984413, 5.60377527014, 74.7815985673],
        [0.03440836062, 0.32836099706, 73.297125859],
        [0.0205565386, 1.7829515933, 149.5631971346],
        [0.0064932241, 4.52247285911, 76.2660712756],
        [0.00602247865, 3.86003823674, 63.7358983034],
        [0.00496404167, 1.40139935333, 454.9093665273],
        [0.00338525369, 1.58002770318, 138.5174968707],
        [0.00243509114, 1.57086606044, 71.8126531507],
        [0.00190522303, 1.99809394714, 1.4844727083],
        [0.00161858838, 2.79137786799, 148.0787244263],
        [0.00143706183, 1.38368544947, 11.0457002639],
        [93192405e-11, 0.17437220467, 36.6485629295],
        [71424548e-11, 4.24509236074, 224.3447957019],
        [89806014e-11, 3.66105364565, 109.9456887885],
        [39009723e-11, 1.66971401684, 70.8494453042],
        [46677296e-11, 1.39976401694, 35.1640902212],
        [39025624e-11, 3.36234773834, 277.0349937414],
        [36755274e-11, 3.88649278513, 146.594251718],
        [30348723e-11, 0.70100838798, 151.0476698429],
        [29156413e-11, 3.180563367, 77.7505439839],
        [22637073e-11, 0.72518687029, 529.6909650946],
        [11959076e-11, 1.7504339214, 984.6003316219],
        [25620756e-11, 5.25656086672, 380.12776796]
      ],
      [
        [0.01479896629, 3.67205697578, 74.7815985673]
      ]
    ]
  ],
  Neptune: [
    [
      [
        [5.31188633046, 0, 0],
        [0.0179847553, 2.9010127389, 38.1330356378],
        [0.01019727652, 0.48580922867, 1.4844727083],
        [0.00124531845, 4.83008090676, 36.6485629295],
        [42064466e-11, 5.41054993053, 2.9689454166],
        [37714584e-11, 6.09221808686, 35.1640902212],
        [33784738e-11, 1.24488874087, 76.2660712756],
        [16482741e-11, 7727998e-11, 491.5579294568],
        [9198584e-11, 4.93747051954, 39.6175083461],
        [899425e-10, 0.27462171806, 175.1660598002]
      ],
      [
        [38.13303563957, 0, 0],
        [16604172e-11, 4.86323329249, 1.4844727083],
        [15744045e-11, 2.27887427527, 38.1330356378]
      ]
    ],
    [
      [
        [0.03088622933, 1.44104372644, 38.1330356378],
        [27780087e-11, 5.91271884599, 76.2660712756],
        [27623609e-11, 0, 0],
        [15355489e-11, 2.52123799551, 36.6485629295],
        [15448133e-11, 3.50877079215, 39.6175083461]
      ]
    ],
    [
      [
        [30.07013205828, 0, 0],
        [0.27062259632, 1.32999459377, 38.1330356378],
        [0.01691764014, 3.25186135653, 36.6485629295],
        [0.00807830553, 5.18592878704, 1.4844727083],
        [0.0053776051, 4.52113935896, 35.1640902212],
        [0.00495725141, 1.5710564165, 491.5579294568],
        [0.00274571975, 1.84552258866, 175.1660598002],
        [1201232e-10, 1.92059384991, 1021.2488945514],
        [0.00121801746, 5.79754470298, 76.2660712756],
        [0.00100896068, 0.3770272493, 73.297125859],
        [0.00135134092, 3.37220609835, 39.6175083461],
        [7571796e-11, 1.07149207335, 388.4651552382]
      ]
    ]
  ]
};
function tr(n3) {
  var e3, t2, r3, i2, o2, a2, c3;
  const s = 2e3 + (n3 - 14) / Xn;
  return s < -500 ? (e3 = (s - 1820) / 100, -20 + 32 * e3 * e3) : s < 500 ? (e3 = s / 100, t2 = e3 * e3, r3 = e3 * t2, i2 = t2 * t2, o2 = t2 * r3, a2 = r3 * r3, 10583.6 - 1014.41 * e3 + 33.78311 * t2 - 5.952053 * r3 - 0.1798452 * i2 + 0.022174192 * o2 + 0.0090316521 * a2) : s < 1600 ? (e3 = (s - 1e3) / 100, t2 = e3 * e3, r3 = e3 * t2, i2 = t2 * t2, o2 = t2 * r3, a2 = r3 * r3, 1574.2 - 556.01 * e3 + 71.23472 * t2 + 0.319781 * r3 - 0.8503463 * i2 - 5050998e-9 * o2 + 0.0083572073 * a2) : s < 1700 ? (e3 = s - 1600, t2 = e3 * e3, r3 = e3 * t2, 120 - 0.9808 * e3 - 0.01532 * t2 + r3 / 7129) : s < 1800 ? (e3 = s - 1700, t2 = e3 * e3, r3 = e3 * t2, i2 = t2 * t2, 8.83 + 0.1603 * e3 - 59285e-7 * t2 + 13336e-8 * r3 - i2 / 1174e3) : s < 1860 ? (e3 = s - 1800, t2 = e3 * e3, r3 = e3 * t2, i2 = t2 * t2, o2 = t2 * r3, a2 = r3 * r3, c3 = r3 * i2, 13.72 - 0.332447 * e3 + 68612e-7 * t2 + 41116e-7 * r3 - 37436e-8 * i2 + 121272e-10 * o2 - 1699e-10 * a2 + 875e-12 * c3) : s < 1900 ? (e3 = s - 1860, t2 = e3 * e3, r3 = e3 * t2, i2 = t2 * t2, o2 = t2 * r3, 7.62 + 0.5737 * e3 - 0.251754 * t2 + 0.01680668 * r3 - 4473624e-10 * i2 + o2 / 233174) : s < 1920 ? (e3 = s - 1900, t2 = e3 * e3, r3 = e3 * t2, i2 = t2 * t2, -2.79 + 1.494119 * e3 - 0.0598939 * t2 + 61966e-7 * r3 - 197e-6 * i2) : s < 1941 ? (e3 = s - 1920, t2 = e3 * e3, r3 = e3 * t2, 21.2 + 0.84493 * e3 - 0.0761 * t2 + 20936e-7 * r3) : s < 1961 ? (e3 = s - 1950, t2 = e3 * e3, r3 = e3 * t2, 29.07 + 0.407 * e3 - t2 / 233 + r3 / 2547) : s < 1986 ? (e3 = s - 1975, t2 = e3 * e3, r3 = e3 * t2, 45.45 + 1.067 * e3 - t2 / 260 - r3 / 718) : s < 2005 ? (e3 = s - 2e3, t2 = e3 * e3, r3 = e3 * t2, i2 = t2 * t2, o2 = t2 * r3, 63.86 + 0.3345 * e3 - 0.060374 * t2 + 17275e-7 * r3 + 651814e-9 * i2 + 2373599e-11 * o2) : s < 2050 ? (e3 = s - 2e3, 62.92 + 0.32217 * e3 + 5589e-6 * e3 * e3) : s < 2150 ? (e3 = (s - 1820) / 100, -20 + 32 * e3 * e3 - 0.5628 * (2150 - s)) : (e3 = (s - 1820) / 100, -20 + 32 * e3 * e3);
}
var nr = tr;
function rt(n3) {
  return n3 + nr(n3) / 86400;
}
var Z = class _Z {
  /**
   * @param {FlexibleDateTime} date
   *      A JavaScript Date object, a numeric UTC value expressed in J2000 days, or another AstroTime object.
   */
  constructor(e3) {
    if (e3 instanceof _Z) {
      this.date = e3.date, this.ut = e3.ut, this.tt = e3.tt;
      return;
    }
    const t2 = 1e3 * 3600 * 24;
    if (e3 instanceof Date && Number.isFinite(e3.getTime())) {
      this.date = e3, this.ut = (e3.getTime() - nt.getTime()) / t2, this.tt = rt(this.ut);
      return;
    }
    if (Number.isFinite(e3)) {
      this.date = new Date(nt.getTime() + e3 * t2), this.ut = e3, this.tt = rt(this.ut);
      return;
    }
    throw "Argument must be a Date object, an AstroTime object, or a numeric UTC Julian date.";
  }
  /**
   * @brief Creates an `AstroTime` value from a Terrestrial Time (TT) day value.
   *
   * This function can be used in rare cases where a time must be based
   * on Terrestrial Time (TT) rather than Universal Time (UT).
   * Most developers will want to invoke `new AstroTime(ut)` with a universal time
   * instead of this function, because usually time is based on civil time adjusted
   * by leap seconds to match the Earth's rotation, rather than the uniformly
   * flowing TT used to calculate solar system dynamics. In rare cases
   * where the caller already knows TT, this function is provided to create
   * an `AstroTime` value that can be passed to Astronomy Engine functions.
   *
   * @param {number} tt
   *      The number of days since the J2000 epoch as expressed in Terrestrial Time.
   *
   * @returns {AstroTime}
   *      An `AstroTime` object for the specified terrestrial time.
   */
  static FromTerrestrialTime(e3) {
    let t2 = new _Z(e3);
    for (; ; ) {
      const r3 = e3 - t2.tt;
      if (Math.abs(r3) < 1e-12)
        return t2;
      t2 = t2.AddDays(r3);
    }
  }
  /**
   * Formats an `AstroTime` object as an [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601)
   * date/time string in UTC, to millisecond resolution.
   * Example: `2018-08-17T17:22:04.050Z`
   * @returns {string}
   */
  toString() {
    return this.date.toISOString();
  }
  /**
   * Returns a new `AstroTime` object adjusted by the floating point number of days.
   * Does NOT modify the original `AstroTime` object.
   *
   * @param {number} days
   *      The floating point number of days by which to adjust the given date and time.
   *      Positive values adjust the date toward the future, and
   *      negative values adjust the date toward the past.
   *
   * @returns {AstroTime}
   */
  AddDays(e3) {
    return new _Z(this.ut + e3);
  }
};
function d0(n3) {
  return n3 instanceof Z ? n3 : new Z(n3);
}
function rr(n3) {
  function e3(f2) {
    return f2 % Kn * v0;
  }
  const t2 = n3.tt / 36525, r3 = e3(128710479305e-5 + t2 * 1295965810481e-4), i2 = e3(335779.526232 + t2 * 17395272628478e-4), o2 = e3(107226070369e-5 + t2 * 1602961601209e-3), a2 = e3(450160.398036 - t2 * 69628905431e-4);
  let c3 = Math.sin(a2), s = Math.cos(a2), d2 = (-172064161 - 174666 * t2) * c3 + 33386 * s, h2 = (92052331 + 9086 * t2) * s + 15377 * c3, m3 = 2 * (i2 - o2 + a2);
  return c3 = Math.sin(m3), s = Math.cos(m3), d2 += (-13170906 - 1675 * t2) * c3 - 13696 * s, h2 += (5730336 - 3015 * t2) * s - 4587 * c3, m3 = 2 * (i2 + a2), c3 = Math.sin(m3), s = Math.cos(m3), d2 += (-2276413 - 234 * t2) * c3 + 2796 * s, h2 += (978459 - 485 * t2) * s + 1374 * c3, m3 = 2 * a2, c3 = Math.sin(m3), s = Math.cos(m3), d2 += (2074554 + 207 * t2) * c3 - 698 * s, h2 += (-897492 + 470 * t2) * s - 291 * c3, c3 = Math.sin(r3), s = Math.cos(r3), d2 += (1475877 - 3633 * t2) * c3 + 11817 * s, h2 += (73871 - 184 * t2) * s - 1924 * c3, {
    dpsi: -135e-6 + d2 * 1e-7,
    deps: 388e-6 + h2 * 1e-7
  };
}
function Pt(n3) {
  var e3 = n3.tt / 36525, t2 = ((((-434e-10 * e3 - 576e-9) * e3 + 20034e-7) * e3 - 1831e-7) * e3 - 46.836769) * e3 + 84381.406;
  return t2 / 3600;
}
var Y0;
function Nt(n3) {
  if (!Y0 || Math.abs(Y0.tt - n3.tt) > 1e-6) {
    const e3 = rr(n3), t2 = Pt(n3), r3 = t2 + e3.deps / 3600;
    Y0 = {
      tt: n3.tt,
      dpsi: e3.dpsi,
      deps: e3.deps,
      ee: e3.dpsi * Math.cos(t2 * a0) / 15,
      mobl: t2,
      tobl: r3
    };
  }
  return Y0;
}
function ir(n3, e3) {
  const t2 = n3 * a0, r3 = Math.cos(t2), i2 = Math.sin(t2);
  return [
    e3[0],
    e3[1] * r3 - e3[2] * i2,
    e3[1] * i2 + e3[2] * r3
  ];
}
function ar(n3, e3) {
  return ir(Pt(n3), e3);
}
function or(n3) {
  const e3 = n3.tt / 36525;
  function t2(S, _2) {
    const A2 = [];
    let M;
    for (M = 0; M <= _2 - S; ++M)
      A2.push(0);
    return { min: S, array: A2 };
  }
  function r3(S, _2, A2, M) {
    const y = [];
    for (let $ = 0; $ <= _2 - S; ++$)
      y.push(t2(A2, M));
    return { min: S, array: y };
  }
  function i2(S, _2, A2) {
    const M = S.array[_2 - S.min];
    return M.array[A2 - M.min];
  }
  function o2(S, _2, A2, M) {
    const y = S.array[_2 - S.min];
    y.array[A2 - y.min] = M;
  }
  let a2, c3, s, d2, h2, m3, f2, T2, p3, E, R, D2, P2, N, H, G, B, F, H0, M0, U0, b0, Q, G0 = r3(-6, 6, 1, 4), F0 = r3(-6, 6, 1, 4);
  function h0(S, _2) {
    return i2(G0, S, _2);
  }
  function z0(S, _2) {
    return i2(F0, S, _2);
  }
  function k0(S, _2, A2) {
    return o2(G0, S, _2, A2);
  }
  function B0(S, _2, A2) {
    return o2(F0, S, _2, A2);
  }
  function Ye(S, _2, A2, M, y) {
    y(S * A2 - _2 * M, _2 * A2 + S * M);
  }
  function x2(S) {
    return Math.sin(W * S);
  }
  f2 = e3 * e3, p3 = 0, Q = 0, R = 0, D2 = 3422.7;
  var V0 = x2(0.19833 + 0.05611 * e3), me = x2(0.27869 + 0.04508 * e3), fe = x2(0.16827 - 0.36903 * e3), ge = x2(0.34734 - 5.37261 * e3), pe = x2(0.10498 - 5.37899 * e3), W0 = x2(0.42681 - 0.41855 * e3), Vt = x2(0.14943 - 5.37511 * e3);
  for (F = 0.84 * V0 + 0.31 * me + 14.27 * fe + 7.26 * ge + 0.28 * pe + 0.24 * W0, H0 = 2.94 * V0 + 0.31 * me + 14.27 * fe + 9.34 * ge + 1.12 * pe + 0.83 * W0, M0 = -6.4 * V0 - 1.89 * W0, U0 = 0.21 * V0 + 0.31 * me + 14.27 * fe - 88.7 * ge - 15.3 * pe + 0.24 * W0 - 1.86 * Vt, b0 = F - M0, T2 = -3332e-9 * x2(0.59734 - 5.37261 * e3) - 539e-9 * x2(0.35498 - 5.37899 * e3) - 64e-9 * x2(0.39943 - 5.37511 * e3), P2 = W * p0(0.60643382 + 1336.85522467 * e3 - 313e-8 * f2) + F / q, N = W * p0(0.37489701 + 1325.55240982 * e3 + 2565e-8 * f2) + H0 / q, H = W * p0(0.99312619 + 99.99735956 * e3 - 44e-8 * f2) + M0 / q, G = W * p0(0.25909118 + 1342.2278298 * e3 - 892e-8 * f2) + U0 / q, B = W * p0(0.82736186 + 1236.85308708 * e3 - 397e-8 * f2) + b0 / q, h2 = 1; h2 <= 4; ++h2) {
    switch (h2) {
      case 1:
        s = N, c3 = 4, d2 = 1.000002208;
        break;
      case 2:
        s = H, c3 = 3, d2 = 0.997504612 - 2495388e-9 * e3;
        break;
      case 3:
        s = G, c3 = 4, d2 = 1.000002708 + 139.978 * T2;
        break;
      case 4:
        s = B, c3 = 6, d2 = 1;
        break;
      default:
        throw `Internal error: I = ${h2}`;
    }
    for (k0(0, h2, 1), k0(1, h2, Math.cos(s) * d2), B0(0, h2, 0), B0(1, h2, Math.sin(s) * d2), m3 = 2; m3 <= c3; ++m3)
      Ye(h0(m3 - 1, h2), z0(m3 - 1, h2), h0(1, h2), z0(1, h2), (S, _2) => (k0(m3, h2, S), B0(m3, h2, _2)));
    for (m3 = 1; m3 <= c3; ++m3)
      k0(-m3, h2, h0(m3, h2)), B0(-m3, h2, -z0(m3, h2));
  }
  function Ke(S, _2, A2, M) {
    for (var y = { x: 1, y: 0 }, $ = [0, S, _2, A2, M], V = 1; V <= 4; ++V)
      $[V] !== 0 && Ye(y.x, y.y, h0($[V], V), z0($[V], V), (Te, m0) => (y.x = Te, y.y = m0));
    return y;
  }
  function u2(S, _2, A2, M, y, $, V, Te) {
    var m0 = Ke(y, $, V, Te);
    p3 += S * m0.y, Q += _2 * m0.y, R += A2 * m0.x, D2 += M * m0.x;
  }
  u2(13.902, 14.06, -1e-3, 0.2607, 0, 0, 0, 4), u2(0.403, -4.01, 0.394, 23e-4, 0, 0, 0, 3), u2(2369.912, 2373.36, 0.601, 28.2333, 0, 0, 0, 2), u2(-125.154, -112.79, -0.725, -0.9781, 0, 0, 0, 1), u2(1.979, 6.98, -0.445, 0.0433, 1, 0, 0, 4), u2(191.953, 192.72, 0.029, 3.0861, 1, 0, 0, 2), u2(-8.466, -13.51, 0.455, -0.1093, 1, 0, 0, 1), u2(22639.5, 22609.07, 0.079, 186.5398, 1, 0, 0, 0), u2(18.609, 3.59, -0.094, 0.0118, 1, 0, 0, -1), u2(-4586.465, -4578.13, -0.077, 34.3117, 1, 0, 0, -2), u2(3.215, 5.44, 0.192, -0.0386, 1, 0, 0, -3), u2(-38.428, -38.64, 1e-3, 0.6008, 1, 0, 0, -4), u2(-0.393, -1.43, -0.092, 86e-4, 1, 0, 0, -6), u2(-0.289, -1.59, 0.123, -53e-4, 0, 1, 0, 4), u2(-24.42, -25.1, 0.04, -0.3, 0, 1, 0, 2), u2(18.023, 17.93, 7e-3, 0.1494, 0, 1, 0, 1), u2(-668.146, -126.98, -1.302, -0.3997, 0, 1, 0, 0), u2(0.56, 0.32, -1e-3, -37e-4, 0, 1, 0, -1), u2(-165.145, -165.06, 0.054, 1.9178, 0, 1, 0, -2), u2(-1.877, -6.46, -0.416, 0.0339, 0, 1, 0, -4), u2(0.213, 1.02, -0.074, 54e-4, 2, 0, 0, 4), u2(14.387, 14.78, -0.017, 0.2833, 2, 0, 0, 2), u2(-0.586, -1.2, 0.054, -0.01, 2, 0, 0, 1), u2(769.016, 767.96, 0.107, 10.1657, 2, 0, 0, 0), u2(1.75, 2.01, -0.018, 0.0155, 2, 0, 0, -1), u2(-211.656, -152.53, 5.679, -0.3039, 2, 0, 0, -2), u2(1.225, 0.91, -0.03, -88e-4, 2, 0, 0, -3), u2(-30.773, -34.07, -0.308, 0.3722, 2, 0, 0, -4), u2(-0.57, -1.4, -0.074, 0.0109, 2, 0, 0, -6), u2(-2.921, -11.75, 0.787, -0.0484, 1, 1, 0, 2), u2(1.267, 1.52, -0.022, 0.0164, 1, 1, 0, 1), u2(-109.673, -115.18, 0.461, -0.949, 1, 1, 0, 0), u2(-205.962, -182.36, 2.056, 1.4437, 1, 1, 0, -2), u2(0.233, 0.36, 0.012, -25e-4, 1, 1, 0, -3), u2(-4.391, -9.66, -0.471, 0.0673, 1, 1, 0, -4), u2(0.283, 1.53, -0.111, 6e-3, 1, -1, 0, 4), u2(14.577, 31.7, -1.54, 0.2302, 1, -1, 0, 2), u2(147.687, 138.76, 0.679, 1.1528, 1, -1, 0, 0), u2(-1.089, 0.55, 0.021, 0, 1, -1, 0, -1), u2(28.475, 23.59, -0.443, -0.2257, 1, -1, 0, -2), u2(-0.276, -0.38, -6e-3, -36e-4, 1, -1, 0, -3), u2(0.636, 2.27, 0.146, -0.0102, 1, -1, 0, -4), u2(-0.189, -1.68, 0.131, -28e-4, 0, 2, 0, 2), u2(-7.486, -0.66, -0.037, -86e-4, 0, 2, 0, 0), u2(-8.096, -16.35, -0.74, 0.0918, 0, 2, 0, -2), u2(-5.741, -0.04, 0, -9e-4, 0, 0, 2, 2), u2(0.255, 0, 0, 0, 0, 0, 2, 1), u2(-411.608, -0.2, 0, -0.0124, 0, 0, 2, 0), u2(0.584, 0.84, 0, 71e-4, 0, 0, 2, -1), u2(-55.173, -52.14, 0, -0.1052, 0, 0, 2, -2), u2(0.254, 0.25, 0, -17e-4, 0, 0, 2, -3), u2(0.025, -1.67, 0, 31e-4, 0, 0, 2, -4), u2(1.06, 2.96, -0.166, 0.0243, 3, 0, 0, 2), u2(36.124, 50.64, -1.3, 0.6215, 3, 0, 0, 0), u2(-13.193, -16.4, 0.258, -0.1187, 3, 0, 0, -2), u2(-1.187, -0.74, 0.042, 74e-4, 3, 0, 0, -4), u2(-0.293, -0.31, -2e-3, 46e-4, 3, 0, 0, -6), u2(-0.29, -1.45, 0.116, -51e-4, 2, 1, 0, 2), u2(-7.649, -10.56, 0.259, -0.1038, 2, 1, 0, 0), u2(-8.627, -7.59, 0.078, -0.0192, 2, 1, 0, -2), u2(-2.74, -2.54, 0.022, 0.0324, 2, 1, 0, -4), u2(1.181, 3.32, -0.212, 0.0213, 2, -1, 0, 2), u2(9.703, 11.67, -0.151, 0.1268, 2, -1, 0, 0), u2(-0.352, -0.37, 1e-3, -28e-4, 2, -1, 0, -1), u2(-2.494, -1.17, -3e-3, -17e-4, 2, -1, 0, -2), u2(0.36, 0.2, -0.012, -43e-4, 2, -1, 0, -4), u2(-1.167, -1.25, 8e-3, -0.0106, 1, 2, 0, 0), u2(-7.412, -6.12, 0.117, 0.0484, 1, 2, 0, -2), u2(-0.311, -0.65, -0.032, 44e-4, 1, 2, 0, -4), u2(0.757, 1.82, -0.105, 0.0112, 1, -2, 0, 2), u2(2.58, 2.32, 0.027, 0.0196, 1, -2, 0, 0), u2(2.533, 2.4, -0.014, -0.0212, 1, -2, 0, -2), u2(-0.344, -0.57, -0.025, 36e-4, 0, 3, 0, -2), u2(-0.992, -0.02, 0, 0, 1, 0, 2, 2), u2(-45.099, -0.02, 0, -1e-3, 1, 0, 2, 0), u2(-0.179, -9.52, 0, -0.0833, 1, 0, 2, -2), u2(-0.301, -0.33, 0, 14e-4, 1, 0, 2, -4), u2(-6.382, -3.37, 0, -0.0481, 1, 0, -2, 2), u2(39.528, 85.13, 0, -0.7136, 1, 0, -2, 0), u2(9.366, 0.71, 0, -0.0112, 1, 0, -2, -2), u2(0.202, 0.02, 0, 0, 1, 0, -2, -4), u2(0.415, 0.1, 0, 13e-4, 0, 1, 2, 0), u2(-2.152, -2.26, 0, -66e-4, 0, 1, 2, -2), u2(-1.44, -1.3, 0, 14e-4, 0, 1, -2, 2), u2(0.384, -0.04, 0, 0, 0, 1, -2, -2), u2(1.938, 3.6, -0.145, 0.0401, 4, 0, 0, 0), u2(-0.952, -1.58, 0.052, -0.013, 4, 0, 0, -2), u2(-0.551, -0.94, 0.032, -97e-4, 3, 1, 0, 0), u2(-0.482, -0.57, 5e-3, -45e-4, 3, 1, 0, -2), u2(0.681, 0.96, -0.026, 0.0115, 3, -1, 0, 0), u2(-0.297, -0.27, 2e-3, -9e-4, 2, 2, 0, -2), u2(0.254, 0.21, -3e-3, 0, 2, -2, 0, -2), u2(-0.25, -0.22, 4e-3, 14e-4, 1, 3, 0, -2), u2(-3.996, 0, 0, 4e-4, 2, 0, 2, 0), u2(0.557, -0.75, 0, -9e-3, 2, 0, 2, -2), u2(-0.459, -0.38, 0, -53e-4, 2, 0, -2, 2), u2(-1.298, 0.74, 0, 4e-4, 2, 0, -2, 0), u2(0.538, 1.14, 0, -0.0141, 2, 0, -2, -2), u2(0.263, 0.02, 0, 0, 1, 1, 2, 0), u2(0.426, 0.07, 0, -6e-4, 1, 1, -2, -2), u2(-0.304, 0.03, 0, 3e-4, 1, -1, 2, 0), u2(-0.372, -0.19, 0, -27e-4, 1, -1, -2, 2), u2(0.418, 0, 0, 0, 0, 0, 4, 0), u2(-0.33, -0.04, 0, 0, 3, 0, 2, 0);
  function z(S, _2, A2, M, y) {
    return S * Ke(_2, A2, M, y).y;
  }
  E = 0, E += z(-526.069, 0, 0, 1, -2), E += z(-3.352, 0, 0, 1, -4), E += z(44.297, 1, 0, 1, -2), E += z(-6, 1, 0, 1, -4), E += z(20.599, -1, 0, 1, 0), E += z(-30.598, -1, 0, 1, -2), E += z(-24.649, -2, 0, 1, 0), E += z(-2, -2, 0, 1, -2), E += z(-22.571, 0, 1, 1, -2), E += z(10.985, 0, -1, 1, -2), p3 += 0.82 * x2(0.7736 - 62.5512 * e3) + 0.31 * x2(0.0466 - 125.1025 * e3) + 0.35 * x2(0.5785 - 25.1042 * e3) + 0.66 * x2(0.4591 + 1335.8075 * e3) + 0.64 * x2(0.313 - 91.568 * e3) + 1.14 * x2(0.148 + 1331.2898 * e3) + 0.21 * x2(0.5918 + 1056.5859 * e3) + 0.44 * x2(0.5784 + 1322.8595 * e3) + 0.24 * x2(0.2275 - 5.7374 * e3) + 0.28 * x2(0.2965 + 2.6929 * e3) + 0.33 * x2(0.3132 + 6.3368 * e3), a2 = G + Q / q;
  let Wt = (1.000002708 + 139.978 * T2) * (18518.511 + 1.189 + R) * Math.sin(a2) - 6.24 * Math.sin(3 * a2) + E;
  return {
    geo_eclip_lon: W * p0((P2 + p3 / q) / W),
    geo_eclip_lat: Math.PI / (180 * 3600) * Wt,
    distance_au: q * qn / (0.999953253 * D2)
  };
}
function sr(n3, e3) {
  return [
    n3.rot[0][0] * e3[0] + n3.rot[1][0] * e3[1] + n3.rot[2][0] * e3[2],
    n3.rot[0][1] * e3[0] + n3.rot[1][1] * e3[1] + n3.rot[2][1] * e3[2],
    n3.rot[0][2] * e3[0] + n3.rot[1][2] * e3[1] + n3.rot[2][2] * e3[2]
  ];
}
function cr(n3, e3, t2) {
  const r3 = Ot(e3, t2);
  return sr(r3, n3);
}
function Ot(n3, e3) {
  const t2 = n3.tt / 36525;
  let r3 = 84381.406, i2 = ((((-951e-10 * t2 + 132851e-9) * t2 - 114045e-8) * t2 - 1.0790069) * t2 + 5038.481507) * t2, o2 = ((((3337e-10 * t2 - 467e-9) * t2 - 772503e-8) * t2 + 0.0512623) * t2 - 0.025754) * t2 + r3, a2 = ((((-56e-9 * t2 + 170663e-9) * t2 - 121197e-8) * t2 - 2.3814292) * t2 + 10.556403) * t2;
  r3 *= v0, i2 *= v0, o2 *= v0, a2 *= v0;
  const c3 = Math.sin(r3), s = Math.cos(r3), d2 = Math.sin(-i2), h2 = Math.cos(-i2), m3 = Math.sin(-o2), f2 = Math.cos(-o2), T2 = Math.sin(a2), p3 = Math.cos(a2), E = p3 * h2 - d2 * T2 * f2, R = p3 * d2 * s + T2 * f2 * h2 * s - c3 * T2 * m3, D2 = p3 * d2 * c3 + T2 * f2 * h2 * c3 + s * T2 * m3, P2 = -T2 * h2 - d2 * p3 * f2, N = -T2 * d2 * s + p3 * f2 * h2 * s - c3 * p3 * m3, H = -T2 * d2 * c3 + p3 * f2 * h2 * c3 + s * p3 * m3, G = d2 * m3, B = -m3 * h2 * s - c3 * f2, F = -m3 * h2 * c3 + f2 * s;
  if (e3 === K.Into2000)
    return new w0([
      [E, R, D2],
      [P2, N, H],
      [G, B, F]
    ]);
  if (e3 === K.From2000)
    return new w0([
      [E, P2, G],
      [R, N, B],
      [D2, H, F]
    ]);
  throw "Invalid precess direction";
}
function ur(n3) {
  const e3 = 0.779057273264 + 0.00273781191135448 * n3.ut, t2 = n3.ut % 1;
  let r3 = 360 * ((e3 + t2) % 1);
  return r3 < 0 && (r3 += 360), r3;
}
var K0;
function lr(n3) {
  if (!K0 || K0.tt !== n3.tt) {
    const e3 = n3.tt / 36525;
    let t2 = 15 * Nt(n3).ee;
    const r3 = ur(n3);
    let o2 = ((t2 + 0.014506 + ((((-368e-10 * e3 - 29956e-9) * e3 - 44e-8) * e3 + 1.3915817) * e3 + 4612.156534) * e3) / 3600 + r3) % 360 / 15;
    o2 < 0 && (o2 += 24), K0 = {
      tt: n3.tt,
      st: o2
    };
  }
  return K0.st;
}
function dr(n3) {
  const e3 = d0(n3);
  return lr(e3);
}
function hr(n3, e3) {
  const t2 = Nt(n3), r3 = t2.mobl * a0, i2 = t2.tobl * a0, o2 = t2.dpsi * v0, a2 = Math.cos(r3), c3 = Math.sin(r3), s = Math.cos(i2), d2 = Math.sin(i2), h2 = Math.cos(o2), m3 = Math.sin(o2), f2 = h2, T2 = -m3 * a2, p3 = -m3 * c3, E = m3 * s, R = h2 * a2 * s + c3 * d2, D2 = h2 * c3 * s - a2 * d2, P2 = m3 * d2, N = h2 * a2 * d2 - c3 * s, H = h2 * c3 * d2 + a2 * s;
  if (e3 === K.From2000)
    return new w0([
      [f2, E, P2],
      [T2, R, N],
      [p3, D2, H]
    ]);
  if (e3 === K.Into2000)
    return new w0([
      [f2, T2, p3],
      [E, R, D2],
      [P2, N, H]
    ]);
  throw "Invalid precess direction";
}
var b2 = class {
  constructor(e3, t2, r3, i2) {
    this.x = e3, this.y = t2, this.z = r3, this.t = i2;
  }
  /**
   * Returns the length of the vector in astronomical units (AU).
   * @returns {number}
   */
  Length() {
    return Math.hypot(this.x, this.y, this.z);
  }
};
var mr = class {
  constructor(e3, t2, r3, i2, o2, a2, c3) {
    this.x = e3, this.y = t2, this.z = r3, this.vx = i2, this.vy = o2, this.vz = a2, this.t = c3;
  }
};
var fr = class {
  constructor(e3, t2, r3) {
    this.lat = J0(e3), this.lon = J0(t2), this.dist = J0(r3);
  }
};
var w0 = class {
  constructor(e3) {
    this.rot = e3;
  }
};
function Ie(n3) {
  const e3 = d0(n3), t2 = or(e3), r3 = t2.distance_au * Math.cos(t2.geo_eclip_lat), i2 = [
    r3 * Math.cos(t2.geo_eclip_lon),
    r3 * Math.sin(t2.geo_eclip_lon),
    t2.distance_au * Math.sin(t2.geo_eclip_lat)
  ], o2 = ar(e3, i2), a2 = cr(o2, e3, K.Into2000);
  return new b2(a2[0], a2[1], a2[2], e3);
}
function R0(n3, e3, t2) {
  let r3 = 1, i2 = 0;
  for (let o2 of n3) {
    let a2 = 0;
    for (let [s, d2, h2] of o2)
      a2 += s * Math.cos(d2 + e3 * h2);
    let c3 = r3 * a2;
    t2 && (c3 %= W), i2 += c3, r3 *= e3;
  }
  return i2;
}
function _e(n3, e3) {
  let t2 = 1, r3 = 0, i2 = 0, o2 = 0;
  for (let a2 of n3) {
    let c3 = 0, s = 0;
    for (let [d2, h2, m3] of a2) {
      let f2 = h2 + e3 * m3;
      c3 += d2 * m3 * Math.sin(f2), o2 > 0 && (s += d2 * Math.cos(f2));
    }
    i2 += o2 * r3 * s - t2 * c3, r3 = t2, t2 *= e3, ++o2;
  }
  return i2;
}
var I0 = 365250;
var Pe = 0;
var Ne = 1;
var Oe = 2;
function Le(n3) {
  return new I(n3[0] + 44036e-11 * n3[1] - 190919e-12 * n3[2], -479966e-12 * n3[0] + 0.917482137087 * n3[1] - 0.397776982902 * n3[2], 0.397776982902 * n3[1] + 0.917482137087 * n3[2]);
}
function Lt(n3, e3, t2) {
  const r3 = t2 * Math.cos(e3), i2 = Math.cos(n3), o2 = Math.sin(n3);
  return [
    r3 * i2,
    r3 * o2,
    t2 * Math.sin(e3)
  ];
}
function Q0(n3, e3) {
  const t2 = e3.tt / I0, r3 = R0(n3[Pe], t2, true), i2 = R0(n3[Ne], t2, false), o2 = R0(n3[Oe], t2, false), a2 = Lt(r3, i2, o2);
  return Le(a2).ToAstroVector(e3);
}
function gr(n3, e3) {
  const t2 = e3 / I0, r3 = R0(n3[Pe], t2, true), i2 = R0(n3[Ne], t2, false), o2 = R0(n3[Oe], t2, false), a2 = _e(n3[Pe], t2), c3 = _e(n3[Ne], t2), s = _e(n3[Oe], t2), d2 = Math.cos(r3), h2 = Math.sin(r3), m3 = Math.cos(i2), f2 = Math.sin(i2), T2 = +(s * m3 * d2) - o2 * f2 * d2 * c3 - o2 * m3 * h2 * a2, p3 = +(s * m3 * h2) - o2 * f2 * h2 * c3 + o2 * m3 * d2 * a2, E = +(s * f2) + o2 * m3 * c3, R = Lt(r3, i2, o2), D2 = [
    T2 / I0,
    p3 / I0,
    E / I0
  ], P2 = Le(R), N = Le(D2);
  return new o0(e3, P2, N);
}
function $0(n3, e3, t2, r3) {
  const i2 = r3 / (r3 + Be), o2 = Q0(E0[t2], e3);
  n3.x += i2 * o2.x, n3.y += i2 * o2.y, n3.z += i2 * o2.z;
}
function pr(n3) {
  const e3 = new b2(0, 0, 0, n3);
  return $0(e3, n3, v4.Jupiter, Me), $0(e3, n3, v4.Saturn, ye), $0(e3, n3, v4.Uranus, Ce), $0(e3, n3, v4.Neptune, De), e3;
}
var He = 51;
var Tr = 29200;
var _0 = 146;
var j = 201;
var e0 = [
  [-73e4, [-26.118207232108, -14.376168177825, 3.384402515299], [0.0016339372163656, -0.0027861699588508, -0.0013585880229445]],
  [-700800, [41.974905202127, -0.448502952929, -12.770351505989], [73458569351457e-17, 0.0022785014891658, 48619778602049e-17]],
  [-671600, [14.706930780744, 44.269110540027, 9.353698474772], [-0.00210001479998, 22295915939915e-17, 70143443551414e-17]],
  [-642400, [-29.441003929957, -6.43016153057, 6.858481011305], [84495803960544e-17, -0.0030783914758711, -0.0012106305981192]],
  [-613200, [39.444396946234, -6.557989760571, -13.913760296463], [0.0011480029005873, 0.0022400006880665, 35168075922288e-17]],
  [-584e3, [20.2303809507, 43.266966657189, 7.382966091923], [-0.0019754081700585, 53457141292226e-17, 75929169129793e-17]],
  [-554800, [-30.65832536462, 2.093818874552, 9.880531138071], [61010603013347e-18, -0.0031326500935382, -99346125151067e-17]],
  [-525600, [35.737703251673, -12.587706024764, -14.677847247563], [0.0015802939375649, 0.0021347678412429, 19074436384343e-17]],
  [-496400, [25.466295188546, 41.367478338417, 5.216476873382], [-0.0018054401046468, 8328308359951e-16, 80260156912107e-17]],
  [-467200, [-29.847174904071, 10.636426313081, 12.297904180106], [-63257063052907e-17, -0.0029969577578221, -74476074151596e-17]],
  [-438e3, [30.774692107687, -18.236637015304, -14.945535879896], [0.0020113162005465, 0.0019353827024189, -20937793168297e-19]],
  [-408800, [30.243153324028, 38.656267888503, 2.938501750218], [-0.0016052508674468, 0.0011183495337525, 83333973416824e-17]],
  [-379600, [-27.288984772533, 18.643162147874, 14.023633623329], [-0.0011856388898191, -0.0027170609282181, -49015526126399e-17]],
  [-350400, [24.519605196774, -23.245756064727, -14.626862367368], [0.0024322321483154, 0.0016062008146048, -23369181613312e-17]],
  [-321200, [34.505274805875, 35.125338586954, 0.557361475637], [-0.0013824391637782, 0.0013833397561817, 84823598806262e-17]],
  [-292e3, [-23.275363915119, 25.818514298769, 15.055381588598], [-0.0016062295460975, -0.0023395961498533, -24377362639479e-17]],
  [-262800, [17.050384798092, -27.180376290126, -13.608963321694], [0.0028175521080578, 0.0011358749093955, -49548725258825e-17]],
  [-233600, [38.093671910285, 30.880588383337, -1.843688067413], [-0.0011317697153459, 0.0016128814698472, 84177586176055e-17]],
  [-204400, [-18.197852930878, 31.932869934309, 15.438294826279], [-0.0019117272501813, -0.0019146495909842, -19657304369835e-18]],
  [-175200, [8.528924039997, -29.618422200048, -11.805400994258], [0.0031034370787005, 5139363329243e-16, -77293066202546e-17]],
  [-146e3, [40.94685725864, 25.904973592021, -4.256336240499], [-83652705194051e-17, 0.0018129497136404, 8156422827306e-16]],
  [-116800, [-12.326958895325, 36.881883446292, 15.217158258711], [-0.0021166103705038, -0.001481442003599, 17401209844705e-17]],
  [-87600, [-0.633258375909, -30.018759794709, -9.17193287495], [0.0032016994581737, -25279858672148e-17, -0.0010411088271861]],
  [-58400, [42.936048423883, 20.344685584452, -6.588027007912], [-50525450073192e-17, 0.0019910074335507, 77440196540269e-17]],
  [-29200, [-5.975910552974, 40.61180995846, 14.470131723673], [-0.0022184202156107, -0.0010562361130164, 33652250216211e-17]],
  [0, [-9.875369580774, -27.978926224737, -5.753711824704], [0.0030287533248818, -0.0011276087003636, -0.0012651326732361]],
  [29200, [43.958831986165, 14.214147973292, -8.808306227163], [-14717608981871e-17, 0.0021404187242141, 71486567806614e-17]],
  [58400, [0.67813676352, 43.094461639362, 13.243238780721], [-0.0022358226110718, -63233636090933e-17, 47664798895648e-17]],
  [87600, [-18.282602096834, -23.30503958666, -1.766620508028], [0.0025567245263557, -0.0019902940754171, -0.0013943491701082]],
  [116800, [43.873338744526, 7.700705617215, -10.814273666425], [23174803055677e-17, 0.0022402163127924, 62988756452032e-17]],
  [146e3, [7.392949027906, 44.382678951534, 11.629500214854], [-0.002193281545383, -21751799585364e-17, 59556516201114e-17]],
  [175200, [-24.981690229261, -16.204012851426, 2.466457544298], [0.001819398914958, -0.0026765419531201, -0.0013848283502247]],
  [204400, [42.530187039511, 0.845935508021, -12.554907527683], [65059779150669e-17, 0.0022725657282262, 51133743202822e-17]],
  [233600, [13.999526486822, 44.462363044894, 9.669418486465], [-0.0021079296569252, 17533423831993e-17, 69128485798076e-17]],
  [262800, [-29.184024803031, -7.371243995762, 6.493275957928], [93581363109681e-17, -0.0030610357109184, -0.0012364201089345]],
  [292e3, [39.831980671753, -6.078405766765, -13.909815358656], [0.0011117769689167, 0.0022362097830152, 36230548231153e-17]],
  [321200, [20.294955108476, 43.417190420251, 7.450091985932], [-0.0019742157451535, 53102050468554e-17, 75938408813008e-17]],
  [350400, [-30.66999230216, 2.318743558955, 9.973480913858], [45605107450676e-18, -0.0031308219926928, -99066533301924e-17]],
  [379600, [35.626122155983, -12.897647509224, -14.777586508444], [0.0016015684949743, 0.0021171931182284, 18002516202204e-17]],
  [408800, [26.133186148561, 41.232139187599, 5.00640132622], [-0.0017857704419579, 86046232702817e-17, 80614690298954e-17]],
  [438e3, [-29.57674022923, 11.863535943587, 12.631323039872], [-72292830060955e-17, -0.0029587820140709, -708242964503e-15]],
  [467200, [29.910805787391, -19.159019294, -15.013363865194], [0.0020871080437997, 0.0018848372554514, -38528655083926e-18]],
  [496400, [31.375957451819, 38.050372720763, 2.433138343754], [-0.0015546055556611, 0.0011699815465629, 83565439266001e-17]],
  [525600, [-26.360071336928, 20.662505904952, 14.414696258958], [-0.0013142373118349, -0.0026236647854842, -42542017598193e-17]],
  [554800, [22.599441488648, -24.508879898306, -14.484045731468], [0.0025454108304806, 0.0014917058755191, -30243665086079e-17]],
  [584e3, [35.877864013014, 33.894226366071, -0.224524636277], [-0.0012941245730845, 0.0014560427668319, 84762160640137e-17]],
  [613200, [-21.538149762417, 28.204068269761, 15.321973799534], [-0.001731211740901, -0.0021939631314577, -1631691327518e-16]],
  [642400, [13.971521374415, -28.339941764789, -13.083792871886], [0.0029334630526035, 91860931752944e-17, -59939422488627e-17]],
  [671600, [39.526942044143, 28.93989736011, -2.872799527539], [-0.0010068481658095, 0.001702113288809, 83578230511981e-17]],
  [700800, [-15.576200701394, 34.399412961275, 15.466033737854], [-0.0020098814612884, -0.0017191109825989, 70414782780416e-18]],
  [73e4, [4.24325283709, -30.118201690825, -10.707441231349], [0.0031725847067411, 1609846120227e-16, -90672150593868e-17]]
];
var I = class _I {
  constructor(e3, t2, r3) {
    this.x = e3, this.y = t2, this.z = r3;
  }
  clone() {
    return new _I(this.x, this.y, this.z);
  }
  ToAstroVector(e3) {
    return new b2(this.x, this.y, this.z, e3);
  }
  static zero() {
    return new _I(0, 0, 0);
  }
  quadrature() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  add(e3) {
    return new _I(this.x + e3.x, this.y + e3.y, this.z + e3.z);
  }
  sub(e3) {
    return new _I(this.x - e3.x, this.y - e3.y, this.z - e3.z);
  }
  incr(e3) {
    this.x += e3.x, this.y += e3.y, this.z += e3.z;
  }
  decr(e3) {
    this.x -= e3.x, this.y -= e3.y, this.z -= e3.z;
  }
  mul(e3) {
    return new _I(e3 * this.x, e3 * this.y, e3 * this.z);
  }
  div(e3) {
    return new _I(this.x / e3, this.y / e3, this.z / e3);
  }
  mean(e3) {
    return new _I((this.x + e3.x) / 2, (this.y + e3.y) / 2, (this.z + e3.z) / 2);
  }
  neg() {
    return new _I(-this.x, -this.y, -this.z);
  }
};
var o0 = class _o0 {
  constructor(e3, t2, r3) {
    this.tt = e3, this.r = t2, this.v = r3;
  }
  clone() {
    return new _o0(this.tt, this.r, this.v);
  }
  sub(e3) {
    return new _o0(this.tt, this.r.sub(e3.r), this.v.sub(e3.v));
  }
};
function Sr(n3) {
  let [e3, [t2, r3, i2], [o2, a2, c3]] = n3;
  return new o0(e3, new I(t2, r3, i2), new I(o2, a2, c3));
}
function q0(n3, e3, t2, r3) {
  const i2 = r3 / (r3 + Be), o2 = gr(E0[t2], e3);
  return n3.r.incr(o2.r.mul(i2)), n3.v.incr(o2.v.mul(i2)), o2;
}
function D0(n3, e3, t2) {
  const r3 = t2.sub(n3), i2 = r3.quadrature();
  return r3.mul(e3 / (i2 * Math.sqrt(i2)));
}
var Ve = class {
  constructor(e3) {
    let t2 = new o0(e3, new I(0, 0, 0), new I(0, 0, 0));
    this.Jupiter = q0(t2, e3, v4.Jupiter, Me), this.Saturn = q0(t2, e3, v4.Saturn, ye), this.Uranus = q0(t2, e3, v4.Uranus, Ce), this.Neptune = q0(t2, e3, v4.Neptune, De), this.Jupiter.r.decr(t2.r), this.Jupiter.v.decr(t2.v), this.Saturn.r.decr(t2.r), this.Saturn.v.decr(t2.v), this.Uranus.r.decr(t2.r), this.Uranus.v.decr(t2.v), this.Neptune.r.decr(t2.r), this.Neptune.v.decr(t2.v), this.Sun = new o0(e3, t2.r.mul(-1), t2.v.mul(-1));
  }
  Acceleration(e3) {
    let t2 = D0(e3, Be, this.Sun.r);
    return t2.incr(D0(e3, Me, this.Jupiter.r)), t2.incr(D0(e3, ye, this.Saturn.r)), t2.incr(D0(e3, Ce, this.Uranus.r)), t2.incr(D0(e3, De, this.Neptune.r)), t2;
  }
};
var he = class _he {
  constructor(e3, t2, r3, i2) {
    this.tt = e3, this.r = t2, this.v = r3, this.a = i2;
  }
  clone() {
    return new _he(this.tt, this.r.clone(), this.v.clone(), this.a.clone());
  }
};
var Ht = class {
  constructor(e3, t2) {
    this.bary = e3, this.grav = t2;
  }
};
function te(n3, e3, t2, r3) {
  return new I(e3.x + n3 * (t2.x + n3 * r3.x / 2), e3.y + n3 * (t2.y + n3 * r3.y / 2), e3.z + n3 * (t2.z + n3 * r3.z / 2));
}
function it(n3, e3, t2) {
  return new I(e3.x + n3 * t2.x, e3.y + n3 * t2.y, e3.z + n3 * t2.z);
}
function Ue(n3, e3) {
  const t2 = n3 - e3.tt, r3 = new Ve(n3), i2 = te(t2, e3.r, e3.v, e3.a), o2 = r3.Acceleration(i2).mean(e3.a), a2 = te(t2, e3.r, e3.v, o2), c3 = e3.v.add(o2.mul(t2)), s = r3.Acceleration(a2), d2 = new he(n3, a2, c3, s);
  return new Ht(r3, d2);
}
var vr = [];
function Ut(n3, e3) {
  const t2 = Math.floor(n3);
  return t2 < 0 ? 0 : t2 >= e3 ? e3 - 1 : t2;
}
function be(n3) {
  const e3 = Sr(n3), t2 = new Ve(e3.tt), r3 = e3.r.add(t2.Sun.r), i2 = e3.v.add(t2.Sun.v), o2 = t2.Acceleration(r3), a2 = new he(e3.tt, r3, i2, o2);
  return new Ht(t2, a2);
}
function Er(n3, e3) {
  const t2 = e0[0][0];
  if (e3 < t2 || e3 > e0[He - 1][0])
    return null;
  const r3 = Ut((e3 - t2) / Tr, He - 1);
  if (!n3[r3]) {
    const o2 = n3[r3] = [];
    o2[0] = be(e0[r3]).grav, o2[j - 1] = be(e0[r3 + 1]).grav;
    let a2, c3 = o2[0].tt;
    for (a2 = 1; a2 < j - 1; ++a2)
      o2[a2] = Ue(c3 += _0, o2[a2 - 1]).grav;
    c3 = o2[j - 1].tt;
    var i2 = [];
    for (i2[j - 1] = o2[j - 1], a2 = j - 2; a2 > 0; --a2)
      i2[a2] = Ue(c3 -= _0, i2[a2 + 1]).grav;
    for (a2 = j - 2; a2 > 0; --a2) {
      const s = a2 / (j - 1);
      o2[a2].r = o2[a2].r.mul(1 - s).add(i2[a2].r.mul(s)), o2[a2].v = o2[a2].v.mul(1 - s).add(i2[a2].v.mul(s)), o2[a2].a = o2[a2].a.mul(1 - s).add(i2[a2].a.mul(s));
    }
  }
  return n3[r3];
}
function at(n3, e3, t2) {
  let r3 = be(n3);
  const i2 = Math.ceil((e3 - r3.grav.tt) / t2);
  for (let o2 = 0; o2 < i2; ++o2)
    r3 = Ue(o2 + 1 === i2 ? e3 : r3.grav.tt + t2, r3.grav);
  return r3;
}
function _r(n3, e3) {
  let t2, r3, i2;
  const o2 = Er(vr, n3.tt);
  if (o2) {
    const a2 = Ut((n3.tt - o2[0].tt) / _0, j - 1), c3 = o2[a2], s = o2[a2 + 1], d2 = c3.a.mean(s.a), h2 = te(n3.tt - c3.tt, c3.r, c3.v, d2), m3 = it(n3.tt - c3.tt, c3.v, d2), f2 = te(n3.tt - s.tt, s.r, s.v, d2), T2 = it(n3.tt - s.tt, s.v, d2), p3 = (n3.tt - c3.tt) / _0;
    t2 = h2.mul(1 - p3).add(f2.mul(p3)), r3 = m3.mul(1 - p3).add(T2.mul(p3));
  } else {
    let a2;
    n3.tt < e0[0][0] ? a2 = at(e0[0], n3.tt, -_0) : a2 = at(e0[He - 1], n3.tt, +_0), t2 = a2.grav.r, r3 = a2.grav.v, i2 = a2.bary;
  }
  return i2 || (i2 = new Ve(n3.tt)), t2 = t2.sub(i2.Sun.r), r3 = r3.sub(i2.Sun.v), new mr(t2.x, t2.y, t2.z, r3.x, r3.y, r3.z, n3);
}
function N0(n3, e3) {
  var t2 = d0(e3);
  if (n3 in E0)
    return Q0(E0[n3], t2);
  if (n3 === v4.Pluto) {
    const a2 = _r(t2);
    return new b2(a2.x, a2.y, a2.z, t2);
  }
  if (n3 === v4.Sun)
    return new b2(0, 0, 0, t2);
  if (n3 === v4.Moon) {
    var r3 = Q0(E0.Earth, t2), i2 = Ie(t2);
    return new b2(r3.x + i2.x, r3.y + i2.y, r3.z + i2.z, t2);
  }
  if (n3 === v4.EMB) {
    const a2 = Q0(E0.Earth, t2), c3 = Ie(t2), s = 1 + Zn;
    return new b2(a2.x + c3.x / s, a2.y + c3.y / s, a2.z + c3.z / s, t2);
  }
  if (n3 === v4.SSB)
    return pr(t2);
  const o2 = It(n3);
  if (o2) {
    const a2 = new fr(o2.dec, 15 * o2.ra, o2.dist);
    return Cr(a2, t2);
  }
  throw `HelioVector: Unknown body "${n3}"`;
}
function Rr(n3, e3) {
  let t2 = e3, r3 = 0;
  for (let i2 = 0; i2 < 10; ++i2) {
    const o2 = n3(t2), a2 = o2.Length() / jn;
    if (a2 > 1)
      throw "Object is too distant for light-travel solver.";
    const c3 = e3.AddDays(-a2);
    if (r3 = Math.abs(c3.tt - t2.tt), r3 < 1e-9)
      return o2;
    t2 = c3;
  }
  throw `Light-travel time solver did not converge: dt = ${r3}`;
}
var xr = class {
  constructor(e3, t2, r3, i2) {
    this.observerBody = e3, this.targetBody = t2, this.aberration = r3, this.observerPos = i2;
  }
  Position(e3) {
    this.aberration && (this.observerPos = N0(this.observerBody, e3));
    const t2 = N0(this.targetBody, e3);
    return new b2(t2.x - this.observerPos.x, t2.y - this.observerPos.y, t2.z - this.observerPos.z, e3);
  }
};
function Ar(n3, e3, t2, r3) {
  const i2 = d0(n3);
  if (It(t2)) {
    const c3 = N0(t2, i2), s = N0(e3, i2);
    return new b2(c3.x - s.x, c3.y - s.y, c3.z - s.z, i2);
  }
  let o2;
  o2 = N0(e3, i2);
  const a2 = new xr(e3, t2, r3, o2);
  return Rr((c3) => a2.Position(c3), i2);
}
function wr(n3, e3, t2) {
  const r3 = d0(e3);
  switch (n3) {
    case v4.Earth:
      return new b2(0, 0, 0, r3);
    case v4.Moon:
      return Ie(r3);
    default:
      const i2 = Ar(r3, v4.Earth, n3, t2);
      return i2.t = r3, i2;
  }
}
var ot;
(function(n3) {
  n3[n3.Pericenter = 0] = "Pericenter", n3[n3.Apocenter = 1] = "Apocenter";
})(ot || (ot = {}));
function Mr(n3, e3) {
  return new w0([
    [
      e3.rot[0][0] * n3.rot[0][0] + e3.rot[1][0] * n3.rot[0][1] + e3.rot[2][0] * n3.rot[0][2],
      e3.rot[0][1] * n3.rot[0][0] + e3.rot[1][1] * n3.rot[0][1] + e3.rot[2][1] * n3.rot[0][2],
      e3.rot[0][2] * n3.rot[0][0] + e3.rot[1][2] * n3.rot[0][1] + e3.rot[2][2] * n3.rot[0][2]
    ],
    [
      e3.rot[0][0] * n3.rot[1][0] + e3.rot[1][0] * n3.rot[1][1] + e3.rot[2][0] * n3.rot[1][2],
      e3.rot[0][1] * n3.rot[1][0] + e3.rot[1][1] * n3.rot[1][1] + e3.rot[2][1] * n3.rot[1][2],
      e3.rot[0][2] * n3.rot[1][0] + e3.rot[1][2] * n3.rot[1][1] + e3.rot[2][2] * n3.rot[1][2]
    ],
    [
      e3.rot[0][0] * n3.rot[2][0] + e3.rot[1][0] * n3.rot[2][1] + e3.rot[2][0] * n3.rot[2][2],
      e3.rot[0][1] * n3.rot[2][0] + e3.rot[1][1] * n3.rot[2][1] + e3.rot[2][1] * n3.rot[2][2],
      e3.rot[0][2] * n3.rot[2][0] + e3.rot[1][2] * n3.rot[2][1] + e3.rot[2][2] * n3.rot[2][2]
    ]
  ]);
}
function yr(n3, e3, t2) {
  const r3 = J0(t2) * a0, i2 = Math.cos(r3), o2 = Math.sin(r3), a2 = (e3 + 1) % 3, c3 = (e3 + 2) % 3, s = e3;
  let d2 = [[0, 0, 0], [0, 0, 0], [0, 0, 0]];
  return d2[a2][a2] = i2 * n3.rot[a2][a2] - o2 * n3.rot[a2][c3], d2[a2][c3] = o2 * n3.rot[a2][a2] + i2 * n3.rot[a2][c3], d2[a2][s] = n3.rot[a2][s], d2[c3][a2] = i2 * n3.rot[c3][a2] - o2 * n3.rot[c3][c3], d2[c3][c3] = o2 * n3.rot[c3][a2] + i2 * n3.rot[c3][c3], d2[c3][s] = n3.rot[c3][s], d2[s][a2] = i2 * n3.rot[s][a2] - o2 * n3.rot[s][c3], d2[s][c3] = o2 * n3.rot[s][a2] + i2 * n3.rot[s][c3], d2[s][s] = n3.rot[s][s], new w0(d2);
}
function Cr(n3, e3) {
  e3 = d0(e3);
  const t2 = n3.lat * a0, r3 = n3.lon * a0, i2 = n3.dist * Math.cos(t2);
  return new b2(i2 * Math.cos(r3), i2 * Math.sin(r3), n3.dist * Math.sin(t2), e3);
}
function Dr(n3) {
  n3 = d0(n3);
  const e3 = Ot(n3, K.From2000), t2 = hr(n3, K.From2000);
  return Mr(e3, t2);
}
var st;
(function(n3) {
  n3.Penumbral = "penumbral", n3.Partial = "partial", n3.Annular = "annular", n3.Total = "total";
})(st || (st = {}));
var ct;
(function(n3) {
  n3[n3.Invalid = 0] = "Invalid", n3[n3.Ascending = 1] = "Ascending", n3[n3.Descending = -1] = "Descending";
})(ct || (ct = {}));
var Ir = 1e-3 / Dt;
var Pr = new Vector3();
var Nr = new Matrix4();
var ut = new Matrix4();
function L0(n3) {
  return n3 instanceof Z ? n3 : new Z(n3 instanceof Date ? n3 : new Date(n3));
}
function bt(n3, e3 = new Matrix4()) {
  const t2 = L0(n3), { rot: r3 } = yr(Dr(t2), 2, -15 * dr(t2));
  return e3.set(
    r3[0][0],
    r3[1][0],
    r3[2][0],
    0,
    r3[0][1],
    r3[1][1],
    r3[2][1],
    0,
    r3[0][2],
    r3[1][2],
    r3[2][2],
    0,
    0,
    0,
    0,
    1
  );
}
function We(n3, e3, t2, r3, i2) {
  const { x: o2, y: a2, z: c3 } = wr(n3, e3, false);
  if (t2.set(o2, a2, c3), r3 != null) {
    const s = i2 != null ? (
      // matrixScratch1 can be in use by getDirectionECEF()
      ut.copy(i2).transpose()
    ) : bt(e3, ut).transpose();
    t2.sub(
      Pr.copy(r3).applyMatrix4(s).multiplyScalar(Ir)
    );
  }
  return t2.normalize();
}
function Gt(n3, e3, t2, r3) {
  const i2 = bt(e3, Nr);
  return We(n3, e3, t2, r3, i2), t2.applyMatrix4(i2);
}
function Ii(n3, e3 = new Vector3(), t2) {
  return We(v4.Sun, L0(n3), e3, t2);
}
function Pi(n3, e3 = new Vector3(), t2) {
  return We(v4.Moon, L0(n3), e3, t2);
}
function Ni(n3, e3 = new Vector3(), t2) {
  return Gt(v4.Sun, L0(n3), e3, t2);
}
function Oi(n3, e3 = new Vector3(), t2) {
  return Gt(v4.Moon, L0(n3), e3, t2);
}
function Ft(n3) {
  return Math.sqrt(Math.max(n3, 0));
}
function Or(n3) {
  return Math.max(n3, 0);
}
function Lr(n3, e3, t2) {
  const { bottomRadius: r3 } = n3;
  return t2 < 0 && e3 ** 2 * (t2 ** 2 - 1) + r3 ** 2 >= 0;
}
function Hr(n3, e3, t2) {
  const { topRadius: r3 } = n3, i2 = e3 ** 2 * (t2 ** 2 - 1) + r3 ** 2;
  return Or(-e3 * t2 + Ft(i2));
}
function ne(n3, e3) {
  return 0.5 / e3 + n3 * (1 - 1 / e3);
}
var Ur = new Vector3();
var lt = new Vector3();
var br = new Vector3();
var dt = /* @__PURE__ */ new WeakMap();
function Gr(n3) {
  let e3 = wo(n3.image.data) ? n3.image.data : wo(n3.userData.imageData) ? n3.userData.imageData : void 0;
  if (n3.type === HalfFloatType && e3 instanceof Uint16Array) {
    const t2 = dt.get(e3.buffer);
    t2 == null ? (e3 = new L(e3.buffer), dt.set(e3.buffer, e3)) : e3 = t2;
  }
  return e3;
}
function Z0(n3, e3, t2) {
  const r3 = e3 * 4;
  return t2.set(n3[r3], n3[r3 + 1], n3[r3 + 2]);
}
function zt(n3, e3, t2) {
  const r3 = Gr(n3);
  if (r3 == null)
    return t2.setScalar(0);
  const { width: i2, height: o2 } = n3.image, a2 = $e(e3.x, 0, 1) * (i2 - 1), c3 = $e(e3.y, 0, 1) * (o2 - 1), s = Math.floor(a2), d2 = Math.floor(c3), h2 = a2 - s, m3 = c3 - d2, f2 = h2, T2 = m3, p3 = s % i2, E = (p3 + 1) % i2, R = d2 % o2, D2 = (R + 1) % o2, P2 = Z0(r3, R * i2 + p3, Ur), N = Z0(r3, R * i2 + E, lt), H = P2.lerp(N, f2), G = Z0(r3, D2 * i2 + p3, lt), B = Z0(r3, D2 * i2 + E, br), F = G.lerp(B, f2);
  return t2.copy(H.lerp(F, T2));
}
function Fr(n3, e3, t2, r3) {
  const { topRadius: i2, bottomRadius: o2 } = n3, a2 = Math.sqrt(i2 ** 2 - o2 ** 2), c3 = Ft(e3 ** 2 - o2 ** 2), s = Hr(n3, e3, t2), d2 = i2 - e3, h2 = c3 + a2, m3 = (s - d2) / (h2 - d2), f2 = c3 / a2;
  return r3.set(
    ne(m3, u0),
    ne(f2, l0)
  );
}
var zr = new Vector3();
var Re = new Vector3();
var kr = new Vector2();
function Br(n3, e3, t2, r3 = new Color(), {
  ellipsoid: i2 = b.WGS84,
  correctAltitude: o2 = true
} = {}, a2 = J.DEFAULT) {
  const c3 = zr.copy(e3);
  if (o2) {
    const p3 = i2.projectOnSurface(
      e3,
      Re
    );
    p3 != null && c3.sub(
      i2.getOsculatingSphereCenter(
        p3,
        a2.bottomRadius,
        Re
      )
    );
  }
  const s = Re;
  let d2 = c3.length(), h2 = c3.dot(t2);
  const { topRadius: m3 } = a2, f2 = -h2 - Math.sqrt(h2 ** 2 - d2 ** 2 + m3 ** 2);
  if (f2 > 0 && (d2 = m3, h2 += f2), d2 > m3)
    s.set(1, 1, 1);
  else {
    const p3 = h2 / d2;
    if (Lr(a2, d2, p3))
      s.setScalar(0);
    else {
      const R = Fr(a2, d2, p3, kr);
      zt(n3, R, s);
    }
  }
  const T2 = s.multiply(a2.solarIrradiance).multiply(a2.sunRadianceToRelativeLuminance);
  return r3.setFromVector3(T2);
}
var Vr = `// Based on: https://github.com/pmndrs/postprocessing/blob/v6.37.4/src/materials/glsl/depth-mask.frag

#include <common>
#include <packing>

#include "core/depth"

#ifdef GL_FRAGMENT_PRECISION_HIGH
uniform highp sampler2D depthBuffer0;
uniform highp sampler2D depthBuffer1;
#else // GL_FRAGMENT_PRECISION_HIGH
uniform mediump sampler2D depthBuffer0;
uniform mediump sampler2D depthBuffer1;
#endif // GL_FRAGMENT_PRECISION_HIGH

uniform sampler2D inputBuffer;
uniform vec2 cameraNearFar;
uniform bool inverted;

float getViewZ(const float depth) {
  #ifdef PERSPECTIVE_CAMERA
  return perspectiveDepthToViewZ(depth, cameraNearFar.x, cameraNearFar.y);
  #else // PERSPECTIVE_CAMERA
  return orthographicDepthToViewZ(depth, cameraNearFar.x, cameraNearFar.y);
  #endif // PERSPECTIVE_CAMERA
}

varying vec2 vUv;

void main() {
  vec2 depth;

  #if DEPTH_PACKING_0 == 3201
  depth.x = unpackRGBAToDepth(texture2D(depthBuffer0, vUv));
  #else // DEPTH_PACKING_0 == 3201
  depth.x = reverseLogDepth(texture2D(depthBuffer0, vUv).r, cameraNearFar.x, cameraNearFar.y);
  #endif // DEPTH_PACKING_0 == 3201

  #if DEPTH_PACKING_1 == 3201
  depth.y = unpackRGBAToDepth(texture2D(depthBuffer1, vUv));
  #else // DEPTH_PACKING_1 == 3201
  depth.y = reverseLogDepth(texture2D(depthBuffer1, vUv).r, cameraNearFar.x, cameraNearFar.y);
  #endif // DEPTH_PACKING_1 == 3201

  bool isMaxDepth = depth.x == 1.0;

  #ifdef PERSPECTIVE_CAMERA
  depth.x = viewZToOrthographicDepth(getViewZ(depth.x), cameraNearFar.x, cameraNearFar.y);
  depth.y = viewZToOrthographicDepth(getViewZ(depth.y), cameraNearFar.x, cameraNearFar.y);
  #endif // PERSPECTIVE_CAMERA

  #if DEPTH_TEST_STRATEGY == 0
  // Decide based on depth test.
  bool keep = depthTest(depth.x, depth.y);

  #elif DEPTH_TEST_STRATEGY == 1
  // Always keep max depth.
  bool keep = isMaxDepth || depthTest(depth.x, depth.y);

  #else // DEPTH_TEST_STRATEGY
  // Always discard max depth.
  bool keep = !isMaxDepth && depthTest(depth.x, depth.y);

  #endif // DEPTH_TEST_STRATEGY

  if (inverted) {
    keep = !keep;
  }
  if (keep) {
    gl_FragColor = texture2D(inputBuffer, vUv);
  } else {
    discard;
  }
}
`;
var Wr = class extends Pass {
  constructor(e3, t2) {
    super("LightingMaskPass"), this.selection = new Selection(), this.needsSwap = false, this.needsDepthTexture = true, this.renderPass = new RenderPass(e3, t2, new MeshBasicMaterial()), this.renderPass.ignoreBackground = true, this.renderPass.skipShadowMapUpdate = true, this.renderPass.selection = this.selection, this.depthTexture = new DepthTexture(1, 1, UnsignedIntType), this.renderTarget = new WebGLRenderTarget(1, 1, {
      format: RedFormat,
      depthTexture: this.depthTexture
    }), this.depthCopyPass0 = new DepthCopyPass({ depthPacking: RGBADepthPacking }), this.depthCopyPass1 = new DepthCopyPass({ depthPacking: RGBADepthPacking }), this.clearPass = new ClearPass(true, false, false), this.clearPass.overrideClearColor = new Color(16777215), this.clearPass.overrideClearAlpha = 1;
    const r3 = new DepthMaskMaterial();
    r3.fragmentShader = io(Vr, {
      core: { depth: d }
    }), r3.uniforms.inverted = new Uniform(false), r3.copyCameraSettings(t2), r3.depthBuffer0 = this.depthCopyPass0.texture, r3.depthPacking0 = RGBADepthPacking, r3.depthBuffer1 = this.depthCopyPass1.texture, r3.depthPacking1 = RGBADepthPacking, r3.depthMode = LessEqualDepth, r3.maxDepthStrategy = DepthTestStrategy.DISCARD_MAX_DEPTH, this.depthMaskMaterial = r3, this.depthMaskPass = new ShaderPass(r3);
  }
  // eslint-disable-next-line accessor-pairs
  set mainScene(e3) {
    this.renderPass.mainScene = e3;
  }
  // eslint-disable-next-line accessor-pairs
  set mainCamera(e3) {
    this.renderPass.mainCamera = e3, this.depthMaskMaterial.copyCameraSettings(e3);
  }
  initialize(e3, t2, r3) {
    this.renderPass.initialize(e3, t2, r3), this.clearPass.initialize(e3, t2, r3), this.depthMaskPass.initialize(e3, t2, r3);
  }
  setDepthTexture(e3, t2 = BasicDepthPacking) {
    this.depthCopyPass0.setDepthTexture(e3, t2), this.depthCopyPass1.setDepthTexture(this.depthTexture, t2);
  }
  render(e3, t2, r3, i2, o2) {
    const a2 = e3.autoClear;
    e3.autoClear = false, this.depthCopyPass0.render(e3, null, null), this.renderPass.render(e3, this.renderTarget, null), this.depthCopyPass1.render(e3, null, null), this.clearPass.render(e3, this.renderTarget, null), this.depthMaskPass.render(e3, null, this.renderTarget), e3.autoClear = a2;
  }
  setSize(e3, t2) {
    this.renderTarget.setSize(e3, t2), this.depthCopyPass0.setSize(e3, t2), this.depthCopyPass1.setSize(e3, t2);
  }
  get texture() {
    return this.renderTarget.texture;
  }
  get selectionLayer() {
    return this.selection.layer;
  }
  set selectionLayer(e3) {
    this.selection.layer = e3;
  }
  get inverted() {
    return this.depthMaskMaterial.uniforms.inverted.value;
  }
  set inverted(e3) {
    this.depthMaskMaterial.uniforms.inverted.value = e3;
  }
};
var Li = Wr;
var jr = true;
var ht = "Invariant failed";
function Xr(n3, e3) {
  if (!n3) {
    if (jr)
      throw new Error(ht);
    var t2 = ht;
    throw new Error(t2);
  }
}
var mt = window.requestIdleCallback ?? function(e3, t2 = {}) {
  const i2 = t2.timeout ?? 1, o2 = performance.now();
  return setTimeout(function() {
    e3({
      get didTimeout() {
        return t2.timeout != null ? false : performance.now() - o2 - 1 > i2;
      },
      timeRemaining: function() {
        return Math.max(0, 1 + (performance.now() - o2));
      }
    });
  }, 1);
};
var Yr = `precision highp float;
precision highp sampler3D;

#include "bruneton/definitions"
#include "bruneton/common"
#include "bruneton/precompute"

uniform AtmosphereParameters ATMOSPHERE;

uniform sampler2D transmittanceTexture;

layout(location = 0) out vec4 outputColor;

void main() {
  vec3 deltaIrradiance;
  vec3 irradiance;
  deltaIrradiance = ComputeDirectIrradianceTexture(
    ATMOSPHERE,
    transmittanceTexture,
    gl_FragCoord.xy
  );
  irradiance = vec3(0.0);
  outputColor = vec4(OUTPUT, 1.0);
}
`;
var Kr = `precision highp float;
precision highp sampler3D;

#include "bruneton/definitions"
#include "bruneton/common"
#include "bruneton/precompute"

uniform AtmosphereParameters ATMOSPHERE;

uniform mat3 luminanceFromRadiance;
uniform sampler3D singleRayleighScatteringTexture;
uniform sampler3D singleMieScatteringTexture;
uniform sampler3D multipleScatteringTexture;
uniform int scatteringOrder;

layout(location = 0) out vec4 outputColor;

void main() {
  vec3 deltaIrradiance;
  vec3 irradiance;
  deltaIrradiance = ComputeIndirectIrradianceTexture(
    ATMOSPHERE,
    singleRayleighScatteringTexture,
    singleMieScatteringTexture,
    multipleScatteringTexture,
    gl_FragCoord.xy,
    scatteringOrder
  );
  irradiance = luminanceFromRadiance * deltaIrradiance;
  outputColor = vec4(OUTPUT, 1.0);
}
`;
var $r = `precision highp float;
precision highp sampler3D;

#include "bruneton/definitions"
#include "bruneton/common"
#include "bruneton/precompute"

uniform AtmosphereParameters ATMOSPHERE;

uniform mat3 luminanceFromRadiance;
uniform sampler2D transmittanceTexture;
uniform sampler3D scatteringDensityTexture;
uniform int layer;

layout(location = 0) out vec4 outputColor;

void main() {
  vec4 deltaMultipleScattering;
  vec4 scattering;
  float nu;
  deltaMultipleScattering.rgb = ComputeMultipleScatteringTexture(
    ATMOSPHERE,
    transmittanceTexture,
    scatteringDensityTexture,
    vec3(gl_FragCoord.xy, float(layer) + 0.5),
    nu
  );
  deltaMultipleScattering.a = 1.0;
  scattering = vec4(
    luminanceFromRadiance * deltaMultipleScattering.rgb / RayleighPhaseFunction(nu),
    0.0
  );
  outputColor = OUTPUT;
}
`;
var qr = `precision highp float;
precision highp sampler3D;

#include "bruneton/definitions"
#include "bruneton/common"
#include "bruneton/precompute"

uniform AtmosphereParameters ATMOSPHERE;

uniform sampler2D transmittanceTexture;
uniform sampler3D singleRayleighScatteringTexture;
uniform sampler3D singleMieScatteringTexture;
uniform sampler3D multipleScatteringTexture;
uniform sampler2D irradianceTexture;
uniform int scatteringOrder;
uniform int layer;

layout(location = 0) out vec4 scatteringDensity;

void main() {
  scatteringDensity.rgb = ComputeScatteringDensityTexture(
    ATMOSPHERE,
    transmittanceTexture,
    singleRayleighScatteringTexture,
    singleMieScatteringTexture,
    multipleScatteringTexture,
    irradianceTexture,
    vec3(gl_FragCoord.xy, float(layer) + 0.5),
    scatteringOrder
  );
  scatteringDensity.a = 1.0;
}
`;
var Zr = `precision highp float;
precision highp sampler3D;

#include "bruneton/definitions"
#include "bruneton/common"
#include "bruneton/precompute"

uniform AtmosphereParameters ATMOSPHERE;

uniform mat3 luminanceFromRadiance;
uniform sampler2D transmittanceTexture;
uniform int layer;

layout(location = 0) out vec4 outputColor;

void main() {
  vec4 deltaRayleigh;
  vec4 deltaMie;
  vec4 scattering;
  vec4 singleMieScattering;
  ComputeSingleScatteringTexture(
    ATMOSPHERE,
    transmittanceTexture,
    vec3(gl_FragCoord.xy, float(layer) + 0.5),
    deltaRayleigh.rgb,
    deltaMie.rgb
  );
  deltaRayleigh.a = 1.0;
  deltaMie.a = 1.0;
  scattering = vec4(
    luminanceFromRadiance * deltaRayleigh.rgb,
    (luminanceFromRadiance * deltaMie.rgb).r
  );
  singleMieScattering.rgb = luminanceFromRadiance * deltaMie.rgb;
  singleMieScattering.a = 1.0;
  outputColor = OUTPUT;
}
`;
var Jr = `precision highp float;
precision highp sampler3D;

#include "bruneton/definitions"
#include "bruneton/common"
#include "bruneton/precompute"

uniform AtmosphereParameters ATMOSPHERE;

layout(location = 0) out vec4 transmittance;

void main() {
  transmittance.rgb = ComputeTransmittanceToTopAtmosphereBoundaryTexture(
    ATMOSPHERE,
    gl_FragCoord.xy
  );
  transmittance.a = 1.0;
}
`;
var Qr = (
  /* glsl */
  `
  precision highp float;
  in vec2 position;
  void main() {
    gl_Position = vec4(position, 1.0, 1.0);
  }
`
);
function re(n3, e3, t2) {
  const r3 = new WebGLRenderTarget(e3, t2, {
    depthBuffer: false,
    type: n3,
    format: RGBAFormat
  }), i2 = r3.texture;
  return i2.minFilter = LinearFilter, i2.magFilter = LinearFilter, i2.wrapS = ClampToEdgeWrapping, i2.wrapT = ClampToEdgeWrapping, i2.colorSpace = NoColorSpace, r3;
}
function x0(n3, e3, t2, r3) {
  const i2 = new WebGL3DRenderTarget(e3, t2, r3, {
    depthBuffer: false,
    type: n3,
    format: RGBAFormat
  }), o2 = i2.texture;
  return o2.minFilter = LinearFilter, o2.magFilter = LinearFilter, o2.wrapS = ClampToEdgeWrapping, o2.wrapT = ClampToEdgeWrapping, o2.wrapR = ClampToEdgeWrapping, o2.colorSpace = NoColorSpace, i2;
}
function ei(n3) {
  const e3 = n3[Symbol.iterator]();
  return new Promise((t2, r3) => {
    const i2 = () => {
      try {
        const { value: o2, done: a2 } = e3.next();
        a2 === true ? t2(o2) : mt(i2);
      } catch (o2) {
        r3(o2 instanceof Error ? o2 : new Error());
      }
    };
    mt(i2);
  });
}
async function ft(n3, e3, t2) {
  const { width: r3, height: i2 } = e3, o2 = t2.type === HalfFloatType ? new Uint16Array(r3 * i2 * 4) : new Float32Array(r3 * i2 * 4);
  await n3.readRenderTargetPixelsAsync(
    e3,
    0,
    0,
    e3.width,
    e3.height,
    o2
  ), t2.userData.imageData = o2;
}
var ti = class {
  constructor(e3) {
    this.lambdas = new Vector3(), this.luminanceFromRadiance = new Matrix3(), e3 === HalfFloatType && (this.opticalDepth = re(
      e3,
      u0,
      l0
    )), this.deltaIrradiance = re(
      e3,
      s0,
      c0
    ), this.deltaRayleighScattering = x0(
      e3,
      n0,
      r0,
      i0
    ), this.deltaMieScattering = x0(
      e3,
      n0,
      r0,
      i0
    ), this.deltaScatteringDensity = x0(
      e3,
      n0,
      r0,
      i0
    ), this.deltaMultipleScattering = this.deltaRayleighScattering;
  }
  dispose() {
    var e3;
    (e3 = this.opticalDepth) == null || e3.dispose(), this.deltaIrradiance.dispose(), this.deltaRayleighScattering.dispose(), this.deltaMieScattering.dispose(), this.deltaScatteringDensity.dispose();
  }
};
var T0 = class extends RawShaderMaterial {
  constructor(e3) {
    super({
      glslVersion: GLSL3,
      vertexShader: Qr,
      ...e3,
      defines: {
        TRANSMITTANCE_TEXTURE_WIDTH: u0.toFixed(0),
        TRANSMITTANCE_TEXTURE_HEIGHT: l0.toFixed(0),
        SCATTERING_TEXTURE_R_SIZE: se.toFixed(0),
        SCATTERING_TEXTURE_MU_SIZE: ce.toFixed(0),
        SCATTERING_TEXTURE_MU_S_SIZE: ue.toFixed(0),
        SCATTERING_TEXTURE_NU_SIZE: le.toFixed(0),
        IRRADIANCE_TEXTURE_WIDTH: s0.toFixed(0),
        IRRADIANCE_TEXTURE_HEIGHT: c0.toFixed(0),
        ...e3.defines
      }
    });
  }
  // eslint-disable-next-line accessor-pairs
  set additive(e3) {
    this.transparent = e3, this.blending = e3 ? CustomBlending : NoBlending, this.blendEquation = AddEquation, this.blendEquationAlpha = AddEquation, this.blendSrc = OneFactor, this.blendDst = OneFactor, this.blendSrcAlpha = OneFactor, this.blendDstAlpha = OneFactor;
  }
  setUniforms(e3) {
    const t2 = this.uniforms;
    t2.luminanceFromRadiance != null && t2.luminanceFromRadiance.value.copy(e3.luminanceFromRadiance), t2.singleRayleighScatteringTexture != null && (t2.singleRayleighScatteringTexture.value = e3.deltaRayleighScattering.texture), t2.singleMieScatteringTexture != null && (t2.singleMieScatteringTexture.value = e3.deltaMieScattering.texture), t2.multipleScatteringTexture != null && (t2.multipleScatteringTexture.value = e3.deltaMultipleScattering.texture), t2.scatteringDensityTexture != null && (t2.scatteringDensityTexture.value = e3.deltaScatteringDensity.texture), t2.irradianceTexture != null && (t2.irradianceTexture.value = e3.deltaIrradiance.texture);
  }
};
var Hi = class {
  constructor(e3, {
    type: t2 = yo(e3) ? FloatType : HalfFloatType,
    combinedScattering: r3 = true,
    higherOrderScattering: i2 = true
  } = {}) {
    var o2, a2;
    this.transmittanceMaterial = new T0({
      fragmentShader: io(Jr, {
        bruneton: {
          common: e2,
          definitions: t,
          precompute: r2
        }
      })
    }), this.directIrradianceMaterial = new T0({
      fragmentShader: io(Yr, {
        bruneton: {
          common: e2,
          definitions: t,
          precompute: r2
        }
      }),
      uniforms: {
        transmittanceTexture: new Uniform(null)
      }
    }), this.singleScatteringMaterial = new T0({
      fragmentShader: io(Zr, {
        bruneton: {
          common: e2,
          definitions: t,
          precompute: r2
        }
      }),
      uniforms: {
        luminanceFromRadiance: new Uniform(new Matrix3()),
        transmittanceTexture: new Uniform(null),
        layer: new Uniform(0)
      }
    }), this.scatteringDensityMaterial = new T0({
      fragmentShader: io(qr, {
        bruneton: {
          common: e2,
          definitions: t,
          precompute: r2
        }
      }),
      uniforms: {
        transmittanceTexture: new Uniform(null),
        singleRayleighScatteringTexture: new Uniform(null),
        singleMieScatteringTexture: new Uniform(null),
        multipleScatteringTexture: new Uniform(null),
        irradianceTexture: new Uniform(null),
        scatteringOrder: new Uniform(0),
        layer: new Uniform(0)
      }
    }), this.indirectIrradianceMaterial = new T0({
      fragmentShader: io(Kr, {
        bruneton: {
          common: e2,
          definitions: t,
          precompute: r2
        }
      }),
      uniforms: {
        luminanceFromRadiance: new Uniform(new Matrix3()),
        singleRayleighScatteringTexture: new Uniform(null),
        singleMieScatteringTexture: new Uniform(null),
        multipleScatteringTexture: new Uniform(null),
        scatteringOrder: new Uniform(0)
      }
    }), this.multipleScatteringMaterial = new T0({
      fragmentShader: io($r, {
        bruneton: {
          common: e2,
          definitions: t,
          precompute: r2
        }
      }),
      uniforms: {
        luminanceFromRadiance: new Uniform(new Matrix3()),
        transmittanceTexture: new Uniform(null),
        scatteringDensityTexture: new Uniform(null),
        layer: new Uniform(0)
      }
    }), this.mesh = new Mesh(new PlaneGeometry(2, 2)), this.scene = new Scene().add(this.mesh), this.camera = new Camera(), this.updating = false, this.renderer = e3, this.type = t2, this.transmittanceRenderTarget = re(
      t2,
      u0,
      l0
    ), this.scatteringRenderTarget = x0(
      t2,
      n0,
      r0,
      i0
    ), this.irradianceRenderTarget = re(
      t2,
      s0,
      c0
    ), r3 || (this.singleMieScatteringRenderTarget = x0(
      t2,
      n0,
      r0,
      i0
    )), i2 && (this.higherOrderScatteringRenderTarget = x0(
      t2,
      n0,
      r0,
      i0
    )), this.textures = {
      transmittanceTexture: this.transmittanceRenderTarget.texture,
      scatteringTexture: this.scatteringRenderTarget.texture,
      irradianceTexture: this.irradianceRenderTarget.texture,
      singleMieScatteringTexture: (o2 = this.singleMieScatteringRenderTarget) == null ? void 0 : o2.texture,
      higherOrderScatteringTexture: (a2 = this.higherOrderScatteringRenderTarget) == null ? void 0 : a2.texture
    };
  }
  render3DRenderTarget(e3, t2) {
    for (let r3 = 0; r3 < e3.depth; ++r3)
      t2.uniforms.layer.value = r3, this.renderer.setRenderTarget(e3, r3), this.renderer.render(this.scene, this.camera);
  }
  computeTransmittance(e3) {
    const t2 = this.transmittanceMaterial;
    delete t2.defines.TRANSMITTANCE_PRECISION_LOG, t2.needsUpdate = true, this.mesh.material = t2, this.renderer.setRenderTarget(e3.renderTarget), this.renderer.render(this.scene, this.camera);
  }
  computeOpticalDepth(e3) {
    const t2 = this.transmittanceMaterial;
    t2.defines.TRANSMITTANCE_PRECISION_LOG = "1", t2.needsUpdate = true, this.mesh.material = t2, this.renderer.setRenderTarget(e3.renderTarget), this.renderer.render(this.scene, this.camera);
  }
  computeDirectIrradiance(e3) {
    var i2;
    const t2 = this.directIrradianceMaterial;
    t2.defines.OUTPUT = e3.output, t2.additive = e3.additive, this.type === HalfFloatType ? t2.defines.TRANSMITTANCE_PRECISION_LOG = "1" : delete t2.defines.TRANSMITTANCE_PRECISION_LOG, t2.needsUpdate = true;
    const r3 = t2.uniforms;
    r3.transmittanceTexture.value = ((i2 = e3.context.opticalDepth) == null ? void 0 : i2.texture) ?? this.transmittanceRenderTarget.texture, this.mesh.material = t2, this.renderer.setRenderTarget(e3.renderTarget), this.renderer.render(this.scene, this.camera);
  }
  computeSingleScattering(e3) {
    var i2;
    const t2 = this.singleScatteringMaterial;
    t2.defines.OUTPUT = e3.output, t2.additive = e3.additive, this.type === HalfFloatType ? t2.defines.TRANSMITTANCE_PRECISION_LOG = "1" : delete t2.defines.TRANSMITTANCE_PRECISION_LOG, t2.needsUpdate = true;
    const r3 = t2.uniforms;
    r3.transmittanceTexture.value = ((i2 = e3.context.opticalDepth) == null ? void 0 : i2.texture) ?? this.transmittanceRenderTarget.texture, t2.setUniforms(e3.context), this.mesh.material = t2, this.render3DRenderTarget(e3.renderTarget, t2);
  }
  computeScatteringDensity(e3) {
    var i2;
    const t2 = this.scatteringDensityMaterial;
    this.type === HalfFloatType ? t2.defines.TRANSMITTANCE_PRECISION_LOG = "1" : delete t2.defines.TRANSMITTANCE_PRECISION_LOG, t2.needsUpdate = true;
    const r3 = t2.uniforms;
    r3.transmittanceTexture.value = ((i2 = e3.context.opticalDepth) == null ? void 0 : i2.texture) ?? this.transmittanceRenderTarget.texture, r3.scatteringOrder.value = e3.scatteringOrder, t2.setUniforms(e3.context), this.mesh.material = t2, this.render3DRenderTarget(e3.renderTarget, t2);
  }
  computeIndirectIrradiance(e3) {
    const t2 = this.indirectIrradianceMaterial;
    t2.defines.OUTPUT = e3.output, t2.additive = e3.additive, t2.needsUpdate = true;
    const r3 = t2.uniforms;
    r3.scatteringOrder.value = e3.scatteringOrder - 1, t2.setUniforms(e3.context), this.mesh.material = t2, this.renderer.setRenderTarget(e3.renderTarget), this.renderer.render(this.scene, this.camera);
  }
  computeMultipleScattering(e3) {
    var i2;
    const t2 = this.multipleScatteringMaterial;
    t2.defines.OUTPUT = e3.output, t2.additive = e3.additive, this.type === HalfFloatType ? t2.defines.TRANSMITTANCE_PRECISION_LOG = "1" : delete t2.defines.TRANSMITTANCE_PRECISION_LOG, t2.needsUpdate = true;
    const r3 = t2.uniforms;
    r3.transmittanceTexture.value = ((i2 = e3.context.opticalDepth) == null ? void 0 : i2.texture) ?? this.transmittanceRenderTarget.texture, t2.setUniforms(e3.context), this.mesh.material = t2, this.render3DRenderTarget(e3.renderTarget, t2);
  }
  *precompute(e3, t2) {
    this.computeTransmittance({
      renderTarget: this.transmittanceRenderTarget
    }), this.type === HalfFloatType && (Xr(e3.opticalDepth != null), this.computeOpticalDepth({
      renderTarget: e3.opticalDepth
    })), this.computeDirectIrradiance({
      renderTarget: e3.deltaIrradiance,
      context: e3,
      output: "deltaIrradiance",
      additive: false
    }), this.computeDirectIrradiance({
      renderTarget: this.irradianceRenderTarget,
      context: e3,
      output: "irradiance",
      additive: t2
    }), this.renderer.setRenderTarget(null), yield, this.computeSingleScattering({
      renderTarget: e3.deltaRayleighScattering,
      context: e3,
      output: "deltaRayleigh",
      additive: false
    }), this.computeSingleScattering({
      renderTarget: e3.deltaMieScattering,
      context: e3,
      output: "deltaMie",
      additive: false
    }), this.computeSingleScattering({
      renderTarget: this.scatteringRenderTarget,
      context: e3,
      output: "scattering",
      additive: t2
    }), this.singleMieScatteringRenderTarget != null && this.computeSingleScattering({
      renderTarget: this.singleMieScatteringRenderTarget,
      context: e3,
      output: "singleMieScattering",
      additive: t2
    }), this.renderer.setRenderTarget(null), yield;
    for (let r3 = 2; r3 <= 4; ++r3)
      this.computeScatteringDensity({
        renderTarget: e3.deltaScatteringDensity,
        context: e3,
        scatteringOrder: r3
      }), this.computeIndirectIrradiance({
        renderTarget: e3.deltaIrradiance,
        context: e3,
        scatteringOrder: r3,
        output: "deltaIrradiance",
        additive: false
      }), this.computeIndirectIrradiance({
        renderTarget: this.irradianceRenderTarget,
        context: e3,
        scatteringOrder: r3,
        output: "irradiance",
        additive: true
      }), this.computeMultipleScattering({
        renderTarget: e3.deltaMultipleScattering,
        context: e3,
        output: "deltaMultipleScattering",
        additive: false
      }), this.computeMultipleScattering({
        renderTarget: this.scatteringRenderTarget,
        context: e3,
        output: "scattering",
        additive: true
      }), this.higherOrderScatteringRenderTarget != null && this.computeMultipleScattering({
        renderTarget: this.higherOrderScatteringRenderTarget,
        context: e3,
        output: "scattering",
        additive: true
      }), this.renderer.setRenderTarget(null), yield;
  }
  async update(e3 = J.DEFAULT) {
    var a2;
    this.updating = true;
    const t2 = e3.toUniform();
    this.transmittanceMaterial.uniforms.ATMOSPHERE = t2, this.directIrradianceMaterial.uniforms.ATMOSPHERE = t2, this.singleScatteringMaterial.uniforms.ATMOSPHERE = t2, this.scatteringDensityMaterial.uniforms.ATMOSPHERE = t2, this.indirectIrradianceMaterial.uniforms.ATMOSPHERE = t2, this.multipleScatteringMaterial.uniforms.ATMOSPHERE = t2;
    const r3 = this.renderer, i2 = new ti(this.type);
    i2.lambdas.set(680, 550, 440), i2.luminanceFromRadiance.identity();
    const o2 = r3.autoClear;
    return r3.autoClear = false, await ei(this.precompute(i2, false)), r3.autoClear = o2, i2.dispose(), await ft(
      this.renderer,
      this.transmittanceRenderTarget,
      this.transmittanceRenderTarget.texture
    ), await ft(
      this.renderer,
      this.irradianceRenderTarget,
      this.irradianceRenderTarget.texture
    ), this.updating = false, (a2 = this.disposeQueue) == null || a2.call(this), this.textures;
  }
  dispose(e3 = {}) {
    var r3, i2, o2, a2;
    if (this.updating) {
      this.disposeQueue = () => {
        this.dispose(e3), this.disposeQueue = void 0;
      };
      return;
    }
    const { textures: t2 = true } = e3;
    t2 || (this.transmittanceRenderTarget.textures.splice(0, 1), this.scatteringRenderTarget.textures.splice(0, 1), this.irradianceRenderTarget.textures.splice(0, 1), (r3 = this.singleMieScatteringRenderTarget) == null || r3.textures.splice(0, 1), (i2 = this.higherOrderScatteringRenderTarget) == null || i2.textures.splice(0, 1)), this.transmittanceRenderTarget.dispose(), this.scatteringRenderTarget.dispose(), this.irradianceRenderTarget.dispose(), (o2 = this.singleMieScatteringRenderTarget) == null || o2.dispose(), (a2 = this.higherOrderScatteringRenderTarget) == null || a2.dispose(), this.transmittanceMaterial.dispose(), this.directIrradianceMaterial.dispose(), this.singleScatteringMaterial.dispose(), this.scatteringDensityMaterial.dispose(), this.indirectIrradianceMaterial.dispose(), this.multipleScatteringMaterial.dispose(), this.mesh.geometry.dispose();
  }
};
function ni(n3) {
  var e3 = [];
  if (n3.length === 0)
    return "";
  if (typeof n3[0] != "string")
    throw new TypeError("Url must be a string. Received " + n3[0]);
  if (n3[0].match(/^[^/:]+:\/*$/) && n3.length > 1) {
    var t2 = n3.shift();
    n3[0] = t2 + n3[0];
  }
  n3[0].match(/^file:\/\/\//) ? n3[0] = n3[0].replace(/^([^/:]+):\/*/, "$1:///") : n3[0] = n3[0].replace(/^([^/:]+):\/*/, "$1://");
  for (var r3 = 0; r3 < n3.length; r3++) {
    var i2 = n3[r3];
    if (typeof i2 != "string")
      throw new TypeError("Url must be a string. Received " + i2);
    i2 !== "" && (r3 > 0 && (i2 = i2.replace(/^[\/]+/, "")), r3 < n3.length - 1 ? i2 = i2.replace(/[\/]+$/, "") : i2 = i2.replace(/[\/]+$/, "/"), e3.push(i2));
  }
  var o2 = e3.join("/");
  o2 = o2.replace(/\/(\?|&|#[^!])/g, "$1");
  var a2 = o2.split("?");
  return o2 = a2.shift() + (a2.length > 0 ? "?" : "") + a2.join("&"), o2;
}
function ri() {
  var n3;
  return typeof arguments[0] == "object" ? n3 = arguments[0] : n3 = [].slice.call(arguments), ni(n3);
}
var gt = {
  width: u0,
  height: l0
};
var S0 = {
  width: n0,
  height: r0,
  depth: i0
};
var pt = {
  width: s0,
  height: c0
};
var Ui = class extends Loader {
  constructor({
    format: e3 = "exr",
    type: t2 = HalfFloatType,
    combinedScattering: r3 = true,
    higherOrderScattering: i2 = true
  } = {}, o2) {
    super(o2), this.format = e3, this.type = t2, this.combinedScattering = r3, this.higherOrderScattering = i2;
  }
  setType(e3) {
    return this.type = yo(e3) ? FloatType : HalfFloatType, this;
  }
  /** @deprecated Use setType(renderer) instead. */
  setTypeFromRenderer(e3) {
    return this.setType(e3);
  }
  load(e3, t2, r3, i2) {
    const o2 = {}, a2 = ({
      key: c3,
      loader: s,
      path: d2
    }) => (s.setRequestHeader(this.requestHeader), s.setPath(this.path), s.setWithCredentials(this.withCredentials), s.load(
      ri(e3, d2),
      (h2) => {
        h2.type = this.type, this.type === FloatType && (h2.image.data = new Float32Array(
          new L(h2.image.data.buffer)
        )), h2.minFilter = LinearFilter, h2.magFilter = LinearFilter, o2[`${c3}Texture`] = h2, o2.irradianceTexture != null && o2.scatteringTexture != null && o2.transmittanceTexture != null && (this.combinedScattering || o2.singleMieScatteringTexture != null) && (!this.higherOrderScattering || o2.higherOrderScatteringTexture != null) && (t2 == null || t2(o2));
      },
      r3,
      i2
    ));
    return this.format === "exr" ? {
      transmittanceTexture: a2({
        key: "transmittance",
        loader: new zo(gt, this.manager),
        path: "transmittance.exr"
      }),
      scatteringTexture: a2({
        key: "scattering",
        loader: new Lo(S0, this.manager),
        path: "scattering.exr"
      }),
      irradianceTexture: a2({
        key: "irradiance",
        loader: new zo(pt, this.manager),
        path: "irradiance.exr"
      }),
      singleMieScatteringTexture: this.combinedScattering ? void 0 : a2({
        key: "singleMieScattering",
        loader: new Lo(S0, this.manager),
        path: "single_mie_scattering.exr"
      }),
      higherOrderScatteringTexture: this.higherOrderScattering ? a2({
        key: "higherOrderScattering",
        loader: new Lo(S0, this.manager),
        path: "higher_order_scattering.exr"
      }) : void 0
    } : {
      transmittanceTexture: a2({
        key: "transmittance",
        loader: new Ls(
          DataTexture,
          Xo,
          gt,
          this.manager
        ),
        path: "transmittance.bin"
      }),
      scatteringTexture: a2({
        key: "scattering",
        loader: new Ls(
          Data3DTexture,
          Xo,
          S0,
          this.manager
        ),
        path: "scattering.bin"
      }),
      irradianceTexture: a2({
        key: "irradiance",
        loader: new Ls(
          DataTexture,
          Xo,
          pt,
          this.manager
        ),
        path: "irradiance.bin"
      }),
      singleMieScatteringTexture: this.combinedScattering ? void 0 : a2({
        key: "singleMieScattering",
        loader: new Ls(
          Data3DTexture,
          Xo,
          S0,
          this.manager
        ),
        path: "single_mie_scattering.bin"
      }),
      higherOrderScatteringTexture: this.higherOrderScattering ? a2({
        key: "higherOrderScattering",
        loader: new Ls(
          Data3DTexture,
          Xo,
          S0,
          this.manager
        ),
        path: "higher_order_scattering.bin"
      }) : void 0
    };
  }
};
function ii({ topRadius: n3, bottomRadius: e3 }, t2, r3, i2) {
  const o2 = (t2 - e3) / (n3 - e3), a2 = r3 * 0.5 + 0.5;
  return i2.set(
    ne(a2, s0),
    ne(o2, c0)
  );
}
var ai = 1 / Math.sqrt(Math.PI);
var xe = Math.sqrt(3) / (2 * Math.sqrt(Math.PI));
var oi = new Vector3();
var Ae = new Vector3();
var si = new Vector2();
var ci = new Matrix3();
var ui = {
  ellipsoid: b.WGS84,
  correctAltitude: true
};
var bi = class extends LightProbe {
  constructor(e3, t2 = J.DEFAULT) {
    super(), this.atmosphere = t2, this.worldToECEFMatrix = new Matrix4();
    const {
      irradianceTexture: r3 = null,
      ellipsoid: i2,
      correctAltitude: o2,
      sunDirection: a2
    } = { ...ui, ...e3 };
    this.irradianceTexture = r3, this.ellipsoid = i2, this.correctAltitude = o2, this.sunDirection = (a2 == null ? void 0 : a2.clone()) ?? new Vector3();
  }
  update() {
    if (this.irradianceTexture == null)
      return;
    const e3 = this.worldToECEFMatrix, t2 = ci.setFromMatrix4(e3).transpose(), i2 = this.getWorldPosition(oi).applyMatrix4(e3);
    if (this.correctAltitude) {
      const m3 = this.ellipsoid.projectOnSurface(
        i2,
        Ae
      );
      m3 != null && i2.add(
        ze(
          m3,
          this.atmosphere.bottomRadius,
          this.ellipsoid,
          Ae
        )
      );
    }
    const o2 = i2.length(), a2 = i2.dot(this.sunDirection) / o2, c3 = ii(this.atmosphere, o2, a2, si), s = zt(this.irradianceTexture, c3, Ae);
    s.multiply(this.atmosphere.skyRadianceToRelativeLuminance);
    const d2 = this.ellipsoid.getSurfaceNormal(i2).applyMatrix3(t2), h2 = this.sh.coefficients;
    h2[0].copy(s).multiplyScalar(ai), h2[1].copy(s).multiplyScalar(xe * d2.y), h2[2].copy(s).multiplyScalar(xe * d2.z), h2[3].copy(s).multiplyScalar(xe * d2.x);
  }
};
var li = `precision highp float;
precision highp sampler3D;

#define RECIPROCAL_PI 0.3183098861837907

#include "core/raySphereIntersection"

#include "bruneton/definitions"

uniform AtmosphereParameters ATMOSPHERE;
uniform vec3 SUN_SPECTRAL_RADIANCE_TO_LUMINANCE;
uniform vec3 SKY_SPECTRAL_RADIANCE_TO_LUMINANCE;

uniform sampler2D transmittance_texture;
uniform sampler3D scattering_texture;
uniform sampler2D irradiance_texture;
uniform sampler3D single_mie_scattering_texture;
uniform sampler3D higher_order_scattering_texture;

#include "bruneton/common"
#include "bruneton/runtime"

#include "sky"

uniform vec3 sunDirection;
uniform vec3 moonDirection;
uniform float moonAngularRadius;
uniform float lunarRadianceScale;
uniform vec3 groundAlbedo;

#ifdef HAS_SHADOW_LENGTH
uniform sampler2D shadowLengthBuffer;
#endif // HAS_SHADOW_LENGTH

in vec2 vUv;
in vec3 vCameraPosition;
in vec3 vRayDirection;

layout(location = 0) out vec4 outputColor;

#include <mrt_layout>

void main() {
  float shadowLength = 0.0;
  #ifdef HAS_SHADOW_LENGTH
  shadowLength = texture(shadowLengthBuffer, vUv).r;
  #endif // HAS_SHADOW_LENGTH

  vec3 cameraPosition = vCameraPosition;
  vec3 rayDirection = normalize(vRayDirection);

  #ifdef GROUND_ALBEDO

  float r = length(cameraPosition);
  float mu = dot(cameraPosition, rayDirection) / r;
  bool intersectsGround = RayIntersectsGround(ATMOSPHERE, r, mu);
  if (intersectsGround) {
    float distanceToGround = raySphereFirstIntersection(
      cameraPosition,
      rayDirection,
      ATMOSPHERE.bottom_radius
    );
    vec3 groundPosition = rayDirection * distanceToGround + cameraPosition;
    vec3 surfaceNormal = normalize(groundPosition);
    vec3 skyIrradiance;
    vec3 sunIrradiance = GetSunAndSkyIrradiance(
      cameraPosition,
      surfaceNormal,
      sunDirection,
      skyIrradiance
    );
    vec3 transmittance;
    vec3 inscatter = GetSkyRadianceToPoint(
      cameraPosition,
      ATMOSPHERE.bottom_radius * surfaceNormal,
      shadowLength,
      sunDirection,
      transmittance
    );
    vec3 radiance = groundAlbedo * RECIPROCAL_PI * (sunIrradiance + skyIrradiance);
    outputColor.rgb = radiance * transmittance + inscatter;
  } else {
    outputColor.rgb = getSkyRadiance(
      cameraPosition,
      rayDirection,
      shadowLength,
      sunDirection,
      moonDirection,
      moonAngularRadius,
      lunarRadianceScale
    );
  }

  #else // GROUND_ALBEDO

  outputColor.rgb = getSkyRadiance(
    cameraPosition,
    rayDirection,
    shadowLength,
    sunDirection,
    moonDirection,
    moonAngularRadius,
    lunarRadianceScale
  );

  #endif // GROUND_ALBEDO

  outputColor.a = 1.0;

  #include <mrt_output>
}
`;
var di = `precision highp float;
precision highp sampler3D;

uniform mat4 inverseProjectionMatrix;
uniform mat4 inverseViewMatrix;
uniform vec3 cameraPosition;
uniform mat4 worldToECEFMatrix;
uniform vec3 altitudeCorrection;

layout(location = 0) in vec3 position;

out vec2 vUv;
out vec3 vCameraPosition;
out vec3 vRayDirection;

void getCameraRay(out vec3 origin, out vec3 direction) {
  bool isPerspective = inverseProjectionMatrix[2][3] != 0.0; // 4th entry in the 3rd column

  if (isPerspective) {
    // Calculate the camera ray for a perspective camera.
    vec4 viewPosition = inverseProjectionMatrix * vec4(position, 1.0);
    vec4 worldDirection = inverseViewMatrix * vec4(viewPosition.xyz, 0.0);
    origin = cameraPosition;
    direction = worldDirection.xyz;
  } else {
    // Unprojected points to calculate direction.
    vec4 nearPoint = inverseProjectionMatrix * vec4(position.xy, -1.0, 1.0);
    vec4 farPoint = inverseProjectionMatrix * vec4(position.xy, -0.9, 1.0);
    nearPoint /= nearPoint.w;
    farPoint /= farPoint.w;

    // Calculate world values
    vec4 worldDirection = inverseViewMatrix * vec4(farPoint.xyz - nearPoint.xyz, 0.0);
    vec4 worldOrigin = inverseViewMatrix * nearPoint;

    // Outputs
    direction = worldDirection.xyz;
    origin = worldOrigin.xyz;
  }
}

void main() {
  vUv = position.xy * 0.5 + 0.5;

  vec3 direction, origin;
  getCameraRay(origin, direction);

  vec3 cameraPositionECEF = (worldToECEFMatrix * vec4(origin, 1.0)).xyz;
  vCameraPosition = (cameraPositionECEF + altitudeCorrection) * METER_TO_LENGTH_UNIT;
  vRayDirection = (worldToECEFMatrix * vec4(direction, 0.0)).xyz;

  gl_Position = vec4(position.xy, 1.0, 1.0);
}
`;
var hi = Object.defineProperty;
var je = (n3, e3, t2, r3) => {
  for (var i2 = void 0, o2 = n3.length - 1, a2; o2 >= 0; o2--)
    (a2 = n3[o2]) && (i2 = a2(e3, t2, i2) || i2);
  return i2 && hi(e3, t2, i2), i2;
};
var mi = {
  ...ke,
  sun: true,
  moon: true,
  moonAngularRadius: 45e-4,
  //  15.5 arcminutes
  lunarRadianceScale: 1,
  ground: true,
  groundAlbedo: new Color(0)
};
var Xe = class extends de {
  constructor(e3) {
    const {
      sun: t2,
      moon: r3,
      moonDirection: i2,
      moonAngularRadius: o2,
      lunarRadianceScale: a2,
      ground: c3,
      groundAlbedo: s,
      ...d2
    } = { ...mi, ...e3 };
    super({
      name: "SkyMaterial",
      glslVersion: GLSL3,
      vertexShader: di,
      fragmentShader: io(li, {
        core: { raySphereIntersection: u },
        bruneton: {
          common: e2,
          definitions: t,
          runtime: n2
        },
        sky: yt
      }),
      ...d2,
      uniforms: {
        inverseProjectionMatrix: new Uniform(new Matrix4()),
        inverseViewMatrix: new Uniform(new Matrix4()),
        moonDirection: new Uniform((i2 == null ? void 0 : i2.clone()) ?? new Vector3()),
        moonAngularRadius: new Uniform(o2),
        lunarRadianceScale: new Uniform(a2),
        groundAlbedo: new Uniform(s.clone()),
        shadowLengthBuffer: new Uniform(null),
        ...d2.uniforms
      },
      defines: {
        PERSPECTIVE_CAMERA: "1"
      },
      depthTest: true
    }), this.shadowLength = null, this.sun = t2, this.moon = r3, this.ground = c3;
  }
  onBeforeRender(e3, t2, r3, i2, o2, a2) {
    super.onBeforeRender(e3, t2, r3, i2, o2, a2);
    const { uniforms: c3, defines: s } = this;
    c3.inverseProjectionMatrix.value.copy(r3.projectionMatrixInverse), c3.inverseViewMatrix.value.copy(r3.matrixWorld);
    const d2 = s.PERSPECTIVE_CAMERA != null, h2 = r3.isPerspectiveCamera === true;
    h2 !== d2 && (h2 ? s.PERSPECTIVE_CAMERA = "1" : delete s.PERSPECTIVE_CAMERA, this.needsUpdate = true);
    const m3 = this.groundAlbedo, f2 = s.GROUND_ALBEDO != null, T2 = m3.r !== 0 || m3.g !== 0 || m3.b !== 0;
    T2 !== f2 && (T2 ? this.defines.GROUND_ALBEDO = "1" : delete this.defines.GROUND_ALBEDO, this.needsUpdate = true);
    const p3 = this.shadowLength, E = s.HAS_SHADOW_LENGTH != null, R = p3 != null;
    R !== E && (R ? s.HAS_SHADOW_LENGTH = "1" : (delete s.HAS_SHADOW_LENGTH, c3.shadowLengthBuffer.value = null), this.needsUpdate = true), R && (c3.shadowLengthBuffer.value = p3.map);
  }
  get moonDirection() {
    return this.uniforms.moonDirection.value;
  }
  get moonAngularRadius() {
    return this.uniforms.moonAngularRadius.value;
  }
  set moonAngularRadius(e3) {
    this.uniforms.moonAngularRadius.value = e3;
  }
  get lunarRadianceScale() {
    return this.uniforms.lunarRadianceScale.value;
  }
  set lunarRadianceScale(e3) {
    this.uniforms.lunarRadianceScale.value = e3;
  }
  get groundAlbedo() {
    return this.uniforms.groundAlbedo.value;
  }
};
je([
  xo("SUN")
], Xe.prototype, "sun");
je([
  xo("MOON")
], Xe.prototype, "moon");
je([
  xo("GROUND")
], Xe.prototype, "ground");
var Gi = class extends BufferGeometry {
  constructor(e3) {
    super();
    const t2 = new Int16Array(e3), r3 = new Uint8Array(e3), i2 = new InterleavedBuffer(t2, 5), o2 = new InterleavedBuffer(r3, 10);
    this.setAttribute(
      "position",
      new InterleavedBufferAttribute(i2, 3, 0, true)
    ), this.setAttribute(
      "magnitude",
      new InterleavedBufferAttribute(o2, 1, 6, true)
    ), this.setAttribute(
      "color",
      new InterleavedBufferAttribute(o2, 3, 7, true)
    ), this.boundingSphere = new Sphere(new Vector3(), 1);
  }
};
var fi = `precision highp float;
precision highp sampler3D;

#include "bruneton/definitions"

uniform AtmosphereParameters ATMOSPHERE;
uniform vec3 SUN_SPECTRAL_RADIANCE_TO_LUMINANCE;
uniform vec3 SKY_SPECTRAL_RADIANCE_TO_LUMINANCE;

uniform sampler2D transmittance_texture;
uniform sampler3D scattering_texture;
uniform sampler2D irradiance_texture;
uniform sampler3D single_mie_scattering_texture;
uniform sampler3D higher_order_scattering_texture;

#include "bruneton/common"
#include "bruneton/runtime"

uniform vec3 sunDirection;

in vec3 vCameraPosition;
in vec3 vRayDirection;

layout(location = 0) out vec4 outputColor;

#include <mrt_layout>

in vec3 vColor;

void main() {
  #if !defined(PERSPECTIVE_CAMERA)
  outputColor = vec4(0.0);
  discard; // Rendering celestial objects without perspective doesn't make sense.
  #endif // !defined(PERSPECTIVE_CAMERA)

  #ifdef BACKGROUND
  vec3 rayDirection = normalize(vRayDirection);
  float r = length(vCameraPosition);
  float mu = dot(vCameraPosition, rayDirection) / r;

  if (RayIntersectsGround(ATMOSPHERE, r, mu)) {
    discard;
  }

  vec3 transmittance;
  vec3 radiance = GetSkyRadiance(
    vCameraPosition,
    normalize(vRayDirection),
    0.0, // Shadow length
    sunDirection,
    transmittance
  );
  radiance += transmittance * vColor;
  outputColor = vec4(radiance, 1.0);
  #else // BACKGROUND
  outputColor = vec4(vColor, 1.0);
  #endif // BACKGROUND

  #include <mrt_output>
}
`;
var gi = `precision highp float;
precision highp sampler3D;

#define saturate(x) clamp(x, 0.0, 1.0)

uniform mat4 projectionMatrix;
uniform mat4 modelViewMatrix;
uniform mat4 viewMatrix;
uniform mat4 matrixWorld;
uniform vec3 cameraPosition;
uniform float cameraFar;
uniform mat4 worldToECEFMatrix;
uniform vec3 altitudeCorrection;
uniform float pointSize;
uniform vec2 magnitudeRange;
uniform float intensity;

layout(location = 0) in vec3 position;
layout(location = 1) in float magnitude;
layout(location = 2) in vec3 color;

out vec3 vCameraPosition;
out vec3 vRayDirection;
out vec3 vEllipsoidCenter;
out vec3 vColor;

void main() {
  // Magnitude is stored between 0 to 1 within the given range.
  float m = mix(magnitudeRange.x, magnitudeRange.y, magnitude);
  vec3 v = pow(vec3(10.0), -vec3(magnitudeRange, m) / 2.5);
  vColor = vec3(intensity * color);
  vColor *= saturate((v.z - v.y) / (v.x - v.y));

  #ifdef BACKGROUND
  vec3 worldDirection = normalize(matrixWorld * vec4(position, 1.0)).xyz;
  vec3 cameraPositionECEF = (worldToECEFMatrix * vec4(cameraPosition, 1.0)).xyz;
  vCameraPosition = (cameraPositionECEF + altitudeCorrection) * METER_TO_LENGTH_UNIT;
  vRayDirection = (worldToECEFMatrix * vec4(worldDirection, 0.0)).xyz;
  gl_Position =
    projectionMatrix * viewMatrix * vec4(cameraPosition + worldDirection * cameraFar, 1.0);
  #else // BACKGROUND
  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
  #endif // BACKGROUND

  gl_PointSize = pointSize;
}
`;
var pi = Object.defineProperty;
var kt = (n3, e3, t2, r3) => {
  for (var i2 = void 0, o2 = n3.length - 1, a2; o2 >= 0; o2--)
    (a2 = n3[o2]) && (i2 = a2(e3, t2, i2) || i2);
  return i2 && pi(e3, t2, i2), i2;
};
var Ti = {
  ...ke,
  pointSize: 1,
  intensity: 1,
  background: true,
  ground: true
};
var Bt = class extends de {
  constructor(e3) {
    const {
      pointSize: t2,
      radianceScale: r3,
      intensity: i2,
      background: o2,
      ground: a2,
      ...c3
    } = {
      ...Ti,
      ...e3
    };
    super({
      name: "StarsMaterial",
      glslVersion: GLSL3,
      vertexShader: gi,
      fragmentShader: io(fi, {
        bruneton: {
          common: e2,
          definitions: t,
          runtime: n2
        }
      }),
      ...c3,
      uniforms: {
        projectionMatrix: new Uniform(new Matrix4()),
        modelViewMatrix: new Uniform(new Matrix4()),
        viewMatrix: new Uniform(new Matrix4()),
        matrixWorld: new Uniform(new Matrix4()),
        cameraFar: new Uniform(0),
        pointSize: new Uniform(0),
        magnitudeRange: new Uniform(new Vector2(-2, 8)),
        intensity: new Uniform(r3 ?? i2),
        ...c3.uniforms
      },
      defines: {
        PERSPECTIVE_CAMERA: "1"
      }
    }), this.pointSize = t2, this.background = o2, this.ground = a2;
  }
  onBeforeRender(e3, t2, r3, i2, o2, a2) {
    super.onBeforeRender(e3, t2, r3, i2, o2, a2);
    const c3 = this.uniforms;
    c3.projectionMatrix.value.copy(r3.projectionMatrix), c3.modelViewMatrix.value.copy(r3.modelViewMatrix), c3.viewMatrix.value.copy(r3.matrixWorldInverse), c3.matrixWorld.value.copy(o2.matrixWorld), c3.cameraFar.value = r3.far, c3.pointSize.value = this.pointSize * e3.getPixelRatio();
    const s = r3.isPerspectiveCamera === true;
    this.defines.PERSPECTIVE_CAMERA != null !== s && (s ? this.defines.PERSPECTIVE_CAMERA = "1" : delete this.defines.PERSPECTIVE_CAMERA, this.needsUpdate = true);
  }
  get magnitudeRange() {
    return this.uniforms.magnitudeRange.value;
  }
  /** @deprecated Use intensity instead. */
  get radianceScale() {
    return this.intensity;
  }
  /** @deprecated Use intensity instead. */
  set radianceScale(e3) {
    this.intensity = e3;
  }
  get intensity() {
    return this.uniforms.intensity.value;
  }
  set intensity(e3) {
    this.uniforms.intensity.value = e3;
  }
};
kt([
  xo("BACKGROUND")
], Bt.prototype, "background");
kt([
  xo("GROUND")
], Bt.prototype, "ground");
var Si = new Vector3();
var vi = new Matrix3();
var Ei = {
  ellipsoid: b.WGS84,
  correctAltitude: true,
  distance: 1
};
var Fi = class extends DirectionalLight {
  constructor(e3, t2 = J.DEFAULT) {
    super(), this.atmosphere = t2, this.worldToECEFMatrix = new Matrix4();
    const {
      irradianceTexture: r3 = null,
      ellipsoid: i2,
      correctAltitude: o2,
      sunDirection: a2,
      distance: c3
    } = { ...Ei, ...e3 };
    this.transmittanceTexture = r3, this.ellipsoid = i2, this.correctAltitude = o2, this.sunDirection = (a2 == null ? void 0 : a2.clone()) ?? new Vector3(), this.distance = c3;
  }
  update() {
    const e3 = this.worldToECEFMatrix, t2 = vi.setFromMatrix4(e3).transpose();
    if (this.position.copy(this.sunDirection).applyMatrix3(t2).normalize().multiplyScalar(this.distance).add(this.target.position), this.transmittanceTexture == null)
      return;
    const r3 = this.target.getWorldPosition(Si).applyMatrix4(e3);
    Br(
      this.transmittanceTexture,
      r3,
      this.sunDirection,
      this.color,
      {
        ellipsoid: this.ellipsoid,
        correctAltitude: this.correctAltitude
      },
      this.atmosphere
    );
  }
};

// node_modules/@takram/three-atmosphere/build/index.js
var D = new Vector3();
function l(a2, r3 = new Color()) {
  const t2 = a2, T2 = t2 ** 2, o2 = (0.860117757 + 154118254e-12 * t2 + 128641212e-15 * T2) / (1 + 842420235e-12 * t2 + 708145163e-15 * T2), E = (0.317398726 + 422806245e-13 * t2 + 420481691e-16 * T2) / (1 - 289741816e-13 * t2 + 161456053e-15 * T2), c3 = 3 * o2 / (2 * o2 - 8 * E + 4), s = 2 * E / (2 * o2 - 8 * E + 4), i2 = 1, R = s > 0 ? c3 * i2 / s : 0, S = s > 0 ? (1 - c3 - s) * i2 / s : 0, e3 = D.set(R, i2, S).applyMatrix3(Di);
  return e3.x = Co(e3.x), e3.y = Co(e3.y), e3.z = Co(e3.z), r3.setFromVector3(e3.normalize());
}
function A(a2) {
  return 4600 * (1 / (0.92 * $e(a2, -0.4, 2) + 1.7) + 1 / (0.92 * a2 + 0.62));
}
function p2(a2, r3 = new Color()) {
  return l(
    A(a2),
    r3
  );
}
export {
  L2 as AerialPerspectiveEffect,
  de as AtmosphereMaterialBase,
  J as AtmosphereParameters,
  Mi as DEFAULT_PRECOMPUTED_TEXTURES_URL,
  yi as DEFAULT_STARS_DATA_URL,
  g0 as DensityProfileLayer,
  c0 as IRRADIANCE_TEXTURE_HEIGHT,
  s0 as IRRADIANCE_TEXTURE_WIDTH,
  Li as IrradianceMaskPass,
  Wr as LightingMaskPass,
  ee as METER_TO_LENGTH_UNIT,
  Hi as PrecomputedTexturesGenerator,
  Ui as PrecomputedTexturesLoader,
  i0 as SCATTERING_TEXTURE_DEPTH,
  r0 as SCATTERING_TEXTURE_HEIGHT,
  ce as SCATTERING_TEXTURE_MU_SIZE,
  ue as SCATTERING_TEXTURE_MU_S_SIZE,
  le as SCATTERING_TEXTURE_NU_SIZE,
  se as SCATTERING_TEXTURE_R_SIZE,
  n0 as SCATTERING_TEXTURE_WIDTH,
  Ci as SKY_RENDER_ORDER,
  bi as SkyLightProbe,
  Xe as SkyMaterial,
  Gi as StarsGeometry,
  Bt as StarsMaterial,
  Fi as SunDirectionalLight,
  l0 as TRANSMITTANCE_TEXTURE_HEIGHT,
  u0 as TRANSMITTANCE_TEXTURE_WIDTH,
  Di as XYZ_TO_SRGB,
  kn as aerialPerspectiveEffectOptionsDefaults,
  ke as atmosphereMaterialParametersBaseDefaults,
  p2 as convertBVIndexToLinearSRGBChromaticity,
  l as convertTemperatureToLinearSRGBChromaticity,
  ze as getAltitudeCorrectionOffset,
  bt as getECIToECEFRotationMatrix,
  Oi as getMoonDirectionECEF,
  Pi as getMoonDirectionECI,
  Ni as getSunDirectionECEF,
  Ii as getSunDirectionECI,
  Br as getSunLightColor,
  ui as skyLightProbeParametersDefaults,
  mi as skyMaterialParametersDefaults,
  Ti as starsMaterialParametersDefaults,
  Ei as sunDirectionalLightParametersDefaults
};
/*! Bundled license information:

postprocessing/build/index.js:
  (**
   * postprocessing v6.37.8 build Fri Sep 12 2025
   * https://github.com/pmndrs/postprocessing
   * Copyright 2015-2025 Raoul van Rschen
   * @license Zlib
   *)

@takram/three-atmosphere/build/shared.js:
  (**
      @preserve
  
      Astronomy library for JavaScript (browser and Node.js).
      https://github.com/cosinekitty/astronomy
  
      MIT License
  
      Copyright (c) 2019-2023 Don Cross <cosinekitty@gmail.com>
  
      Permission is hereby granted, free of charge, to any person obtaining a copy
      of this software and associated documentation files (the "Software"), to deal
      in the Software without restriction, including without limitation the rights
      to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
      copies of the Software, and to permit persons to whom the Software is
      furnished to do so, subject to the following conditions:
  
      The above copyright notice and this permission notice shall be included in all
      copies or substantial portions of the Software.
  
      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
      IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
      FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
      AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
      LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
      OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
      SOFTWARE.
  *)
  (**
   * @fileoverview Astronomy calculation library for browser scripting and Node.js.
   * @author Don Cross <cosinekitty@gmail.com>
   * @license MIT
   *)
*/
//# sourceMappingURL=@takram_three-atmosphere.js.map
