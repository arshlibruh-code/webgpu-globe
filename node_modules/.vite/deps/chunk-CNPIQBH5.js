import {
  Box3,
  BufferAttribute,
  BufferGeometry,
  ByteType,
  Data3DTexture,
  DataTexture,
  DataTextureLoader,
  DataUtils,
  FileLoader,
  FloatType,
  HalfFloatType,
  IntType,
  LinearFilter,
  Loader,
  Material,
  MathUtils,
  Matrix4,
  NearestFilter,
  Quaternion,
  REVISION,
  RGBAFormat,
  Ray,
  RedFormat,
  RepeatWrapping,
  ShortType,
  Sphere,
  UnsignedByteType,
  UnsignedIntType,
  UnsignedShortType,
  Vector2,
  Vector3
} from "./chunk-GHUIN7QU.js";

// node_modules/@takram/three-geospatial/build/shared.js
var k = true;
var P = "Invariant failed";
function R(f, t) {
  if (!f) {
    if (k)
      throw new Error(P);
    var i = P;
    throw new Error(i);
  }
}
var H = new Vector3();
function G(f, t, i = new Vector3(), r) {
  const { x: s, y: e, z: n } = f, a = t.x, h = t.y, u = t.z, d = s * s * a, y = e * e * h, c = n * n * u, l = d + y + c, p = Math.sqrt(1 / l);
  if (!Number.isFinite(p))
    return;
  const M2 = H.copy(f).multiplyScalar(p);
  if (l < ((r == null ? void 0 : r.centerTolerance) ?? 0.1))
    return i.copy(M2);
  const v = M2.multiply(t).multiplyScalar(2);
  let m = (1 - p) * f.length() / (v.length() / 2), I = 0, x2, w, z, E;
  do {
    m -= I, x2 = 1 / (1 + m * a), w = 1 / (1 + m * h), z = 1 / (1 + m * u);
    const F = x2 * x2, L2 = w * w, O2 = z * z, j = F * x2, B = L2 * w, W = O2 * z;
    E = d * F + y * L2 + c * O2 - 1, I = E / ((d * j * a + y * B * h + c * W * u) * -2);
  } while (Math.abs(E) > 1e-12);
  return i.set(s * x2, e * w, n * z);
}
var N = new Vector3();
var V = new Vector3();
var U = new Vector3();
var q = class q2 {
  constructor(t, i, r) {
    this.radii = new Vector3(t, i, r);
  }
  get minimumRadius() {
    return Math.min(this.radii.x, this.radii.y, this.radii.z);
  }
  get maximumRadius() {
    return Math.max(this.radii.x, this.radii.y, this.radii.z);
  }
  reciprocalRadii(t = new Vector3()) {
    const { x: i, y: r, z: s } = this.radii;
    return t.set(1 / i, 1 / r, 1 / s);
  }
  reciprocalRadiiSquared(t = new Vector3()) {
    const { x: i, y: r, z: s } = this.radii;
    return t.set(1 / i ** 2, 1 / r ** 2, 1 / s ** 2);
  }
  projectOnSurface(t, i = new Vector3(), r) {
    return G(
      t,
      this.reciprocalRadiiSquared(),
      i,
      r
    );
  }
  getSurfaceNormal(t, i = new Vector3()) {
    return i.multiplyVectors(this.reciprocalRadiiSquared(N), t).normalize();
  }
  getEastNorthUpVectors(t, i = new Vector3(), r = new Vector3(), s = new Vector3()) {
    this.getSurfaceNormal(t, s), i.set(-t.y, t.x, 0).normalize(), r.crossVectors(s, i).normalize();
  }
  getEastNorthUpFrame(t, i = new Matrix4()) {
    const r = N, s = V, e = U;
    return this.getEastNorthUpVectors(t, r, s, e), i.makeBasis(r, s, e).setPosition(t);
  }
  getNorthUpEastFrame(t, i = new Matrix4()) {
    const r = N, s = V, e = U;
    return this.getEastNorthUpVectors(t, r, s, e), i.makeBasis(s, e, r).setPosition(t);
  }
  getIntersection(t, i = new Vector3()) {
    const r = this.reciprocalRadii(N), s = V.copy(r).multiply(t.origin), e = U.copy(r).multiply(t.direction), n = s.lengthSq(), a = e.lengthSq(), h = s.dot(e), u = h ** 2 - a * (n - 1);
    if (n === 1)
      return i.copy(t.origin);
    if (n > 1) {
      if (h >= 0 || u < 0)
        return;
      const d = Math.sqrt(u), y = (-h - d) / a, c = (-h + d) / a;
      return t.at(Math.min(y, c), i);
    }
    if (n < 1) {
      const d = h ** 2 - a * (n - 1), y = Math.sqrt(d), c = (-h + y) / a;
      return t.at(c, i);
    }
    if (h < 0)
      return t.at(-h / a, i);
  }
  getOsculatingSphereCenter(t, i, r = new Vector3()) {
    R(this.radii.x === this.radii.y);
    const s = this.radii.x ** 2, e = this.radii.z ** 2, n = N.set(
      t.x / s,
      t.y / s,
      t.z / e
    ).normalize();
    return r.copy(n.multiplyScalar(-i).add(t));
  }
  getNormalAtHorizon(t, i, r = new Vector3()) {
    R(this.radii.x === this.radii.y);
    const s = this.radii.x ** 2, e = this.radii.z ** 2, n = t, a = i;
    let h = (n.x * a.x + n.y * a.y) / s + n.z * a.z / e;
    h /= (n.x ** 2 + n.y ** 2) / s + n.z ** 2 / e;
    const u = N.copy(a).multiplyScalar(-h).add(t);
    return r.set(u.x / s, u.y / s, u.z / e).normalize();
  }
};
q.WGS84 = new q(
  6378137,
  6378137,
  6356752314245179e-9
);
var b = q;
var X = class extends BufferGeometry {
  constructor(t = new Vector3(1, 1, 1), i = 32, r = 16) {
    super(), this.type = "EllipsoidGeometry", this.parameters = {
      radii: t,
      longitudeSegments: i,
      latitudeSegments: r
    }, i = Math.max(3, Math.floor(i)), r = Math.max(2, Math.floor(r));
    const s = (i + 1) * (r + 1), e = new Vector3(), n = new Vector3(), a = new Float32Array(s * 3), h = new Float32Array(s * 3), u = new Float32Array(s * 2), d = [], y = [];
    for (let c = 0, l = 0, p = 0, M2 = 0; c <= r; ++c) {
      const v = [], m = c / r, I = m * Math.PI;
      let x2 = 0;
      c === 0 ? x2 = 0.5 / i : c === r && (x2 = -0.5 / i);
      for (let w = 0; w <= i; ++w, l += 3, p += 2, ++M2) {
        const z = w / i, E = z * Math.PI * 2;
        e.x = t.x * Math.cos(E) * Math.sin(I), e.y = t.y * Math.sin(E) * Math.sin(I), e.z = t.z * Math.cos(I), a[l] = e.x, a[l + 1] = e.y, a[l + 2] = e.z, n.copy(e).normalize(), h[l] = n.x, h[l + 1] = n.y, h[l + 2] = n.z, u[p] = z + x2, u[p + 1] = 1 - m, v.push(M2);
      }
      d.push(v);
    }
    for (let c = 0; c < r; ++c)
      for (let l = 0; l < i; ++l) {
        const p = d[c][l + 1], M2 = d[c][l], v = d[c + 1][l], m = d[c + 1][l + 1];
        c !== 0 && y.push(p, M2, m), c !== r - 1 && y.push(M2, v, m);
      }
    this.setIndex(y), this.setAttribute("position", new BufferAttribute(a, 3)), this.setAttribute("normal", new BufferAttribute(h, 3)), this.setAttribute("uv", new BufferAttribute(u, 2));
  }
  copy(t) {
    return super.copy(t), this.parameters = { ...t.parameters }, this;
  }
};
var A = new Vector3();
var D = new Vector3();
var g = class g2 {
  constructor(t = 0, i = 0, r = 0) {
    this.longitude = t, this.latitude = i, this.height = r;
  }
  set(t, i, r) {
    return this.longitude = t, this.latitude = i, r != null && (this.height = r), this;
  }
  clone() {
    return new g2(this.longitude, this.latitude, this.height);
  }
  copy(t) {
    return this.longitude = t.longitude, this.latitude = t.latitude, this.height = t.height, this;
  }
  equals(t) {
    return t.longitude === this.longitude && t.latitude === this.latitude && t.height === this.height;
  }
  setLongitude(t) {
    return this.longitude = t, this;
  }
  setLatitude(t) {
    return this.latitude = t, this;
  }
  setHeight(t) {
    return this.height = t, this;
  }
  normalize() {
    return this.longitude < g2.MIN_LONGITUDE && (this.longitude += Math.PI * 2), this;
  }
  // See: https://en.wikipedia.org/wiki/Geographic_coordinate_conversion
  // Reference: https://github.com/CesiumGS/cesium/blob/1.122/packages/engine/Source/Core/Geodetic.js#L119
  setFromECEF(t, i) {
    const s = ((i == null ? void 0 : i.ellipsoid) ?? b.WGS84).reciprocalRadiiSquared(A), e = G(
      t,
      s,
      D,
      i
    );
    if (e == null)
      throw new Error(
        `Could not project position to ellipsoid surface: ${t.toArray()}`
      );
    const n = A.multiplyVectors(e, s).normalize();
    this.longitude = Math.atan2(n.y, n.x), this.latitude = Math.asin(n.z);
    const a = A.subVectors(t, e);
    return this.height = Math.sign(a.dot(t)) * a.length(), this;
  }
  // See: https://en.wikipedia.org/wiki/Geographic_coordinate_conversion
  // Reference: https://github.com/CesiumGS/cesium/blob/1.122/packages/engine/Source/Core/Cartesian3.js#L916
  toECEF(t = new Vector3(), i) {
    const r = (i == null ? void 0 : i.ellipsoid) ?? b.WGS84, s = A.multiplyVectors(
      r.radii,
      r.radii
    ), e = Math.cos(this.latitude), n = D.set(
      e * Math.cos(this.longitude),
      e * Math.sin(this.longitude),
      Math.sin(this.latitude)
    ).normalize();
    return t.multiplyVectors(s, n), t.divideScalar(Math.sqrt(n.dot(t))).add(n.multiplyScalar(this.height));
  }
  fromArray(t, i = 0) {
    return this.longitude = t[i], this.latitude = t[i + 1], this.height = t[i + 2], this;
  }
  toArray(t = [], i = 0) {
    return t[i] = this.longitude, t[i + 1] = this.latitude, t[i + 2] = this.height, t;
  }
  *[Symbol.iterator]() {
    yield this.longitude, yield this.latitude, yield this.height;
  }
};
g.MIN_LONGITUDE = -Math.PI, g.MAX_LONGITUDE = Math.PI, g.MIN_LATITUDE = -Math.PI / 2, g.MAX_LATITUDE = Math.PI / 2;
var C = g;

// node_modules/@takram/three-geospatial/build/index.js
var Bi = class extends Loader {
  load(e, n, s, o) {
    const a = new FileLoader(this.manager);
    a.setResponseType("arraybuffer"), a.setRequestHeader(this.requestHeader), a.setPath(this.path), a.setWithCredentials(this.withCredentials), a.load(
      e,
      (l) => {
        R(l instanceof ArrayBuffer);
        try {
          n(l);
        } catch (u) {
          o != null ? o(u) : console.error(u), this.manager.itemError(e);
        }
      },
      s,
      o
    );
  }
};
function uo(r) {
}
function fo(r) {
  var a;
  const { attributes: e, index: n, boundingBox: s, boundingSphere: o } = r;
  return [
    { attributes: e, index: n, boundingBox: s, boundingSphere: o },
    [
      ...Object.values(r.attributes).map(
        (l) => l.array.buffer
      ),
      (a = r.index) == null ? void 0 : a.array.buffer
    ].filter((l) => l != null)
  ];
}
function vo(r, e = new BufferGeometry()) {
  for (const [n, s] of Object.entries(r.attributes))
    e.setAttribute(
      n,
      new BufferAttribute(
        s.array,
        s.itemSize,
        s.normalized
      )
    );
  if (e.index = r.index != null ? new BufferAttribute(
    r.index.array,
    r.index.itemSize,
    r.index.normalized
  ) : null, r.boundingBox != null) {
    const { min: n, max: s } = r.boundingBox;
    e.boundingBox = new Box3(
      new Vector3(n.x, n.y, n.z),
      new Vector3(s.x, s.y, s.z)
    );
  }
  if (r.boundingSphere != null) {
    const { center: n, radius: s } = r.boundingSphere;
    e.boundingSphere = new Sphere(
      new Vector3(n.x, n.y, n.z),
      s
    );
  }
  return e;
}
function yo(r) {
  return r.getContext().getExtension("OES_texture_float_linear") != null;
}
var Di = 128;
var Li = 128;
var zi = 64;
var ki = "9627216cc50057994c98a2118f3c4a23765d43b9";
var po = `https://media.githubusercontent.com/media/takram-design-engineering/three-geospatial/${ki}/packages/core/assets/stbn.bin`;
var Zi = "This is not an object";
var Hi = "This is not a Float16Array object";
var Wr = "This constructor is not a subclass of Float16Array";
var vn = "The constructor property value is not an object";
var Gi = "Species constructor didn't return TypedArray object";
var Wi = "Derived constructor created TypedArray object which was too small length";
var vt = "Attempting to access detached ArrayBuffer";
var yr = "Cannot convert undefined or null to object";
var pr = "Cannot mix BigInt and other types, use explicit conversions";
var Xr = "@@iterator property is not callable";
var Yr = "Reduce of empty array with no initial value";
var Xi = "The comparison function must be either a function or undefined";
var or = "Offset is out of bounds";
function Z(r) {
  return (e, ...n) => ie(r, e, n);
}
function Je(r, e) {
  return Z(
    Ye(
      r,
      e
    ).get
  );
}
var {
  apply: ie,
  construct: ht,
  defineProperty: qr,
  get: ar,
  getOwnPropertyDescriptor: Ye,
  getPrototypeOf: At,
  has: wr,
  ownKeys: yn,
  set: Vr,
  setPrototypeOf: pn
} = Reflect;
var Yi = Proxy;
var {
  EPSILON: qi,
  MAX_SAFE_INTEGER: $r,
  isFinite: wn,
  isNaN: qe
} = Number;
var {
  iterator: Ie,
  species: Vi,
  toStringTag: Ir,
  for: $i
} = Symbol;
var Ve = Object;
var {
  create: $t,
  defineProperty: St,
  freeze: Ji,
  is: Jr
} = Ve;
var dr = Ve.prototype;
var Qi = (
  /** @type {any} */
  dr.__lookupGetter__ ? Z(
    /** @type {any} */
    dr.__lookupGetter__
  ) : (r, e) => {
    if (r == null)
      throw X2(
        yr
      );
    let n = Ve(r);
    do {
      const s = Ye(n, e);
      if (s !== void 0)
        return Ce(s, "get") ? s.get : void 0;
    } while ((n = At(n)) !== null);
  }
);
var Ce = (
  /** @type {any} */
  Ve.hasOwn || Z(dr.hasOwnProperty)
);
var dn = Array;
var gn = dn.isArray;
var Jt = dn.prototype;
var ji = Z(Jt.join);
var Ki = Z(Jt.push);
var es = Z(
  Jt.toLocaleString
);
var _r = Jt[Ie];
var ts = Z(_r);
var {
  abs: rs,
  trunc: An
} = Math;
var Qt = ArrayBuffer;
var ns = Qt.isView;
var Sn = Qt.prototype;
var is = Z(Sn.slice);
var ss = Je(Sn, "byteLength");
var gr = typeof SharedArrayBuffer < "u" ? SharedArrayBuffer : null;
var os = gr && Je(gr.prototype, "byteLength");
var br = At(Uint8Array);
var as = br.from;
var Q = br.prototype;
var cs = Q[Ie];
var ls = Z(Q.keys);
var hs = Z(
  Q.values
);
var us = Z(
  Q.entries
);
var fs = Z(Q.set);
var Qr = Z(
  Q.reverse
);
var vs = Z(Q.fill);
var ys = Z(
  Q.copyWithin
);
var jr = Z(Q.sort);
var ot = Z(Q.slice);
var ps = Z(
  Q.subarray
);
var J = Je(
  Q,
  "buffer"
);
var Le = Je(
  Q,
  "byteOffset"
);
var x = Je(
  Q,
  "length"
);
var En = Je(
  Q,
  Ir
);
var ws = Uint8Array;
var ce = Uint16Array;
var Kr = (...r) => ie(as, ce, r);
var Nr = Uint32Array;
var ds = Float32Array;
var ze = At([][Ie]());
var jt = Z(ze.next);
var gs = Z((function* () {
})().next);
var As = At(ze);
var Ss = DataView.prototype;
var Es = Z(
  Ss.getUint16
);
var X2 = TypeError;
var cr = RangeError;
var Tn = WeakSet;
var In = Tn.prototype;
var Ts = Z(In.add);
var Is = Z(In.has);
var Kt = WeakMap;
var Or = Kt.prototype;
var Zt = Z(Or.get);
var _s = Z(Or.has);
var Ur = Z(Or.set);
var _n = new Kt();
var bs = $t(null, {
  next: {
    value: function() {
      const e = Zt(_n, this);
      return jt(e);
    }
  },
  [Ie]: {
    value: function() {
      return this;
    }
  }
});
function ut(r) {
  if (r[Ie] === _r && ze.next === jt)
    return r;
  const e = $t(bs);
  return Ur(_n, e, ts(r)), e;
}
var bn = new Kt();
var Nn = $t(As, {
  next: {
    value: function() {
      const e = Zt(bn, this);
      return gs(e);
    },
    writable: true,
    configurable: true
  }
});
for (const r of yn(ze))
  r !== "next" && St(Nn, r, Ye(ze, r));
function en(r) {
  const e = $t(Nn);
  return Ur(bn, e, r), e;
}
function Ht(r) {
  return r !== null && typeof r == "object" || typeof r == "function";
}
function tn(r) {
  return r !== null && typeof r == "object";
}
function Gt(r) {
  return En(r) !== void 0;
}
function Ar(r) {
  const e = En(r);
  return e === "BigInt64Array" || e === "BigUint64Array";
}
function Ns(r) {
  try {
    return gn(r) ? false : (ss(
      /** @type {any} */
      r
    ), true);
  } catch {
    return false;
  }
}
function On(r) {
  if (gr === null)
    return false;
  try {
    return os(
      /** @type {any} */
      r
    ), true;
  } catch {
    return false;
  }
}
function Os(r) {
  return Ns(r) || On(r);
}
function rn(r) {
  return gn(r) ? r[Ie] === _r && ze.next === jt : false;
}
function Us(r) {
  return Gt(r) ? r[Ie] === cs && ze.next === jt : false;
}
function Ft(r) {
  if (typeof r != "string")
    return false;
  const e = +r;
  return r !== e + "" || !wn(e) ? false : e === An(e);
}
var Wt = $i("__Float16Array__");
function ms(r) {
  if (!tn(r))
    return false;
  const e = At(r);
  if (!tn(e))
    return false;
  const n = e.constructor;
  if (n === void 0)
    return false;
  if (!Ht(n))
    throw X2(vn);
  return wr(n, Wt);
}
var Sr = 1 / qi;
function Cs(r) {
  return r + Sr - Sr;
}
var Un = 6103515625e-14;
var Rs = 65504;
var mn = 9765625e-10;
var nn = mn * Un;
var xs = mn * Sr;
function Fs(r) {
  const e = +r;
  if (!wn(e) || e === 0)
    return e;
  const n = e > 0 ? 1 : -1, s = rs(e);
  if (s < Un)
    return n * Cs(s / nn) * nn;
  const o = (1 + xs) * s, a = o - (o - s);
  return a > Rs || qe(a) ? n * (1 / 0) : n * a;
}
var Cn = new Qt(4);
var Rn = new ds(Cn);
var xn = new Nr(Cn);
var de = new ce(512);
var ge = new ws(512);
for (let r = 0; r < 256; ++r) {
  const e = r - 127;
  e < -24 ? (de[r] = 0, de[r | 256] = 32768, ge[r] = 24, ge[r | 256] = 24) : e < -14 ? (de[r] = 1024 >> -e - 14, de[r | 256] = 1024 >> -e - 14 | 32768, ge[r] = -e - 1, ge[r | 256] = -e - 1) : e <= 15 ? (de[r] = e + 15 << 10, de[r | 256] = e + 15 << 10 | 32768, ge[r] = 13, ge[r | 256] = 13) : e < 128 ? (de[r] = 31744, de[r | 256] = 64512, ge[r] = 24, ge[r | 256] = 24) : (de[r] = 31744, de[r | 256] = 64512, ge[r] = 13, ge[r | 256] = 13);
}
function Te(r) {
  Rn[0] = Fs(r);
  const e = xn[0], n = e >> 23 & 511;
  return de[n] + ((e & 8388607) >> ge[n]);
}
var mr = new Nr(2048);
for (let r = 1; r < 1024; ++r) {
  let e = r << 13, n = 0;
  for (; (e & 8388608) === 0; )
    e <<= 1, n -= 8388608;
  e &= -8388609, n += 947912704, mr[r] = e | n;
}
for (let r = 1024; r < 2048; ++r)
  mr[r] = 939524096 + (r - 1024 << 13);
var Qe = new Nr(64);
for (let r = 1; r < 31; ++r)
  Qe[r] = r << 23;
Qe[31] = 1199570944;
Qe[32] = 2147483648;
for (let r = 33; r < 63; ++r)
  Qe[r] = 2147483648 + (r - 32 << 23);
Qe[63] = 3347054592;
var Fn = new ce(64);
for (let r = 1; r < 64; ++r)
  r !== 32 && (Fn[r] = 1024);
function M(r) {
  const e = r >> 10;
  return xn[0] = mr[Fn[e] + (r & 1023)] + Qe[e], Rn[0];
}
function me(r) {
  const e = +r;
  return qe(e) || e === 0 ? 0 : An(e);
}
function lr(r) {
  const e = me(r);
  return e < 0 ? 0 : e < $r ? e : $r;
}
function Mt(r, e) {
  if (!Ht(r))
    throw X2(Zi);
  const n = r.constructor;
  if (n === void 0)
    return e;
  if (!Ht(n))
    throw X2(vn);
  const s = n[Vi];
  return s ?? e;
}
function yt(r) {
  if (On(r))
    return false;
  try {
    return is(r, 0, 0), false;
  } catch {
  }
  return true;
}
function sn(r, e) {
  const n = qe(r), s = qe(e);
  if (n && s)
    return 0;
  if (n)
    return 1;
  if (s || r < e)
    return -1;
  if (r > e)
    return 1;
  if (r === 0 && e === 0) {
    const o = Jr(r, 0), a = Jr(e, 0);
    if (!o && a)
      return -1;
    if (o && !a)
      return 1;
  }
  return 0;
}
var Cr = 2;
var Xt = new Kt();
function Xe(r) {
  return _s(Xt, r) || !ns(r) && ms(r);
}
function R2(r) {
  if (!Xe(r))
    throw X2(Hi);
}
function Pt(r, e) {
  const n = Xe(r), s = Gt(r);
  if (!n && !s)
    throw X2(Gi);
  if (typeof e == "number") {
    let o;
    if (n) {
      const a = O(r);
      o = x(a);
    } else
      o = x(r);
    if (o < e)
      throw X2(
        Wi
      );
  }
  if (Ar(r))
    throw X2(pr);
}
function O(r) {
  const e = Zt(Xt, r);
  if (e !== void 0) {
    const o = J(e);
    if (yt(o))
      throw X2(vt);
    return e;
  }
  const n = (
    /** @type {any} */
    r.buffer
  );
  if (yt(n))
    throw X2(vt);
  const s = ht(L, [
    n,
    /** @type {any} */
    r.byteOffset,
    /** @type {any} */
    r.length
  ], r.constructor);
  return Zt(Xt, s);
}
function on(r) {
  const e = x(r), n = [];
  for (let s = 0; s < e; ++s)
    n[s] = M(r[s]);
  return n;
}
var Mn = new Tn();
for (const r of yn(Q)) {
  if (r === Ir)
    continue;
  const e = Ye(Q, r);
  Ce(e, "get") && typeof e.get == "function" && Ts(Mn, e.get);
}
var Ms = Ji(
  /** @type {ProxyHandler<Float16BitsArray>} */
  {
    get(r, e, n) {
      return Ft(e) && Ce(r, e) ? M(ar(r, e)) : Is(Mn, Qi(r, e)) ? ar(r, e) : ar(r, e, n);
    },
    set(r, e, n, s) {
      return Ft(e) && Ce(r, e) ? Vr(r, e, Te(n)) : Vr(r, e, n, s);
    },
    getOwnPropertyDescriptor(r, e) {
      if (Ft(e) && Ce(r, e)) {
        const n = Ye(r, e);
        return n.value = M(n.value), n;
      }
      return Ye(r, e);
    },
    defineProperty(r, e, n) {
      return Ft(e) && Ce(r, e) && Ce(n, "value") && (n.value = Te(n.value)), qr(r, e, n);
    }
  }
);
var L = class _L {
  /** @see https://tc39.es/ecma262/#sec-typedarray */
  constructor(e, n, s) {
    let o;
    if (Xe(e))
      o = ht(ce, [O(e)], new.target);
    else if (Ht(e) && !Os(e)) {
      let l, u;
      if (Gt(e)) {
        l = e, u = x(e);
        const y = J(e);
        if (yt(y))
          throw X2(vt);
        if (Ar(e))
          throw X2(pr);
        const E = new Qt(
          u * Cr
        );
        o = ht(ce, [E], new.target);
      } else {
        const y = e[Ie];
        if (y != null && typeof y != "function")
          throw X2(Xr);
        y != null ? rn(e) ? (l = e, u = e.length) : (l = [.../** @type {Iterable<unknown>} */
        e], u = l.length) : (l = /** @type {ArrayLike<unknown>} */
        e, u = lr(l.length)), o = ht(ce, [u], new.target);
      }
      for (let y = 0; y < u; ++y)
        o[y] = Te(l[y]);
    } else
      o = ht(ce, arguments, new.target);
    const a = (
      /** @type {any} */
      new Yi(o, Ms)
    );
    return Ur(Xt, a, o), a;
  }
  /**
   * limitation: `Object.getOwnPropertyNames(Float16Array)` or `Reflect.ownKeys(Float16Array)` include this key
   * @see https://tc39.es/ecma262/#sec-%typedarray%.from
   */
  static from(e, ...n) {
    const s = this;
    if (!wr(s, Wt))
      throw X2(
        Wr
      );
    if (s === _L) {
      if (Xe(e) && n.length === 0) {
        const I = O(e), U2 = new ce(
          J(I),
          Le(I),
          x(I)
        );
        return new _L(
          J(ot(U2))
        );
      }
      if (n.length === 0)
        return new _L(
          J(
            Kr(e, Te)
          )
        );
      const y = n[0], E = n[1];
      return new _L(
        J(
          Kr(e, function(I, ...U2) {
            return Te(
              ie(y, this, [I, ...ut(U2)])
            );
          }, E)
        )
      );
    }
    let o, a;
    const l = e[Ie];
    if (l != null && typeof l != "function")
      throw X2(Xr);
    if (l != null)
      rn(e) ? (o = e, a = e.length) : Us(e) ? (o = e, a = x(e)) : (o = [...e], a = o.length);
    else {
      if (e == null)
        throw X2(
          yr
        );
      o = Ve(e), a = lr(o.length);
    }
    const u = new s(a);
    if (n.length === 0)
      for (let y = 0; y < a; ++y)
        u[y] = /** @type {number} */
        o[y];
    else {
      const y = n[0], E = n[1];
      for (let I = 0; I < a; ++I)
        u[I] = ie(y, E, [o[I], I]);
    }
    return u;
  }
  /**
   * limitation: `Object.getOwnPropertyNames(Float16Array)` or `Reflect.ownKeys(Float16Array)` include this key
   * @see https://tc39.es/ecma262/#sec-%typedarray%.of
   */
  static of(...e) {
    const n = this;
    if (!wr(n, Wt))
      throw X2(
        Wr
      );
    const s = e.length;
    if (n === _L) {
      const a = new _L(s), l = O(a);
      for (let u = 0; u < s; ++u)
        l[u] = Te(e[u]);
      return a;
    }
    const o = new n(s);
    for (let a = 0; a < s; ++a)
      o[a] = e[a];
    return o;
  }
  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.keys */
  keys() {
    R2(this);
    const e = O(this);
    return ls(e);
  }
  /**
   * limitation: returns a object whose prototype is not `%ArrayIteratorPrototype%`
   * @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.values
   */
  values() {
    R2(this);
    const e = O(this);
    return en((function* () {
      for (const n of hs(e))
        yield M(n);
    })());
  }
  /**
   * limitation: returns a object whose prototype is not `%ArrayIteratorPrototype%`
   * @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.entries
   */
  entries() {
    R2(this);
    const e = O(this);
    return en((function* () {
      for (const [n, s] of us(e))
        yield (
          /** @type {[number, number]} */
          [n, M(s)]
        );
    })());
  }
  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.at */
  at(e) {
    R2(this);
    const n = O(this), s = x(n), o = me(e), a = o >= 0 ? o : s + o;
    if (!(a < 0 || a >= s))
      return M(n[a]);
  }
  /** @see https://tc39.es/proposal-change-array-by-copy/#sec-%typedarray%.prototype.with */
  with(e, n) {
    R2(this);
    const s = O(this), o = x(s), a = me(e), l = a >= 0 ? a : o + a, u = +n;
    if (l < 0 || l >= o)
      throw cr(or);
    const y = new ce(
      J(s),
      Le(s),
      x(s)
    ), E = new _L(
      J(
        ot(y)
      )
    ), I = O(E);
    return I[l] = Te(u), E;
  }
  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.map */
  map(e, ...n) {
    R2(this);
    const s = O(this), o = x(s), a = n[0], l = Mt(s, _L);
    if (l === _L) {
      const y = new _L(o), E = O(y);
      for (let I = 0; I < o; ++I) {
        const U2 = M(s[I]);
        E[I] = Te(
          ie(e, a, [U2, I, this])
        );
      }
      return y;
    }
    const u = new l(o);
    Pt(u, o);
    for (let y = 0; y < o; ++y) {
      const E = M(s[y]);
      u[y] = ie(e, a, [E, y, this]);
    }
    return (
      /** @type {any} */
      u
    );
  }
  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.filter */
  filter(e, ...n) {
    R2(this);
    const s = O(this), o = x(s), a = n[0], l = [];
    for (let E = 0; E < o; ++E) {
      const I = M(s[E]);
      ie(e, a, [I, E, this]) && Ki(l, I);
    }
    const u = Mt(s, _L), y = new u(l);
    return Pt(y), /** @type {any} */
    y;
  }
  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.reduce */
  reduce(e, ...n) {
    R2(this);
    const s = O(this), o = x(s);
    if (o === 0 && n.length === 0)
      throw X2(Yr);
    let a, l;
    n.length === 0 ? (a = M(s[0]), l = 1) : (a = n[0], l = 0);
    for (let u = l; u < o; ++u)
      a = e(
        a,
        M(s[u]),
        u,
        this
      );
    return a;
  }
  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.reduceright */
  reduceRight(e, ...n) {
    R2(this);
    const s = O(this), o = x(s);
    if (o === 0 && n.length === 0)
      throw X2(Yr);
    let a, l;
    n.length === 0 ? (a = M(s[o - 1]), l = o - 2) : (a = n[0], l = o - 1);
    for (let u = l; u >= 0; --u)
      a = e(
        a,
        M(s[u]),
        u,
        this
      );
    return a;
  }
  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.foreach */
  forEach(e, ...n) {
    R2(this);
    const s = O(this), o = x(s), a = n[0];
    for (let l = 0; l < o; ++l)
      ie(e, a, [
        M(s[l]),
        l,
        this
      ]);
  }
  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.find */
  find(e, ...n) {
    R2(this);
    const s = O(this), o = x(s), a = n[0];
    for (let l = 0; l < o; ++l) {
      const u = M(s[l]);
      if (ie(e, a, [u, l, this]))
        return u;
    }
  }
  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.findindex */
  findIndex(e, ...n) {
    R2(this);
    const s = O(this), o = x(s), a = n[0];
    for (let l = 0; l < o; ++l) {
      const u = M(s[l]);
      if (ie(e, a, [u, l, this]))
        return l;
    }
    return -1;
  }
  /** @see https://tc39.es/proposal-array-find-from-last/index.html#sec-%typedarray%.prototype.findlast */
  findLast(e, ...n) {
    R2(this);
    const s = O(this), o = x(s), a = n[0];
    for (let l = o - 1; l >= 0; --l) {
      const u = M(s[l]);
      if (ie(e, a, [u, l, this]))
        return u;
    }
  }
  /** @see https://tc39.es/proposal-array-find-from-last/index.html#sec-%typedarray%.prototype.findlastindex */
  findLastIndex(e, ...n) {
    R2(this);
    const s = O(this), o = x(s), a = n[0];
    for (let l = o - 1; l >= 0; --l) {
      const u = M(s[l]);
      if (ie(e, a, [u, l, this]))
        return l;
    }
    return -1;
  }
  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.every */
  every(e, ...n) {
    R2(this);
    const s = O(this), o = x(s), a = n[0];
    for (let l = 0; l < o; ++l)
      if (!ie(e, a, [
        M(s[l]),
        l,
        this
      ]))
        return false;
    return true;
  }
  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.some */
  some(e, ...n) {
    R2(this);
    const s = O(this), o = x(s), a = n[0];
    for (let l = 0; l < o; ++l)
      if (ie(e, a, [
        M(s[l]),
        l,
        this
      ]))
        return true;
    return false;
  }
  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.set */
  set(e, ...n) {
    R2(this);
    const s = O(this), o = me(n[0]);
    if (o < 0)
      throw cr(or);
    if (e == null)
      throw X2(
        yr
      );
    if (Ar(e))
      throw X2(
        pr
      );
    if (Xe(e))
      return fs(
        O(this),
        O(e),
        o
      );
    if (Gt(e)) {
      const y = J(e);
      if (yt(y))
        throw X2(vt);
    }
    const a = x(s), l = Ve(e), u = lr(l.length);
    if (o === 1 / 0 || u + o > a)
      throw cr(or);
    for (let y = 0; y < u; ++y)
      s[y + o] = Te(l[y]);
  }
  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.reverse */
  reverse() {
    R2(this);
    const e = O(this);
    return Qr(e), this;
  }
  /** @see https://tc39.es/proposal-change-array-by-copy/#sec-%typedarray%.prototype.toReversed */
  toReversed() {
    R2(this);
    const e = O(this), n = new ce(
      J(e),
      Le(e),
      x(e)
    ), s = new _L(
      J(
        ot(n)
      )
    ), o = O(s);
    return Qr(o), s;
  }
  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.fill */
  fill(e, ...n) {
    R2(this);
    const s = O(this);
    return vs(
      s,
      Te(e),
      ...ut(n)
    ), this;
  }
  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.copywithin */
  copyWithin(e, n, ...s) {
    R2(this);
    const o = O(this);
    return ys(o, e, n, ...ut(s)), this;
  }
  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.sort */
  sort(e) {
    R2(this);
    const n = O(this), s = e !== void 0 ? e : sn;
    return jr(n, (o, a) => s(M(o), M(a))), this;
  }
  /** @see https://tc39.es/proposal-change-array-by-copy/#sec-%typedarray%.prototype.toSorted */
  toSorted(e) {
    R2(this);
    const n = O(this);
    if (e !== void 0 && typeof e != "function")
      throw new X2(Xi);
    const s = e !== void 0 ? e : sn, o = new ce(
      J(n),
      Le(n),
      x(n)
    ), a = new _L(
      J(
        ot(o)
      )
    ), l = O(a);
    return jr(l, (u, y) => s(M(u), M(y))), a;
  }
  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.slice */
  slice(e, n) {
    R2(this);
    const s = O(this), o = Mt(s, _L);
    if (o === _L) {
      const Ze = new ce(
        J(s),
        Le(s),
        x(s)
      );
      return new _L(
        J(
          ot(Ze, e, n)
        )
      );
    }
    const a = x(s), l = me(e), u = n === void 0 ? a : me(n);
    let y;
    l === -1 / 0 ? y = 0 : l < 0 ? y = a + l > 0 ? a + l : 0 : y = a < l ? a : l;
    let E;
    u === -1 / 0 ? E = 0 : u < 0 ? E = a + u > 0 ? a + u : 0 : E = a < u ? a : u;
    const I = E - y > 0 ? E - y : 0, U2 = new o(I);
    if (Pt(U2, I), I === 0)
      return U2;
    const q3 = J(s);
    if (yt(q3))
      throw X2(vt);
    let se = 0;
    for (; y < E; )
      U2[se] = M(s[y]), ++y, ++se;
    return (
      /** @type {any} */
      U2
    );
  }
  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.subarray */
  subarray(e, n) {
    R2(this);
    const s = O(this), o = Mt(s, _L), a = new ce(
      J(s),
      Le(s),
      x(s)
    ), l = ps(a, e, n), u = new o(
      J(l),
      Le(l),
      x(l)
    );
    return Pt(u), /** @type {any} */
    u;
  }
  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.indexof */
  indexOf(e, ...n) {
    R2(this);
    const s = O(this), o = x(s);
    let a = me(n[0]);
    if (a === 1 / 0)
      return -1;
    a < 0 && (a += o, a < 0 && (a = 0));
    for (let l = a; l < o; ++l)
      if (Ce(s, l) && M(s[l]) === e)
        return l;
    return -1;
  }
  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.lastindexof */
  lastIndexOf(e, ...n) {
    R2(this);
    const s = O(this), o = x(s);
    let a = n.length >= 1 ? me(n[0]) : o - 1;
    if (a === -1 / 0)
      return -1;
    a >= 0 ? a = a < o - 1 ? a : o - 1 : a += o;
    for (let l = a; l >= 0; --l)
      if (Ce(s, l) && M(s[l]) === e)
        return l;
    return -1;
  }
  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.includes */
  includes(e, ...n) {
    R2(this);
    const s = O(this), o = x(s);
    let a = me(n[0]);
    if (a === 1 / 0)
      return false;
    a < 0 && (a += o, a < 0 && (a = 0));
    const l = qe(e);
    for (let u = a; u < o; ++u) {
      const y = M(s[u]);
      if (l && qe(y) || y === e)
        return true;
    }
    return false;
  }
  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.join */
  join(e) {
    R2(this);
    const n = O(this), s = on(n);
    return ji(s, e);
  }
  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.tolocalestring */
  toLocaleString(...e) {
    R2(this);
    const n = O(this), s = on(n);
    return es(s, ...ut(e));
  }
  /** @see https://tc39.es/ecma262/#sec-get-%typedarray%.prototype-@@tostringtag */
  get [Ir]() {
    if (Xe(this))
      return (
        /** @type {any} */
        "Float16Array"
      );
  }
};
St(L, "BYTES_PER_ELEMENT", {
  value: Cr
});
St(L, Wt, {});
pn(L, br);
var Yt = L.prototype;
St(Yt, "BYTES_PER_ELEMENT", {
  value: Cr
});
St(Yt, Ie, {
  value: Yt.values,
  writable: true,
  configurable: true
});
pn(Yt, Q);
function Ps(r, e, ...n) {
  return M(
    Es(r, e, ...ut(n))
  );
}
function wo(r) {
  return r instanceof Int8Array || r instanceof Uint8Array || r instanceof Uint8ClampedArray || r instanceof Int16Array || r instanceof Uint16Array || r instanceof Int32Array || r instanceof Uint32Array || r instanceof L || r instanceof Float32Array || r instanceof Float64Array;
}
var Bs = class extends Loader {
  constructor(e, n) {
    super(n), this.parser = e;
  }
  load(e, n, s, o) {
    const a = new Bi(this.manager);
    a.setRequestHeader(this.requestHeader), a.setPath(this.path), a.setWithCredentials(this.withCredentials), a.load(
      e,
      (l) => {
        try {
          n(this.parser(l));
        } catch (u) {
          o != null ? o(u) : console.error(u), this.manager.itemError(e);
        }
      },
      s,
      o
    );
  }
};
function Ds(r) {
  const e = r instanceof Int8Array ? ByteType : r instanceof Uint8Array ? UnsignedByteType : r instanceof Uint8ClampedArray ? UnsignedByteType : r instanceof Int16Array ? ShortType : r instanceof Uint16Array ? UnsignedShortType : r instanceof Int32Array ? IntType : r instanceof Uint32Array ? UnsignedIntType : r instanceof L ? HalfFloatType : r instanceof Float32Array ? FloatType : r instanceof Float64Array ? FloatType : null;
  return R(e != null), e;
}
var Ls = class extends Loader {
  constructor(e, n, s = {}, o) {
    super(o), this.textureClass = e, this.parser = n, this.options = {
      format: RGBAFormat,
      minFilter: LinearFilter,
      magFilter: LinearFilter,
      ...s
    };
  }
  load(e, n, s, o) {
    const a = new this.textureClass(), l = new Bs(this.parser, this.manager);
    return l.setRequestHeader(this.requestHeader), l.setPath(this.path), l.setWithCredentials(this.withCredentials), l.load(
      e,
      (u) => {
        a.image.data = u instanceof L ? new Uint16Array(u.buffer) : u;
        const { width: y, height: E, depth: I, ...U2 } = this.options;
        y != null && (a.image.width = y), E != null && (a.image.height = E), "depth" in a.image && I != null && (a.image.depth = I), a.type = Ds(u), Object.assign(a, U2), a.needsUpdate = true, n == null || n(a);
      },
      s,
      o
    ), a;
  }
};
var $e = MathUtils.clamp;
var go = MathUtils.euclideanModulo;
var Ao = MathUtils.inverseLerp;
var So = MathUtils.lerp;
var Eo = MathUtils.degToRad;
var To = MathUtils.radToDeg;
var Io = MathUtils.isPowerOfTwo;
var _o = MathUtils.ceilPowerOfTwo;
var bo = MathUtils.floorPowerOfTwo;
var No = MathUtils.normalize;
function Oo(r, e, n, s = 0, o = 1) {
  return MathUtils.mapLinear(r, e, n, s, o);
}
function Uo(r, e, n, s = 0, o = 1) {
  return $e(MathUtils.mapLinear(r, e, n, s, o), s, o);
}
function mo(r, e, n) {
  return n <= r ? 0 : n >= e ? 1 : (n = (n - r) / (e - r), n * n * (3 - 2 * n));
}
function Co(r) {
  return Math.min(Math.max(r, 0), 1);
}
function Ro(r, e, n, s = n) {
  const o = Math.abs(r - e);
  return o <= s || o <= n * Math.max(Math.abs(r), Math.abs(e));
}
function xo(r) {
  return (e, n) => {
    e instanceof Material ? Object.defineProperty(e, n, {
      enumerable: true,
      get() {
        var s;
        return ((s = this.defines) == null ? void 0 : s[r]) != null;
      },
      set(s) {
        var o;
        s !== this[n] && (s ? (this.defines ?? (this.defines = {}), this.defines[r] = "1") : (o = this.defines) == null || delete o[r], this.needsUpdate = true);
      }
    }) : Object.defineProperty(e, n, {
      enumerable: true,
      get() {
        return this.defines.has(r);
      },
      set(s) {
        s !== this[n] && (s ? this.defines.set(r, "1") : this.defines.delete(r), this.setChanged());
      }
    });
  };
}
function Fo(r, {
  min: e = Number.MIN_SAFE_INTEGER,
  max: n = Number.MAX_SAFE_INTEGER
} = {}) {
  return (s, o) => {
    s instanceof Material ? Object.defineProperty(s, o, {
      enumerable: true,
      get() {
        var l;
        const a = (l = this.defines) == null ? void 0 : l[r];
        return a != null ? parseInt(a) : 0;
      },
      set(a) {
        const l = this[o];
        a !== l && (this.defines ?? (this.defines = {}), this.defines[r] = $e(a, e, n).toFixed(0), this.needsUpdate = true);
      }
    }) : Object.defineProperty(s, o, {
      enumerable: true,
      get() {
        const a = this.defines.get(r);
        return a != null ? parseInt(a) : 0;
      },
      set(a) {
        const l = this[o];
        a !== l && (this.defines.set(r, $e(a, e, n).toFixed(0)), this.setChanged());
      }
    });
  };
}
function Mo(r, {
  min: e = -1 / 0,
  max: n = 1 / 0,
  precision: s = 7
} = {}) {
  return (o, a) => {
    o instanceof Material ? Object.defineProperty(o, a, {
      enumerable: true,
      get() {
        var u;
        const l = (u = this.defines) == null ? void 0 : u[r];
        return l != null ? parseFloat(l) : 0;
      },
      set(l) {
        const u = this[a];
        l !== u && (this.defines ?? (this.defines = {}), this.defines[r] = $e(l, e, n).toFixed(s), this.needsUpdate = true);
      }
    }) : Object.defineProperty(o, a, {
      enumerable: true,
      get() {
        const l = this.defines.get(r);
        return l != null ? parseFloat(l) : 0;
      },
      set(l) {
        const u = this[a];
        l !== u && (this.defines.set(r, $e(l, e, n).toFixed(s)), this.setChanged());
      }
    });
  };
}
function Po(r, { validate: e } = {}) {
  return (n, s) => {
    n instanceof Material ? Object.defineProperty(n, s, {
      enumerable: true,
      get() {
        var o;
        return ((o = this.defines) == null ? void 0 : o[r]) ?? "";
      },
      set(o) {
        if (o !== this[s]) {
          if ((e == null ? void 0 : e(o)) === false) {
            console.error(`Expression validation failed: ${o}`);
            return;
          }
          this.defines ?? (this.defines = {}), this.defines[r] = o, this.needsUpdate = true;
        }
      }
    }) : Object.defineProperty(n, s, {
      enumerable: true,
      get() {
        return this.defines.get(r) ?? "";
      },
      set(o) {
        if (o !== this[s]) {
          if ((e == null ? void 0 : e(o)) === false) {
            console.error(`Expression validation failed: ${o}`);
            return;
          }
          this.defines.set(r, o), this.setChanged();
        }
      }
    });
  };
}
function Bo(r, ...e) {
  const n = {};
  for (let s = 0; s < e.length; s += 2) {
    const o = e[s], a = e[s + 1];
    for (const l of a)
      n[l] = {
        enumerable: true,
        get: () => o[l],
        set: (u) => {
          o[l] = u;
        }
      };
  }
  return Object.defineProperties(r, n), r;
}
function Do(r, e, n) {
  const s = {};
  for (const o of n)
    s[o] = {
      enumerable: true,
      get: () => e.uniforms[o].value,
      set: (a) => {
        e.uniforms[o].value = a;
      }
    };
  return Object.defineProperties(r, s), r;
}
var zs = parseInt(REVISION.replace(/\D+/g, ""));
var ve = Uint8Array;
var Me = Uint16Array;
var Er = Uint32Array;
var Pn = new ve([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  0,
  /* unused */
  0,
  0,
  /* impossible */
  0
]);
var Bn = new ve([
  0,
  0,
  0,
  0,
  1,
  1,
  2,
  2,
  3,
  3,
  4,
  4,
  5,
  5,
  6,
  6,
  7,
  7,
  8,
  8,
  9,
  9,
  10,
  10,
  11,
  11,
  12,
  12,
  13,
  13,
  /* unused */
  0,
  0
]);
var ks = new ve([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
var Dn = function(r, e) {
  for (var n = new Me(31), s = 0; s < 31; ++s)
    n[s] = e += 1 << r[s - 1];
  for (var o = new Er(n[30]), s = 1; s < 30; ++s)
    for (var a = n[s]; a < n[s + 1]; ++a)
      o[a] = a - n[s] << 5 | s;
  return [n, o];
};
var Ln = Dn(Pn, 2);
var zn = Ln[0];
var Zs = Ln[1];
zn[28] = 258, Zs[258] = 28;
var Hs = Dn(Bn, 0);
var Gs = Hs[0];
var Tr = new Me(32768);
for (G2 = 0; G2 < 32768; ++G2) {
  Fe = (G2 & 43690) >>> 1 | (G2 & 21845) << 1;
  Fe = (Fe & 52428) >>> 2 | (Fe & 13107) << 2, Fe = (Fe & 61680) >>> 4 | (Fe & 3855) << 4, Tr[G2] = ((Fe & 65280) >>> 8 | (Fe & 255) << 8) >>> 1;
}
var Fe;
var G2;
var pt = function(r, e, n) {
  for (var s = r.length, o = 0, a = new Me(e); o < s; ++o)
    ++a[r[o] - 1];
  var l = new Me(e);
  for (o = 0; o < e; ++o)
    l[o] = l[o - 1] + a[o - 1] << 1;
  var u;
  if (n) {
    u = new Me(1 << e);
    var y = 15 - e;
    for (o = 0; o < s; ++o)
      if (r[o])
        for (var E = o << 4 | r[o], I = e - r[o], U2 = l[r[o] - 1]++ << I, q3 = U2 | (1 << I) - 1; U2 <= q3; ++U2)
          u[Tr[U2] >>> y] = E;
  } else
    for (u = new Me(s), o = 0; o < s; ++o)
      r[o] && (u[o] = Tr[l[r[o] - 1]++] >>> 15 - r[o]);
  return u;
};
var Et = new ve(288);
for (G2 = 0; G2 < 144; ++G2)
  Et[G2] = 8;
var G2;
for (G2 = 144; G2 < 256; ++G2)
  Et[G2] = 9;
var G2;
for (G2 = 256; G2 < 280; ++G2)
  Et[G2] = 7;
var G2;
for (G2 = 280; G2 < 288; ++G2)
  Et[G2] = 8;
var G2;
var kn = new ve(32);
for (G2 = 0; G2 < 32; ++G2)
  kn[G2] = 5;
var G2;
var Ws = pt(Et, 9, 1);
var Xs = pt(kn, 5, 1);
var hr = function(r) {
  for (var e = r[0], n = 1; n < r.length; ++n)
    r[n] > e && (e = r[n]);
  return e;
};
var we = function(r, e, n) {
  var s = e / 8 | 0;
  return (r[s] | r[s + 1] << 8) >> (e & 7) & n;
};
var ur = function(r, e) {
  var n = e / 8 | 0;
  return (r[n] | r[n + 1] << 8 | r[n + 2] << 16) >> (e & 7);
};
var Ys = function(r) {
  return (r / 8 | 0) + (r & 7 && 1);
};
var qs = function(r, e, n) {
  (n == null || n > r.length) && (n = r.length);
  var s = new (r instanceof Me ? Me : r instanceof Er ? Er : ve)(n - e);
  return s.set(r.subarray(e, n)), s;
};
var Vs = function(r, e, n) {
  var s = r.length;
  if (!s || n && !n.l && s < 5)
    return e || new ve(0);
  var o = !e || n, a = !n || n.i;
  n || (n = {}), e || (e = new ve(s * 3));
  var l = function(P2) {
    var be = e.length;
    if (P2 > be) {
      var Ne = new ve(Math.max(be * 2, P2));
      Ne.set(e), e = Ne;
    }
  }, u = n.f || 0, y = n.p || 0, E = n.b || 0, I = n.l, U2 = n.d, q3 = n.m, se = n.n, Ze = s * 8;
  do {
    if (!I) {
      n.f = u = we(r, y, 1);
      var Tt = we(r, y + 1, 3);
      if (y += 3, Tt)
        if (Tt == 1)
          I = Ws, U2 = Xs, q3 = 9, se = 5;
        else if (Tt == 2) {
          var bt = we(r, y, 31) + 257, er = we(r, y + 10, 15) + 4, tr = bt + we(r, y + 5, 31) + 1;
          y += 14;
          for (var He = new ve(tr), Nt = new ve(19), oe = 0; oe < er; ++oe)
            Nt[ks[oe]] = we(r, y + oe * 3, 7);
          y += er * 3;
          for (var Ot = hr(Nt), rr = (1 << Ot) - 1, nr = pt(Nt, Ot, 1), oe = 0; oe < tr; ) {
            var le = nr[we(r, y, rr)];
            y += le & 15;
            var pe = le >>> 4;
            if (pe < 16)
              He[oe++] = pe;
            else {
              var _e = 0, Ae = 0;
              for (pe == 16 ? (Ae = 3 + we(r, y, 3), y += 2, _e = He[oe - 1]) : pe == 17 ? (Ae = 3 + we(r, y, 7), y += 3) : pe == 18 && (Ae = 11 + we(r, y, 127), y += 7); Ae--; )
                He[oe++] = _e;
            }
          }
          var Ut = He.subarray(0, bt), Se = He.subarray(bt);
          q3 = hr(Ut), se = hr(Se), I = pt(Ut, q3, 1), U2 = pt(Se, se, 1);
        } else
          throw "invalid block type";
      else {
        var pe = Ys(y) + 4, It = r[pe - 4] | r[pe - 3] << 8, _t = pe + It;
        if (_t > s) {
          if (a)
            throw "unexpected EOF";
          break;
        }
        o && l(E + It), e.set(r.subarray(pe, _t), E), n.b = E += It, n.p = y = _t * 8;
        continue;
      }
      if (y > Ze) {
        if (a)
          throw "unexpected EOF";
        break;
      }
    }
    o && l(E + 131072);
    for (var mt = (1 << q3) - 1, Ct = (1 << se) - 1, je = y; ; je = y) {
      var _e = I[ur(r, y) & mt], ee = _e >>> 4;
      if (y += _e & 15, y > Ze) {
        if (a)
          throw "unexpected EOF";
        break;
      }
      if (!_e)
        throw "invalid length/literal";
      if (ee < 256)
        e[E++] = ee;
      else if (ee == 256) {
        je = y, I = null;
        break;
      } else {
        var Ge = ee - 254;
        if (ee > 264) {
          var oe = ee - 257, re = Pn[oe];
          Ge = we(r, y, (1 << re) - 1) + zn[oe], y += re;
        }
        var Pe = U2[ur(r, y) & Ct], Be = Pe >>> 4;
        if (!Pe)
          throw "invalid distance";
        y += Pe & 15;
        var Se = Gs[Be];
        if (Be > 3) {
          var re = Bn[Be];
          Se += ur(r, y) & (1 << re) - 1, y += re;
        }
        if (y > Ze) {
          if (a)
            throw "unexpected EOF";
          break;
        }
        o && l(E + 131072);
        for (var Ke = E + Ge; E < Ke; E += 4)
          e[E] = e[E - Se], e[E + 1] = e[E + 1 - Se], e[E + 2] = e[E + 2 - Se], e[E + 3] = e[E + 3 - Se];
        E = Ke;
      }
    }
    n.l = I, n.p = je, n.b = E, I && (u = 1, n.m = q3, n.d = U2, n.n = se);
  } while (!u);
  return E == e.length ? e : qs(e, 0, E);
};
var $s = new ve(0);
var Js = function(r) {
  if ((r[0] & 15) != 8 || r[0] >>> 4 > 7 || (r[0] << 8 | r[1]) % 31)
    throw "invalid zlib data";
  if (r[1] & 32)
    throw "invalid zlib data: preset dictionaries not supported";
};
function Bt(r, e) {
  return Vs((Js(r), r.subarray(2, -4)), e);
}
var Qs = typeof TextDecoder < "u" && new TextDecoder();
var js = 0;
try {
  Qs.decode($s, { stream: true }), js = 1;
} catch {
}
var at = zs >= 152;
var Zn = class extends DataTextureLoader {
  constructor(e) {
    super(e), this.type = HalfFloatType;
  }
  parse(e) {
    const Ot = Math.pow(2.7182818, 2.2);
    function rr(t, i) {
      for (var c = 0, h = 0; h < 65536; ++h)
        (h == 0 || t[h >> 3] & 1 << (h & 7)) && (i[c++] = h);
      for (var f = c - 1; c < 65536; )
        i[c++] = 0;
      return f;
    }
    function nr(t) {
      for (var i = 0; i < 16384; i++)
        t[i] = {}, t[i].len = 0, t[i].lit = 0, t[i].p = null;
    }
    const le = { l: 0, c: 0, lc: 0 };
    function _e(t, i, c, h, f) {
      for (; c < t; )
        i = i << 8 | Dr(h, f), c += 8;
      c -= t, le.l = i >> c & (1 << t) - 1, le.c = i, le.lc = c;
    }
    const Ae = new Array(59);
    function Ut(t) {
      for (var i = 0; i <= 58; ++i)
        Ae[i] = 0;
      for (var i = 0; i < 65537; ++i)
        Ae[t[i]] += 1;
      for (var c = 0, i = 58; i > 0; --i) {
        var h = c + Ae[i] >> 1;
        Ae[i] = c, c = h;
      }
      for (var i = 0; i < 65537; ++i) {
        var f = t[i];
        f > 0 && (t[i] = f | Ae[f]++ << 6);
      }
    }
    function Se(t, i, c, h, f, v, w) {
      for (var p = c, A2 = 0, g3 = 0; f <= v; f++) {
        if (p.value - c.value > h)
          return false;
        _e(6, A2, g3, t, p);
        var S = le.l;
        if (A2 = le.c, g3 = le.lc, w[f] = S, S == 63) {
          if (p.value - c.value > h)
            throw "Something wrong with hufUnpackEncTable";
          _e(8, A2, g3, t, p);
          var d = le.l + 6;
          if (A2 = le.c, g3 = le.lc, f + d > v + 1)
            throw "Something wrong with hufUnpackEncTable";
          for (; d--; )
            w[f++] = 0;
          f--;
        } else if (S >= 59) {
          var d = S - 59 + 2;
          if (f + d > v + 1)
            throw "Something wrong with hufUnpackEncTable";
          for (; d--; )
            w[f++] = 0;
          f--;
        }
      }
      Ut(w);
    }
    function mt(t) {
      return t & 63;
    }
    function Ct(t) {
      return t >> 6;
    }
    function je(t, i, c, h) {
      for (; i <= c; i++) {
        var f = Ct(t[i]), v = mt(t[i]);
        if (f >> v)
          throw "Invalid table entry";
        if (v > 14) {
          var w = h[f >> v - 14];
          if (w.len)
            throw "Invalid table entry";
          if (w.lit++, w.p) {
            var p = w.p;
            w.p = new Array(w.lit);
            for (var A2 = 0; A2 < w.lit - 1; ++A2)
              w.p[A2] = p[A2];
          } else
            w.p = new Array(1);
          w.p[w.lit - 1] = i;
        } else if (v)
          for (var g3 = 0, A2 = 1 << 14 - v; A2 > 0; A2--) {
            var w = h[(f << 14 - v) + g3];
            if (w.len || w.p)
              throw "Invalid table entry";
            w.len = v, w.lit = i, g3++;
          }
      }
      return true;
    }
    const ee = { c: 0, lc: 0 };
    function Ge(t, i, c, h) {
      t = t << 8 | Dr(c, h), i += 8, ee.c = t, ee.lc = i;
    }
    const re = { c: 0, lc: 0 };
    function Pe(t, i, c, h, f, v, w, p, A2, g3) {
      if (t == i) {
        h < 8 && (Ge(c, h, f, w), c = ee.c, h = ee.lc), h -= 8;
        var S = c >> h, S = new Uint8Array([S])[0];
        if (A2.value + S > g3)
          return false;
        for (var d = p[A2.value - 1]; S-- > 0; )
          p[A2.value++] = d;
      } else if (A2.value < g3)
        p[A2.value++] = t;
      else
        return false;
      re.c = c, re.lc = h;
    }
    function Be(t) {
      return t & 65535;
    }
    function Ke(t) {
      var i = Be(t);
      return i > 32767 ? i - 65536 : i;
    }
    const P2 = { a: 0, b: 0 };
    function be(t, i) {
      var c = Ke(t), h = Ke(i), f = h, v = c + (f & 1) + (f >> 1), w = v, p = v - f;
      P2.a = w, P2.b = p;
    }
    function Ne(t, i) {
      var c = Be(t), h = Be(i), f = c - (h >> 1) & 65535, v = h + f - 32768 & 65535;
      P2.a = v, P2.b = f;
    }
    function Xn(t, i, c, h, f, v, w) {
      for (var p = w < 16384, A2 = c > f ? f : c, g3 = 1, S; g3 <= A2; )
        g3 <<= 1;
      for (g3 >>= 1, S = g3, g3 >>= 1; g3 >= 1; ) {
        for (var d = 0, Y = d + v * (f - S), _ = v * g3, b2 = v * S, N2 = h * g3, m = h * S, B, z, V2, te; d <= Y; d += b2) {
          for (var k2 = d, Ee = d + h * (c - S); k2 <= Ee; k2 += m) {
            var H2 = k2 + N2, $ = k2 + _, Oe = $ + N2;
            p ? (be(t[k2 + i], t[$ + i]), B = P2.a, V2 = P2.b, be(t[H2 + i], t[Oe + i]), z = P2.a, te = P2.b, be(B, z), t[k2 + i] = P2.a, t[H2 + i] = P2.b, be(V2, te), t[$ + i] = P2.a, t[Oe + i] = P2.b) : (Ne(t[k2 + i], t[$ + i]), B = P2.a, V2 = P2.b, Ne(t[H2 + i], t[Oe + i]), z = P2.a, te = P2.b, Ne(B, z), t[k2 + i] = P2.a, t[H2 + i] = P2.b, Ne(V2, te), t[$ + i] = P2.a, t[Oe + i] = P2.b);
          }
          if (c & g3) {
            var $ = k2 + _;
            p ? be(t[k2 + i], t[$ + i]) : Ne(t[k2 + i], t[$ + i]), B = P2.a, t[$ + i] = P2.b, t[k2 + i] = B;
          }
        }
        if (f & g3)
          for (var k2 = d, Ee = d + h * (c - S); k2 <= Ee; k2 += m) {
            var H2 = k2 + N2;
            p ? be(t[k2 + i], t[H2 + i]) : Ne(t[k2 + i], t[H2 + i]), B = P2.a, t[H2 + i] = P2.b, t[k2 + i] = B;
          }
        S = g3, g3 >>= 1;
      }
      return d;
    }
    function Yn(t, i, c, h, f, v, w, p, A2, g3) {
      for (var S = 0, d = 0, Y = p, _ = Math.trunc(f.value + (v + 7) / 8); f.value < _; )
        for (Ge(S, d, c, f), S = ee.c, d = ee.lc; d >= 14; ) {
          var b2 = S >> d - 14 & 16383, N2 = i[b2];
          if (N2.len)
            d -= N2.len, Pe(N2.lit, w, S, d, c, h, f, A2, g3, Y), S = re.c, d = re.lc;
          else {
            if (!N2.p)
              throw "hufDecode issues";
            var m;
            for (m = 0; m < N2.lit; m++) {
              for (var B = mt(t[N2.p[m]]); d < B && f.value < _; )
                Ge(S, d, c, f), S = ee.c, d = ee.lc;
              if (d >= B && Ct(t[N2.p[m]]) == (S >> d - B & (1 << B) - 1)) {
                d -= B, Pe(
                  N2.p[m],
                  w,
                  S,
                  d,
                  c,
                  h,
                  f,
                  A2,
                  g3,
                  Y
                ), S = re.c, d = re.lc;
                break;
              }
            }
            if (m == N2.lit)
              throw "hufDecode issues";
          }
        }
      var z = 8 - v & 7;
      for (S >>= z, d -= z; d > 0; ) {
        var N2 = i[S << 14 - d & 16383];
        if (N2.len)
          d -= N2.len, Pe(N2.lit, w, S, d, c, h, f, A2, g3, Y), S = re.c, d = re.lc;
        else
          throw "hufDecode issues";
      }
      return true;
    }
    function Rr(t, i, c, h, f, v) {
      var w = { value: 0 }, p = c.value, A2 = ne(i, c), g3 = ne(i, c);
      c.value += 4;
      var S = ne(i, c);
      if (c.value += 4, A2 < 0 || A2 >= 65537 || g3 < 0 || g3 >= 65537)
        throw "Something wrong with HUF_ENCSIZE";
      var d = new Array(65537), Y = new Array(16384);
      nr(Y);
      var _ = h - (c.value - p);
      if (Se(t, i, c, _, A2, g3, d), S > 8 * (h - (c.value - p)))
        throw "Something wrong with hufUncompress";
      je(d, A2, g3, Y), Yn(d, Y, t, i, c, S, g3, v, f, w);
    }
    function qn(t, i, c) {
      for (var h = 0; h < c; ++h)
        i[h] = t[i[h]];
    }
    function xr(t) {
      for (var i = 1; i < t.length; i++) {
        var c = t[i - 1] + t[i] - 128;
        t[i] = c;
      }
    }
    function Fr(t, i) {
      for (var c = 0, h = Math.floor((t.length + 1) / 2), f = 0, v = t.length - 1; !(f > v || (i[f++] = t[c++], f > v)); )
        i[f++] = t[h++];
    }
    function Mr(t) {
      for (var i = t.byteLength, c = new Array(), h = 0, f = new DataView(t); i > 0; ) {
        var v = f.getInt8(h++);
        if (v < 0) {
          var w = -v;
          i -= w + 1;
          for (var p = 0; p < w; p++)
            c.push(f.getUint8(h++));
        } else {
          var w = v;
          i -= 2;
          for (var A2 = f.getUint8(h++), p = 0; p < w + 1; p++)
            c.push(A2);
        }
      }
      return c;
    }
    function Vn(t, i, c, h, f, v) {
      var H2 = new DataView(v.buffer), w = c[t.idx[0]].width, p = c[t.idx[0]].height, A2 = 3, g3 = Math.floor(w / 8), S = Math.ceil(w / 8), d = Math.ceil(p / 8), Y = w - (S - 1) * 8, _ = p - (d - 1) * 8, b2 = { value: 0 }, N2 = new Array(A2), m = new Array(A2), B = new Array(A2), z = new Array(A2), V2 = new Array(A2);
      for (let D2 = 0; D2 < A2; ++D2)
        V2[D2] = i[t.idx[D2]], N2[D2] = D2 < 1 ? 0 : N2[D2 - 1] + S * d, m[D2] = new Float32Array(64), B[D2] = new Uint16Array(64), z[D2] = new Uint16Array(S * 64);
      for (let D2 = 0; D2 < d; ++D2) {
        var te = 8;
        D2 == d - 1 && (te = _);
        var k2 = 8;
        for (let W = 0; W < S; ++W) {
          W == S - 1 && (k2 = Y);
          for (let F = 0; F < A2; ++F)
            B[F].fill(0), B[F][0] = f[N2[F]++], $n(b2, h, B[F]), Jn(B[F], m[F]), Qn(m[F]);
          jn(m);
          for (let F = 0; F < A2; ++F)
            Kn(m[F], z[F], W * 64);
        }
        let K = 0;
        for (let W = 0; W < A2; ++W) {
          const F = c[t.idx[W]].type;
          for (let fe = 8 * D2; fe < 8 * D2 + te; ++fe) {
            K = V2[W][fe];
            for (let De = 0; De < g3; ++De) {
              const ae = De * 64 + (fe & 7) * 8;
              H2.setUint16(K + 0 * F, z[W][ae + 0], true), H2.setUint16(K + 2 * F, z[W][ae + 1], true), H2.setUint16(K + 4 * F, z[W][ae + 2], true), H2.setUint16(K + 6 * F, z[W][ae + 3], true), H2.setUint16(K + 8 * F, z[W][ae + 4], true), H2.setUint16(K + 10 * F, z[W][ae + 5], true), H2.setUint16(K + 12 * F, z[W][ae + 6], true), H2.setUint16(K + 14 * F, z[W][ae + 7], true), K += 16 * F;
            }
          }
          if (g3 != S)
            for (let fe = 8 * D2; fe < 8 * D2 + te; ++fe) {
              const De = V2[W][fe] + 8 * g3 * 2 * F, ae = g3 * 64 + (fe & 7) * 8;
              for (let xe = 0; xe < k2; ++xe)
                H2.setUint16(De + xe * 2 * F, z[W][ae + xe], true);
            }
        }
      }
      for (var Ee = new Uint16Array(w), H2 = new DataView(v.buffer), $ = 0; $ < A2; ++$) {
        c[t.idx[$]].decoded = true;
        var Oe = c[t.idx[$]].type;
        if (c[$].type == 2)
          for (var it = 0; it < p; ++it) {
            const D2 = V2[$][it];
            for (var ue = 0; ue < w; ++ue)
              Ee[ue] = H2.getUint16(D2 + ue * 2 * Oe, true);
            for (var ue = 0; ue < w; ++ue)
              H2.setFloat32(D2 + ue * 2 * Oe, T(Ee[ue]), true);
          }
      }
    }
    function $n(t, i, c) {
      for (var h, f = 1; f < 64; )
        h = i[t.value], h == 65280 ? f = 64 : h >> 8 == 255 ? f += h & 255 : (c[f] = h, f++), t.value++;
    }
    function Jn(t, i) {
      i[0] = T(t[0]), i[1] = T(t[1]), i[2] = T(t[5]), i[3] = T(t[6]), i[4] = T(t[14]), i[5] = T(t[15]), i[6] = T(t[27]), i[7] = T(t[28]), i[8] = T(t[2]), i[9] = T(t[4]), i[10] = T(t[7]), i[11] = T(t[13]), i[12] = T(t[16]), i[13] = T(t[26]), i[14] = T(t[29]), i[15] = T(t[42]), i[16] = T(t[3]), i[17] = T(t[8]), i[18] = T(t[12]), i[19] = T(t[17]), i[20] = T(t[25]), i[21] = T(t[30]), i[22] = T(t[41]), i[23] = T(t[43]), i[24] = T(t[9]), i[25] = T(t[11]), i[26] = T(t[18]), i[27] = T(t[24]), i[28] = T(t[31]), i[29] = T(t[40]), i[30] = T(t[44]), i[31] = T(t[53]), i[32] = T(t[10]), i[33] = T(t[19]), i[34] = T(t[23]), i[35] = T(t[32]), i[36] = T(t[39]), i[37] = T(t[45]), i[38] = T(t[52]), i[39] = T(t[54]), i[40] = T(t[20]), i[41] = T(t[22]), i[42] = T(t[33]), i[43] = T(t[38]), i[44] = T(t[46]), i[45] = T(t[51]), i[46] = T(t[55]), i[47] = T(t[60]), i[48] = T(t[21]), i[49] = T(t[34]), i[50] = T(t[37]), i[51] = T(t[47]), i[52] = T(t[50]), i[53] = T(t[56]), i[54] = T(t[59]), i[55] = T(t[61]), i[56] = T(t[35]), i[57] = T(t[36]), i[58] = T(t[48]), i[59] = T(t[49]), i[60] = T(t[57]), i[61] = T(t[58]), i[62] = T(t[62]), i[63] = T(t[63]);
    }
    function Qn(t) {
      const i = 0.5 * Math.cos(0.7853975), c = 0.5 * Math.cos(3.14159 / 16), h = 0.5 * Math.cos(3.14159 / 8), f = 0.5 * Math.cos(3 * 3.14159 / 16), v = 0.5 * Math.cos(5 * 3.14159 / 16), w = 0.5 * Math.cos(3 * 3.14159 / 8), p = 0.5 * Math.cos(7 * 3.14159 / 16);
      for (var A2 = new Array(4), g3 = new Array(4), S = new Array(4), d = new Array(4), Y = 0; Y < 8; ++Y) {
        var _ = Y * 8;
        A2[0] = h * t[_ + 2], A2[1] = w * t[_ + 2], A2[2] = h * t[_ + 6], A2[3] = w * t[_ + 6], g3[0] = c * t[_ + 1] + f * t[_ + 3] + v * t[_ + 5] + p * t[_ + 7], g3[1] = f * t[_ + 1] - p * t[_ + 3] - c * t[_ + 5] - v * t[_ + 7], g3[2] = v * t[_ + 1] - c * t[_ + 3] + p * t[_ + 5] + f * t[_ + 7], g3[3] = p * t[_ + 1] - v * t[_ + 3] + f * t[_ + 5] - c * t[_ + 7], S[0] = i * (t[_ + 0] + t[_ + 4]), S[3] = i * (t[_ + 0] - t[_ + 4]), S[1] = A2[0] + A2[3], S[2] = A2[1] - A2[2], d[0] = S[0] + S[1], d[1] = S[3] + S[2], d[2] = S[3] - S[2], d[3] = S[0] - S[1], t[_ + 0] = d[0] + g3[0], t[_ + 1] = d[1] + g3[1], t[_ + 2] = d[2] + g3[2], t[_ + 3] = d[3] + g3[3], t[_ + 4] = d[3] - g3[3], t[_ + 5] = d[2] - g3[2], t[_ + 6] = d[1] - g3[1], t[_ + 7] = d[0] - g3[0];
      }
      for (var b2 = 0; b2 < 8; ++b2)
        A2[0] = h * t[16 + b2], A2[1] = w * t[16 + b2], A2[2] = h * t[48 + b2], A2[3] = w * t[48 + b2], g3[0] = c * t[8 + b2] + f * t[24 + b2] + v * t[40 + b2] + p * t[56 + b2], g3[1] = f * t[8 + b2] - p * t[24 + b2] - c * t[40 + b2] - v * t[56 + b2], g3[2] = v * t[8 + b2] - c * t[24 + b2] + p * t[40 + b2] + f * t[56 + b2], g3[3] = p * t[8 + b2] - v * t[24 + b2] + f * t[40 + b2] - c * t[56 + b2], S[0] = i * (t[b2] + t[32 + b2]), S[3] = i * (t[b2] - t[32 + b2]), S[1] = A2[0] + A2[3], S[2] = A2[1] - A2[2], d[0] = S[0] + S[1], d[1] = S[3] + S[2], d[2] = S[3] - S[2], d[3] = S[0] - S[1], t[0 + b2] = d[0] + g3[0], t[8 + b2] = d[1] + g3[1], t[16 + b2] = d[2] + g3[2], t[24 + b2] = d[3] + g3[3], t[32 + b2] = d[3] - g3[3], t[40 + b2] = d[2] - g3[2], t[48 + b2] = d[1] - g3[1], t[56 + b2] = d[0] - g3[0];
    }
    function jn(t) {
      for (var i = 0; i < 64; ++i) {
        var c = t[0][i], h = t[1][i], f = t[2][i];
        t[0][i] = c + 1.5747 * f, t[1][i] = c - 0.1873 * h - 0.4682 * f, t[2][i] = c + 1.8556 * h;
      }
    }
    function Kn(t, i, c) {
      for (var h = 0; h < 64; ++h)
        i[c + h] = DataUtils.toHalfFloat(ei(t[h]));
    }
    function ei(t) {
      return t <= 1 ? Math.sign(t) * Math.pow(Math.abs(t), 2.2) : Math.sign(t) * Math.pow(Ot, Math.abs(t) - 1);
    }
    function Pr(t) {
      return new DataView(t.array.buffer, t.offset.value, t.size);
    }
    function ti(t) {
      var i = t.viewer.buffer.slice(t.offset.value, t.offset.value + t.size), c = new Uint8Array(Mr(i)), h = new Uint8Array(c.length);
      return xr(c), Fr(c, h), new DataView(h.buffer);
    }
    function ir(t) {
      var i = t.array.slice(t.offset.value, t.offset.value + t.size), c = Bt(i), h = new Uint8Array(c.length);
      return xr(c), Fr(c, h), new DataView(h.buffer);
    }
    function ri(t) {
      for (var i = t.viewer, c = { value: t.offset.value }, h = new Uint16Array(t.width * t.scanlineBlockSize * (t.channels * t.type)), f = new Uint8Array(8192), v = 0, w = new Array(t.channels), p = 0; p < t.channels; p++)
        w[p] = {}, w[p].start = v, w[p].end = w[p].start, w[p].nx = t.width, w[p].ny = t.lines, w[p].size = t.type, v += w[p].nx * w[p].ny * w[p].size;
      var A2 = tt(i, c), g3 = tt(i, c);
      if (g3 >= 8192)
        throw "Something is wrong with PIZ_COMPRESSION BITMAP_SIZE";
      if (A2 <= g3)
        for (var p = 0; p < g3 - A2 + 1; p++)
          f[p + A2] = We(i, c);
      var S = new Uint16Array(65536), d = rr(f, S), Y = ne(i, c);
      Rr(t.array, i, c, Y, h, v);
      for (var p = 0; p < t.channels; ++p)
        for (var _ = w[p], b2 = 0; b2 < w[p].size; ++b2)
          Xn(h, _.start + b2, _.nx, _.size, _.ny, _.nx * _.size, d);
      qn(S, h, v);
      for (var N2 = 0, m = new Uint8Array(h.buffer.byteLength), B = 0; B < t.lines; B++)
        for (var z = 0; z < t.channels; z++) {
          var _ = w[z], V2 = _.nx * _.size, te = new Uint8Array(h.buffer, _.end * 2, V2 * 2);
          m.set(te, N2), N2 += V2 * 2, _.end += V2;
        }
      return new DataView(m.buffer);
    }
    function ni(t) {
      var i = t.array.slice(t.offset.value, t.offset.value + t.size), c = Bt(i);
      const h = t.lines * t.channels * t.width, f = t.type == 1 ? new Uint16Array(h) : new Uint32Array(h);
      let v = 0, w = 0;
      const p = new Array(4);
      for (let A2 = 0; A2 < t.lines; A2++)
        for (let g3 = 0; g3 < t.channels; g3++) {
          let S = 0;
          switch (t.type) {
            case 1:
              p[0] = v, p[1] = p[0] + t.width, v = p[1] + t.width;
              for (let d = 0; d < t.width; ++d) {
                const Y = c[p[0]++] << 8 | c[p[1]++];
                S += Y, f[w] = S, w++;
              }
              break;
            case 2:
              p[0] = v, p[1] = p[0] + t.width, p[2] = p[1] + t.width, v = p[2] + t.width;
              for (let d = 0; d < t.width; ++d) {
                const Y = c[p[0]++] << 24 | c[p[1]++] << 16 | c[p[2]++] << 8;
                S += Y, f[w] = S, w++;
              }
              break;
          }
        }
      return new DataView(f.buffer);
    }
    function Br(t) {
      var i = t.viewer, c = { value: t.offset.value }, h = new Uint8Array(t.width * t.lines * (t.channels * t.type * 2)), f = {
        version: he(i, c),
        unknownUncompressedSize: he(i, c),
        unknownCompressedSize: he(i, c),
        acCompressedSize: he(i, c),
        dcCompressedSize: he(i, c),
        rleCompressedSize: he(i, c),
        rleUncompressedSize: he(i, c),
        rleRawSize: he(i, c),
        totalAcUncompressedCount: he(i, c),
        totalDcUncompressedCount: he(i, c),
        acCompression: he(i, c)
      };
      if (f.version < 2)
        throw "EXRLoader.parse: " + nt.compression + " version " + f.version + " is unsupported";
      for (var v = new Array(), w = tt(i, c) - 2; w > 0; ) {
        var p = Rt(i.buffer, c), A2 = We(i, c), g3 = A2 >> 2 & 3, S = (A2 >> 4) - 1, d = new Int8Array([S])[0], Y = We(i, c);
        v.push({
          name: p,
          index: d,
          type: Y,
          compression: g3
        }), w -= p.length + 3;
      }
      for (var _ = nt.channels, b2 = new Array(t.channels), N2 = 0; N2 < t.channels; ++N2) {
        var m = b2[N2] = {}, B = _[N2];
        m.name = B.name, m.compression = 0, m.decoded = false, m.type = B.pixelType, m.pLinear = B.pLinear, m.width = t.width, m.height = t.lines;
      }
      for (var z = {
        idx: new Array(3)
      }, V2 = 0; V2 < t.channels; ++V2)
        for (var m = b2[V2], N2 = 0; N2 < v.length; ++N2) {
          var te = v[N2];
          m.name == te.name && (m.compression = te.compression, te.index >= 0 && (z.idx[te.index] = V2), m.offset = V2);
        }
      if (f.acCompressedSize > 0)
        switch (f.acCompression) {
          case 0:
            var H2 = new Uint16Array(f.totalAcUncompressedCount);
            Rr(
              t.array,
              i,
              c,
              f.acCompressedSize,
              H2,
              f.totalAcUncompressedCount
            );
            break;
          case 1:
            var k2 = t.array.slice(c.value, c.value + f.totalAcUncompressedCount), Ee = Bt(k2), H2 = new Uint16Array(Ee.buffer);
            c.value += f.totalAcUncompressedCount;
            break;
        }
      if (f.dcCompressedSize > 0) {
        var $ = {
          array: t.array,
          offset: c,
          size: f.dcCompressedSize
        }, Oe = new Uint16Array(ir($).buffer);
        c.value += f.dcCompressedSize;
      }
      if (f.rleRawSize > 0) {
        var k2 = t.array.slice(c.value, c.value + f.rleCompressedSize), Ee = Bt(k2), it = Mr(Ee.buffer);
        c.value += f.rleCompressedSize;
      }
      for (var ue = 0, D2 = new Array(b2.length), N2 = 0; N2 < D2.length; ++N2)
        D2[N2] = new Array();
      for (var K = 0; K < t.lines; ++K)
        for (var W = 0; W < b2.length; ++W)
          D2[W].push(ue), ue += b2[W].width * t.type * 2;
      Vn(z, D2, b2, H2, Oe, h);
      for (var N2 = 0; N2 < b2.length; ++N2) {
        var m = b2[N2];
        if (!m.decoded)
          switch (m.compression) {
            case 2:
              for (var F = 0, fe = 0, K = 0; K < t.lines; ++K) {
                for (var De = D2[N2][F], ae = 0; ae < m.width; ++ae) {
                  for (var xe = 0; xe < 2 * m.type; ++xe)
                    h[De++] = it[fe + xe * m.width * m.height];
                  fe++;
                }
                F++;
              }
              break;
            case 1:
            default:
              throw "EXRLoader.parse: unsupported channel compression";
          }
      }
      return new DataView(h.buffer);
    }
    function Rt(t, i) {
      for (var c = new Uint8Array(t), h = 0; c[i.value + h] != 0; )
        h += 1;
      var f = new TextDecoder().decode(c.slice(i.value, i.value + h));
      return i.value = i.value + h + 1, f;
    }
    function ii(t, i, c) {
      var h = new TextDecoder().decode(new Uint8Array(t).slice(i.value, i.value + c));
      return i.value = i.value + c, h;
    }
    function si(t, i) {
      var c = et(t, i), h = ne(t, i);
      return [c, h];
    }
    function oi(t, i) {
      var c = ne(t, i), h = ne(t, i);
      return [c, h];
    }
    function et(t, i) {
      var c = t.getInt32(i.value, true);
      return i.value = i.value + 4, c;
    }
    function ne(t, i) {
      var c = t.getUint32(i.value, true);
      return i.value = i.value + 4, c;
    }
    function Dr(t, i) {
      var c = t[i.value];
      return i.value = i.value + 1, c;
    }
    function We(t, i) {
      var c = t.getUint8(i.value);
      return i.value = i.value + 1, c;
    }
    const he = function(t, i) {
      let c;
      return "getBigInt64" in DataView.prototype ? c = Number(t.getBigInt64(i.value, true)) : c = t.getUint32(i.value + 4, true) + Number(t.getUint32(i.value, true) << 32), i.value += 8, c;
    };
    function j(t, i) {
      var c = t.getFloat32(i.value, true);
      return i.value += 4, c;
    }
    function ai(t, i) {
      return DataUtils.toHalfFloat(j(t, i));
    }
    function T(t) {
      var i = (t & 31744) >> 10, c = t & 1023;
      return (t >> 15 ? -1 : 1) * (i ? i === 31 ? c ? NaN : 1 / 0 : Math.pow(2, i - 15) * (1 + c / 1024) : 6103515625e-14 * (c / 1024));
    }
    function tt(t, i) {
      var c = t.getUint16(i.value, true);
      return i.value += 2, c;
    }
    function ci(t, i) {
      return T(tt(t, i));
    }
    function li(t, i, c, h) {
      for (var f = c.value, v = []; c.value < f + h - 1; ) {
        var w = Rt(i, c), p = et(t, c), A2 = We(t, c);
        c.value += 3;
        var g3 = et(t, c), S = et(t, c);
        v.push({
          name: w,
          pixelType: p,
          pLinear: A2,
          xSampling: g3,
          ySampling: S
        });
      }
      return c.value += 1, v;
    }
    function hi(t, i) {
      var c = j(t, i), h = j(t, i), f = j(t, i), v = j(t, i), w = j(t, i), p = j(t, i), A2 = j(t, i), g3 = j(t, i);
      return {
        redX: c,
        redY: h,
        greenX: f,
        greenY: v,
        blueX: w,
        blueY: p,
        whiteX: A2,
        whiteY: g3
      };
    }
    function ui(t, i) {
      var c = [
        "NO_COMPRESSION",
        "RLE_COMPRESSION",
        "ZIPS_COMPRESSION",
        "ZIP_COMPRESSION",
        "PIZ_COMPRESSION",
        "PXR24_COMPRESSION",
        "B44_COMPRESSION",
        "B44A_COMPRESSION",
        "DWAA_COMPRESSION",
        "DWAB_COMPRESSION"
      ], h = We(t, i);
      return c[h];
    }
    function fi(t, i) {
      var c = ne(t, i), h = ne(t, i), f = ne(t, i), v = ne(t, i);
      return { xMin: c, yMin: h, xMax: f, yMax: v };
    }
    function vi(t, i) {
      var c = ["INCREASING_Y"], h = We(t, i);
      return c[h];
    }
    function yi(t, i) {
      var c = j(t, i), h = j(t, i);
      return [c, h];
    }
    function pi(t, i) {
      var c = j(t, i), h = j(t, i), f = j(t, i);
      return [c, h, f];
    }
    function wi(t, i, c, h, f) {
      if (h === "string" || h === "stringvector" || h === "iccProfile")
        return ii(i, c, f);
      if (h === "chlist")
        return li(t, i, c, f);
      if (h === "chromaticities")
        return hi(t, c);
      if (h === "compression")
        return ui(t, c);
      if (h === "box2i")
        return fi(t, c);
      if (h === "lineOrder")
        return vi(t, c);
      if (h === "float")
        return j(t, c);
      if (h === "v2f")
        return yi(t, c);
      if (h === "v3f")
        return pi(t, c);
      if (h === "int")
        return et(t, c);
      if (h === "rational")
        return si(t, c);
      if (h === "timecode")
        return oi(t, c);
      if (h === "preview")
        return c.value += f, "skipped";
      c.value += f;
    }
    function di(t, i, c) {
      const h = {};
      if (t.getUint32(0, true) != 20000630)
        throw "THREE.EXRLoader: provided file doesn't appear to be in OpenEXR format.";
      h.version = t.getUint8(4);
      const f = t.getUint8(5);
      h.spec = {
        singleTile: !!(f & 2),
        longName: !!(f & 4),
        deepFormat: !!(f & 8),
        multiPart: !!(f & 16)
      }, c.value = 8;
      for (var v = true; v; ) {
        var w = Rt(i, c);
        if (w == 0)
          v = false;
        else {
          var p = Rt(i, c), A2 = ne(t, c), g3 = wi(t, i, c, p, A2);
          g3 === void 0 ? console.warn(`EXRLoader.parse: skipped unknown header attribute type '${p}'.`) : h[w] = g3;
        }
      }
      if ((f & -5) != 0)
        throw console.error("EXRHeader:", h), "THREE.EXRLoader: provided file is currently unsupported.";
      return h;
    }
    function gi(t, i, c, h, f) {
      const v = {
        size: 0,
        viewer: i,
        array: c,
        offset: h,
        width: t.dataWindow.xMax - t.dataWindow.xMin + 1,
        height: t.dataWindow.yMax - t.dataWindow.yMin + 1,
        channels: t.channels.length,
        bytesPerLine: null,
        lines: null,
        inputSize: null,
        type: t.channels[0].pixelType,
        uncompress: null,
        getter: null,
        format: null,
        [at ? "colorSpace" : "encoding"]: null
      };
      switch (t.compression) {
        case "NO_COMPRESSION":
          v.lines = 1, v.uncompress = Pr;
          break;
        case "RLE_COMPRESSION":
          v.lines = 1, v.uncompress = ti;
          break;
        case "ZIPS_COMPRESSION":
          v.lines = 1, v.uncompress = ir;
          break;
        case "ZIP_COMPRESSION":
          v.lines = 16, v.uncompress = ir;
          break;
        case "PIZ_COMPRESSION":
          v.lines = 32, v.uncompress = ri;
          break;
        case "PXR24_COMPRESSION":
          v.lines = 16, v.uncompress = ni;
          break;
        case "DWAA_COMPRESSION":
          v.lines = 32, v.uncompress = Br;
          break;
        case "DWAB_COMPRESSION":
          v.lines = 256, v.uncompress = Br;
          break;
        default:
          throw "EXRLoader.parse: " + t.compression + " is unsupported";
      }
      if (v.scanlineBlockSize = v.lines, v.type == 1)
        switch (f) {
          case FloatType:
            v.getter = ci, v.inputSize = 2;
            break;
          case HalfFloatType:
            v.getter = tt, v.inputSize = 2;
            break;
        }
      else if (v.type == 2)
        switch (f) {
          case FloatType:
            v.getter = j, v.inputSize = 4;
            break;
          case HalfFloatType:
            v.getter = ai, v.inputSize = 4;
        }
      else
        throw "EXRLoader.parse: unsupported pixelType " + v.type + " for " + t.compression + ".";
      v.blockCount = (t.dataWindow.yMax + 1) / v.scanlineBlockSize;
      for (var w = 0; w < v.blockCount; w++)
        he(i, h);
      v.outputChannels = v.channels == 3 ? 4 : v.channels;
      const p = v.width * v.height * v.outputChannels;
      switch (f) {
        case FloatType:
          v.byteArray = new Float32Array(p), v.channels < v.outputChannels && v.byteArray.fill(1, 0, p);
          break;
        case HalfFloatType:
          v.byteArray = new Uint16Array(p), v.channels < v.outputChannels && v.byteArray.fill(15360, 0, p);
          break;
        default:
          console.error("THREE.EXRLoader: unsupported type: ", f);
          break;
      }
      return v.bytesPerLine = v.width * v.inputSize * v.channels, v.outputChannels == 4 ? v.format = RGBAFormat : v.format = RedFormat, at ? v.colorSpace = "srgb-linear" : v.encoding = 3e3, v;
    }
    const xt = new DataView(e), Ai = new Uint8Array(e), rt = { value: 0 }, nt = di(xt, e, rt), C2 = gi(nt, xt, Ai, rt, this.type), Lr = { value: 0 }, Si = { R: 0, G: 1, B: 2, A: 3, Y: 0 };
    for (let t = 0; t < C2.height / C2.scanlineBlockSize; t++) {
      const i = ne(xt, rt);
      C2.size = ne(xt, rt), C2.lines = i + C2.scanlineBlockSize > C2.height ? C2.height - i : C2.scanlineBlockSize;
      const h = C2.size < C2.lines * C2.bytesPerLine ? C2.uncompress(C2) : Pr(C2);
      rt.value += C2.size;
      for (let f = 0; f < C2.scanlineBlockSize; f++) {
        const v = f + t * C2.scanlineBlockSize;
        if (v >= C2.height)
          break;
        for (let w = 0; w < C2.channels; w++) {
          const p = Si[nt.channels[w].name];
          for (let A2 = 0; A2 < C2.width; A2++) {
            Lr.value = (f * (C2.channels * C2.width) + w * C2.width + A2) * C2.inputSize;
            const g3 = (C2.height - 1 - v) * (C2.width * C2.outputChannels) + A2 * C2.outputChannels + p;
            C2.byteArray[g3] = C2.getter(h, Lr);
          }
        }
      }
    }
    return {
      header: nt,
      width: C2.width,
      height: C2.height,
      data: C2.byteArray,
      format: C2.format,
      [at ? "colorSpace" : "encoding"]: C2[at ? "colorSpace" : "encoding"],
      type: this.type
    };
  }
  setDataType(e) {
    return this.type = e, this;
  }
  load(e, n, s, o) {
    function a(l, u) {
      at ? l.colorSpace = u.colorSpace : l.encoding = u.encoding, l.minFilter = LinearFilter, l.magFilter = LinearFilter, l.generateMipmaps = false, l.flipY = false, n && n(l, u);
    }
    return super.load(e, a, s, o);
  }
};
var Lo = class extends Loader {
  constructor(e = {}, n) {
    super(n), this.options = e;
  }
  load(e, n, s, o) {
    const { width: a, height: l, depth: u } = this.options, y = new Data3DTexture(null, a, l, u), E = new Zn(this.manager);
    return E.setRequestHeader(this.requestHeader), E.setPath(this.path), E.setWithCredentials(this.withCredentials), E.load(
      e,
      (I) => {
        const { image: U2 } = I;
        y.image = {
          data: U2.data,
          width: a ?? U2.width,
          height: l ?? U2.height,
          depth: u ?? Math.sqrt(U2.height)
        }, y.type = I.type, y.format = I.format, y.colorSpace = I.colorSpace, y.needsUpdate = true;
        try {
          n == null || n(y);
        } catch (q3) {
          o != null ? o(q3) : console.error(q3), this.manager.itemError(e);
        }
      },
      s,
      o
    ), y;
  }
};
var zo = class extends Loader {
  constructor(e = {}, n) {
    super(n), this.options = e;
  }
  load(e, n, s, o) {
    const { width: a, height: l } = this.options, u = new DataTexture(null, a, l), y = new Zn(this.manager);
    return y.setRequestHeader(this.requestHeader), y.setPath(this.path), y.setWithCredentials(this.withCredentials), y.load(
      e,
      (E) => {
        const { image: I } = E;
        u.image = {
          data: I.data,
          width: a ?? I.width,
          height: l ?? I.height
        }, u.type = E.type, u.format = E.format, u.colorSpace = E.colorSpace, u.needsUpdate = true;
        try {
          n == null || n(u);
        } catch (U2) {
          o != null ? o(U2) : console.error(U2), this.manager.itemError(e);
        }
      },
      s,
      o
    ), u;
  }
};
var fr = 1e-6;
var Dt = new Vector3();
var Lt = new Vector3();
var Ue = new Vector3();
var ct = new Vector3();
var vr = new Vector3();
var Ks = new Vector3();
var eo = new Matrix4();
var to = new Quaternion();
var ro = new Ray();
var Hn = class _Hn {
  constructor(e = 0, n = 0, s = 0, o = 0) {
    this.distance = e, this.heading = n, this.pitch = s, this.roll = o;
  }
  get distance() {
    return this._distance;
  }
  set distance(e) {
    this._distance = Math.max(e, fr);
  }
  get pitch() {
    return this._pitch;
  }
  set pitch(e) {
    this._pitch = $e(e, -Math.PI / 2 + fr, Math.PI / 2 - fr);
  }
  set(e, n, s, o) {
    return this.distance = e, this.heading = n, this.pitch = s, o != null && (this.roll = o), this;
  }
  clone() {
    return new _Hn(this.distance, this.heading, this.pitch, this.roll);
  }
  copy(e) {
    return this.distance = e.distance, this.heading = e.heading, this.pitch = e.pitch, this.roll = e.roll, this;
  }
  equals(e) {
    return e.distance === this.distance && e.heading === this.heading && e.pitch === this.pitch && e.roll === this.roll;
  }
  decompose(e, n, s, o, a = b.WGS84) {
    a.getEastNorthUpVectors(
      e,
      Dt,
      Lt,
      Ue
    ), o == null || o.copy(Ue);
    const l = ct.copy(Dt).multiplyScalar(Math.cos(this.heading)).add(
      vr.copy(Lt).multiplyScalar(Math.sin(this.heading))
    ).multiplyScalar(Math.cos(this.pitch)).add(vr.copy(Ue).multiplyScalar(Math.sin(this.pitch))).normalize().multiplyScalar(this.distance);
    if (n.copy(e).sub(l), this.roll !== 0) {
      const u = ct.copy(e).sub(n).normalize();
      Ue.applyQuaternion(
        to.setFromAxisAngle(u, this.roll)
      );
    }
    s.setFromRotationMatrix(
      eo.lookAt(n, e, Ue)
    );
  }
  setFromCamera(e, n = b.WGS84) {
    const s = ct.setFromMatrixPosition(e.matrixWorld), o = vr.set(0, 0, 0.5).unproject(e).sub(s).normalize(), a = n.getIntersection(ro.set(s, o));
    if (a == null)
      return;
    this.distance = s.distanceTo(a), n.getEastNorthUpVectors(
      a,
      Dt,
      Lt,
      Ue
    ), this.heading = Math.atan2(
      Lt.dot(o),
      Dt.dot(o)
    ), this.pitch = Math.asin(Ue.dot(o));
    const l = ct.copy(e.up).applyQuaternion(e.quaternion), u = Ks.copy(o).multiplyScalar(-l.dot(o)).add(l).normalize(), y = ct.copy(o).multiplyScalar(-Ue.dot(o)).add(Ue).normalize(), E = y.dot(u), I = o.dot(y.cross(u));
    return this.roll = Math.atan2(I, E), this;
  }
};
var wt = class wt2 {
  constructor(e = 0, n = 0, s = 0, o = 0) {
    this.west = e, this.south = n, this.east = s, this.north = o;
  }
  get width() {
    let e = this.east;
    return e < this.west && (e += Math.PI * 2), e - this.west;
  }
  get height() {
    return this.north - this.south;
  }
  set(e, n, s, o) {
    return this.west = e, this.south = n, this.east = s, this.north = o, this;
  }
  clone() {
    return new wt2(this.west, this.south, this.east, this.north);
  }
  copy(e) {
    return this.west = e.west, this.south = e.south, this.east = e.east, this.north = e.north, this;
  }
  equals(e) {
    return e.west === this.west && e.south === this.south && e.east === this.east && e.north === this.north;
  }
  at(e, n, s = new C()) {
    return s.set(
      this.west + (this.east - this.west) * e,
      this.north + (this.south - this.north) * n
    );
  }
  fromArray(e, n = 0) {
    return this.west = e[n], this.south = e[n + 1], this.east = e[n + 2], this.north = e[n + 3], this;
  }
  toArray(e = [], n = 0) {
    return e[n] = this.west, e[n + 1] = this.south, e[n + 2] = this.east, e[n + 3] = this.north, e;
  }
  *[Symbol.iterator]() {
    yield this.west, yield this.south, yield this.east, yield this.north;
  }
};
wt.MAX = new wt(
  C.MIN_LONGITUDE,
  C.MIN_LATITUDE,
  C.MAX_LONGITUDE,
  C.MAX_LATITUDE
);
var qt = wt;
var no = /^[ \t]*#include +"([\w\d./]+)"/gm;
function io(r, e) {
  return r.replace(no, (n, s) => {
    const a = s.split("/").reduce(
      (l, u) => typeof l != "string" && l != null ? l[u] : void 0,
      e
    );
    if (typeof a != "string")
      throw new Error(`Could not find include for ${s}.`);
    return io(a, e);
  });
}
var zt;
function so() {
  if (zt != null)
    return zt;
  const r = new Uint32Array([268435456]);
  return zt = new Uint8Array(r.buffer, r.byteOffset, r.byteLength)[0] === 0, zt;
}
function ke(r, e, n, s = true) {
  if (s === so())
    return new e(r);
  const o = Object.assign(new DataView(r), {
    getFloat16(l, u) {
      return Ps(this, l, u);
    }
  }), a = new e(o.byteLength / e.BYTES_PER_ELEMENT);
  for (let l = 0, u = 0; l < a.length; ++l, u += e.BYTES_PER_ELEMENT)
    a[l] = o[n](u, s);
  return a;
}
var oo = (r) => new Uint8Array(r);
var ko = (r) => new Int8Array(r);
var Zo = (r, e) => ke(r, Uint16Array, "getUint16", e);
var Ho = (r, e) => ke(r, Int16Array, "getInt16", e);
var Go = (r, e) => ke(r, Int32Array, "getInt32", e);
var Wo = (r, e) => ke(r, Uint32Array, "getUint32", e);
var Xo = (r, e) => ke(r, L, "getFloat16", e);
var Yo = (r, e) => ke(r, Float32Array, "getFloat32", e);
var qo = (r, e) => ke(r, Float64Array, "getFloat64", e);
var Vo = class extends Ls {
  constructor(e) {
    super(
      Data3DTexture,
      oo,
      {
        format: RedFormat,
        minFilter: NearestFilter,
        magFilter: NearestFilter,
        wrapS: RepeatWrapping,
        wrapT: RepeatWrapping,
        wrapR: RepeatWrapping,
        width: Di,
        height: Li,
        depth: zi
      },
      e
    );
  }
};
function* Gn(r, e, n, s, o) {
  if (n >= s)
    return;
  const a = 2 ** n, l = n + 1, u = 2 ** l, y = Math.floor(r / a * u), E = Math.floor(e / a * u), I = [
    [y, E, l],
    [y + 1, E, l],
    [y, E + 1, l],
    [y + 1, E + 1, l]
  ];
  if (l < s)
    for (const U2 of I)
      for (const q3 of Gn(...U2, s, o))
        yield q3;
  else
    for (const U2 of I)
      yield (o ?? new dt()).set(...U2);
}
var dt = class _dt {
  constructor(e = 0, n = 0, s = 0) {
    this.x = e, this.y = n, this.z = s;
  }
  set(e, n, s) {
    return this.x = e, this.y = n, s != null && (this.z = s), this;
  }
  clone() {
    return new _dt(this.x, this.y, this.z);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z;
  }
  getParent(e = new _dt()) {
    const n = 2 ** this.z, s = this.x / n, o = this.y / n, a = this.z - 1, l = 2 ** a;
    return e.set(Math.floor(s * l), Math.floor(o * l), a);
  }
  *traverseChildren(e, n) {
    const { x: s, y: o, z: a } = this;
    for (const l of Gn(s, o, a, a + e, n))
      yield l;
  }
  fromArray(e, n = 0) {
    return this.x = e[n], this.y = e[n + 1], this.z = e[n + 2], this;
  }
  toArray(e = [], n = 0) {
    return e[n] = this.x, e[n + 1] = this.y, e[n + 2] = this.z, e;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z;
  }
};
var an = new Vector2();
var Wn = class _Wn {
  constructor(e = 2, n = 1, s = qt.MAX) {
    this.width = e, this.height = n, this.rectangle = s;
  }
  clone() {
    return new _Wn(this.width, this.height, this.rectangle.clone());
  }
  copy(e) {
    return this.width = e.width, this.height = e.height, this.rectangle.copy(e.rectangle), this;
  }
  getSize(e, n = new Vector2()) {
    return n.set(this.width << e, this.height << e);
  }
  // Reference: https://github.com/CesiumGS/cesium/blob/1.122/packages/engine/Source/Core/GeographicTilingScheme.js#L210
  getTile(e, n, s = new dt()) {
    const o = this.getSize(n, an), { rectangle: a } = this, l = a.width / o.x, u = a.height / o.y, { west: y, south: E, east: I } = a;
    let U2 = e.longitude;
    I < y && (U2 += Math.PI * 2);
    let q3 = Math.floor((U2 - y) / l);
    q3 >= o.x && (q3 = o.x - 1);
    let se = Math.floor((e.latitude - E) / u);
    return se >= o.y && (se = o.y - 1), s.x = q3, s.y = se, s.z = n, s;
  }
  // Reference: https://github.com/CesiumGS/cesium/blob/1.122/packages/engine/Source/Core/GeographicTilingScheme.js#L169
  getRectangle(e, n = new qt()) {
    const s = this.getSize(e.z, an), { rectangle: o } = this, a = o.width / s.x, l = o.height / s.y, { west: u, north: y } = o;
    return n.west = e.x * a + u, n.east = (e.x + 1) * a + u, n.north = y - (s.y - e.y - 1) * l, n.south = y - (s.y - e.y) * l, n;
  }
};
var ao = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*(?:i\s*\+\+|\+\+\s*i)\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function co(r, e, n, s) {
  let o = "";
  for (let a = parseInt(e); a < parseInt(n); ++a)
    o += s.replace(/\[\s*i\s*\]/g, "[" + a + "]").replace(/UNROLLED_LOOP_INDEX/g, `${a}`);
  return o;
}
function $o(r) {
  return r.replace(ao, co);
}

export {
  b,
  X,
  C,
  Bi,
  uo,
  fo,
  vo,
  yo,
  Di,
  Li,
  zi,
  po,
  L,
  wo,
  Bs,
  Ls,
  $e,
  go,
  Ao,
  So,
  Eo,
  To,
  Io,
  _o,
  bo,
  No,
  Oo,
  Uo,
  mo,
  Co,
  Ro,
  xo,
  Fo,
  Mo,
  Po,
  Bo,
  Do,
  Lo,
  zo,
  Hn,
  qt,
  io,
  oo,
  ko,
  Zo,
  Ho,
  Go,
  Wo,
  Xo,
  Yo,
  qo,
  Vo,
  dt,
  Wn,
  $o
};
//# sourceMappingURL=chunk-CNPIQBH5.js.map
