"use strict";const c=require("three");var j=process.env.NODE_ENV==="production",R="Invariant failed";function U(f,t){if(!f){if(j)throw new Error(R);var r=R;throw new Error(r)}}const H=new c.Vector3;function B(f,t,r=new c.Vector3,i){const{x:e,y:s,z:n}=f,o=t.x,h=t.y,u=t.z,d=e*e*o,y=s*s*h,a=n*n*u,l=d+y+a,p=Math.sqrt(1/l);if(!Number.isFinite(p))return;const M=H.copy(f).multiplyScalar(p);if(l<((i==null?void 0:i.centerTolerance)??.1))return r.copy(M);const g=M.multiply(t).multiplyScalar(2);let m=(1-p)*f.length()/(g.length()/2),v=0,x,w,z,E;do{m-=v,x=1/(1+m*o),w=1/(1+m*h),z=1/(1+m*u);const T=x*x,L=w*w,O=z*z,D=T*x,G=L*w,C=O*z;E=d*T+y*L+a*O-1,v=E/((d*D*o+y*G*h+a*C*u)*-2)}while(Math.abs(E)>1e-12);return r.set(e*x,s*w,n*z)}const I=new c.Vector3,q=new c.Vector3,S=new c.Vector3,b=class b{constructor(t,r,i){this.radii=new c.Vector3(t,r,i)}get minimumRadius(){return Math.min(this.radii.x,this.radii.y,this.radii.z)}get maximumRadius(){return Math.max(this.radii.x,this.radii.y,this.radii.z)}reciprocalRadii(t=new c.Vector3){const{x:r,y:i,z:e}=this.radii;return t.set(1/r,1/i,1/e)}reciprocalRadiiSquared(t=new c.Vector3){const{x:r,y:i,z:e}=this.radii;return t.set(1/r**2,1/i**2,1/e**2)}projectOnSurface(t,r=new c.Vector3,i){return B(t,this.reciprocalRadiiSquared(),r,i)}getSurfaceNormal(t,r=new c.Vector3){return r.multiplyVectors(this.reciprocalRadiiSquared(I),t).normalize()}getEastNorthUpVectors(t,r=new c.Vector3,i=new c.Vector3,e=new c.Vector3){this.getSurfaceNormal(t,e),r.set(-t.y,t.x,0).normalize(),i.crossVectors(e,r).normalize()}getEastNorthUpFrame(t,r=new c.Matrix4){const i=I,e=q,s=S;return this.getEastNorthUpVectors(t,i,e,s),r.makeBasis(i,e,s).setPosition(t)}getNorthUpEastFrame(t,r=new c.Matrix4){const i=I,e=q,s=S;return this.getEastNorthUpVectors(t,i,e,s),r.makeBasis(e,s,i).setPosition(t)}getIntersection(t,r=new c.Vector3){const i=this.reciprocalRadii(I),e=q.copy(i).multiply(t.origin),s=S.copy(i).multiply(t.direction),n=e.lengthSq(),o=s.lengthSq(),h=e.dot(s),u=h**2-o*(n-1);if(n===1)return r.copy(t.origin);if(n>1){if(h>=0||u<0)return;const d=Math.sqrt(u),y=(-h-d)/o,a=(-h+d)/o;return t.at(Math.min(y,a),r)}if(n<1){const d=h**2-o*(n-1),y=Math.sqrt(d),a=(-h+y)/o;return t.at(a,r)}if(h<0)return t.at(-h/o,r)}getOsculatingSphereCenter(t,r,i=new c.Vector3){U(this.radii.x===this.radii.y);const e=this.radii.x**2,s=this.radii.z**2,n=I.set(t.x/e,t.y/e,t.z/s).normalize();return i.copy(n.multiplyScalar(-r).add(t))}getNormalAtHorizon(t,r,i=new c.Vector3){U(this.radii.x===this.radii.y);const e=this.radii.x**2,s=this.radii.z**2,n=t,o=r;let h=(n.x*o.x+n.y*o.y)/e+n.z*o.z/s;h/=(n.x**2+n.y**2)/e+n.z**2/s;const u=I.copy(o).multiplyScalar(-h).add(t);return i.set(u.x/e,u.y/e,u.z/s).normalize()}};b.WGS84=new b(6378137,6378137,6356752314245179e-9);let A=b;class W extends c.BufferGeometry{constructor(t=new c.Vector3(1,1,1),r=32,i=16){super(),this.type="EllipsoidGeometry",this.parameters={radii:t,longitudeSegments:r,latitudeSegments:i},r=Math.max(3,Math.floor(r)),i=Math.max(2,Math.floor(i));const e=(r+1)*(i+1),s=new c.Vector3,n=new c.Vector3,o=new Float32Array(e*3),h=new Float32Array(e*3),u=new Float32Array(e*2),d=[],y=[];for(let a=0,l=0,p=0,M=0;a<=i;++a){const g=[],m=a/i,v=m*Math.PI;let x=0;a===0?x=.5/r:a===i&&(x=-.5/r);for(let w=0;w<=r;++w,l+=3,p+=2,++M){const z=w/r,E=z*Math.PI*2;s.x=t.x*Math.cos(E)*Math.sin(v),s.y=t.y*Math.sin(E)*Math.sin(v),s.z=t.z*Math.cos(v),o[l]=s.x,o[l+1]=s.y,o[l+2]=s.z,n.copy(s).normalize(),h[l]=n.x,h[l+1]=n.y,h[l+2]=n.z,u[p]=z+x,u[p+1]=1-m,g.push(M)}d.push(g)}for(let a=0;a<i;++a)for(let l=0;l<r;++l){const p=d[a][l+1],M=d[a][l],g=d[a+1][l],m=d[a+1][l+1];a!==0&&y.push(p,M,m),a!==i-1&&y.push(M,g,m)}this.setIndex(y),this.setAttribute("position",new c.BufferAttribute(o,3)),this.setAttribute("normal",new c.BufferAttribute(h,3)),this.setAttribute("uv",new c.BufferAttribute(u,2))}copy(t){return super.copy(t),this.parameters={...t.parameters},this}}const N=new c.Vector3,P=new c.Vector3,V=class V{constructor(t=0,r=0,i=0){this.longitude=t,this.latitude=r,this.height=i}set(t,r,i){return this.longitude=t,this.latitude=r,i!=null&&(this.height=i),this}clone(){return new V(this.longitude,this.latitude,this.height)}copy(t){return this.longitude=t.longitude,this.latitude=t.latitude,this.height=t.height,this}equals(t){return t.longitude===this.longitude&&t.latitude===this.latitude&&t.height===this.height}setLongitude(t){return this.longitude=t,this}setLatitude(t){return this.latitude=t,this}setHeight(t){return this.height=t,this}normalize(){return this.longitude<V.MIN_LONGITUDE&&(this.longitude+=Math.PI*2),this}setFromECEF(t,r){const e=((r==null?void 0:r.ellipsoid)??A.WGS84).reciprocalRadiiSquared(N),s=B(t,e,P,r);if(s==null)throw new Error(`Could not project position to ellipsoid surface: ${t.toArray()}`);const n=N.multiplyVectors(s,e).normalize();this.longitude=Math.atan2(n.y,n.x),this.latitude=Math.asin(n.z);const o=N.subVectors(t,s);return this.height=Math.sign(o.dot(t))*o.length(),this}toECEF(t=new c.Vector3,r){const i=(r==null?void 0:r.ellipsoid)??A.WGS84,e=N.multiplyVectors(i.radii,i.radii),s=Math.cos(this.latitude),n=P.set(s*Math.cos(this.longitude),s*Math.sin(this.longitude),Math.sin(this.latitude)).normalize();return t.multiplyVectors(e,n),t.divideScalar(Math.sqrt(n.dot(t))).add(n.multiplyScalar(this.height))}fromArray(t,r=0){return this.longitude=t[r],this.latitude=t[r+1],this.height=t[r+2],this}toArray(t=[],r=0){return t[r]=this.longitude,t[r+1]=this.latitude,t[r+2]=this.height,t}*[Symbol.iterator](){yield this.longitude,yield this.latitude,yield this.height}};V.MIN_LONGITUDE=-Math.PI,V.MAX_LONGITUDE=Math.PI,V.MIN_LATITUDE=-Math.PI/2,V.MAX_LATITUDE=Math.PI/2;let F=V;exports.Ellipsoid=A;exports.EllipsoidGeometry=W;exports.Geodetic=F;exports.invariant=U;
//# sourceMappingURL=shared.cjs.map
