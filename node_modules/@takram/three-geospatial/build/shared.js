import { Vector3 as o, Matrix4 as T, BufferGeometry as $, BufferAttribute as S } from "three";
var k = "production" === "production", P = "Invariant failed";
function R(f, t) {
  if (!f) {
    if (k)
      throw new Error(P);
    var i = P;
    throw new Error(i);
  }
}
const H = /* @__PURE__ */ new o();
function G(f, t, i = new o(), r) {
  const { x: s, y: e, z: n } = f, a = t.x, h = t.y, u = t.z, d = s * s * a, y = e * e * h, c = n * n * u, l = d + y + c, p = Math.sqrt(1 / l);
  if (!Number.isFinite(p))
    return;
  const M = H.copy(f).multiplyScalar(p);
  if (l < ((r == null ? void 0 : r.centerTolerance) ?? 0.1))
    return i.copy(M);
  const v = M.multiply(t).multiplyScalar(2);
  let m = (1 - p) * f.length() / (v.length() / 2), I = 0, x, w, z, E;
  do {
    m -= I, x = 1 / (1 + m * a), w = 1 / (1 + m * h), z = 1 / (1 + m * u);
    const F = x * x, L = w * w, O = z * z, j = F * x, B = L * w, W = O * z;
    E = d * F + y * L + c * O - 1, I = E / ((d * j * a + y * B * h + c * W * u) * -2);
  } while (Math.abs(E) > 1e-12);
  return i.set(s * x, e * w, n * z);
}
const N = /* @__PURE__ */ new o(), V = /* @__PURE__ */ new o(), U = /* @__PURE__ */ new o(), q = class q {
  constructor(t, i, r) {
    this.radii = new o(t, i, r);
  }
  get minimumRadius() {
    return Math.min(this.radii.x, this.radii.y, this.radii.z);
  }
  get maximumRadius() {
    return Math.max(this.radii.x, this.radii.y, this.radii.z);
  }
  reciprocalRadii(t = new o()) {
    const { x: i, y: r, z: s } = this.radii;
    return t.set(1 / i, 1 / r, 1 / s);
  }
  reciprocalRadiiSquared(t = new o()) {
    const { x: i, y: r, z: s } = this.radii;
    return t.set(1 / i ** 2, 1 / r ** 2, 1 / s ** 2);
  }
  projectOnSurface(t, i = new o(), r) {
    return G(
      t,
      this.reciprocalRadiiSquared(),
      i,
      r
    );
  }
  getSurfaceNormal(t, i = new o()) {
    return i.multiplyVectors(this.reciprocalRadiiSquared(N), t).normalize();
  }
  getEastNorthUpVectors(t, i = new o(), r = new o(), s = new o()) {
    this.getSurfaceNormal(t, s), i.set(-t.y, t.x, 0).normalize(), r.crossVectors(s, i).normalize();
  }
  getEastNorthUpFrame(t, i = new T()) {
    const r = N, s = V, e = U;
    return this.getEastNorthUpVectors(t, r, s, e), i.makeBasis(r, s, e).setPosition(t);
  }
  getNorthUpEastFrame(t, i = new T()) {
    const r = N, s = V, e = U;
    return this.getEastNorthUpVectors(t, r, s, e), i.makeBasis(s, e, r).setPosition(t);
  }
  getIntersection(t, i = new o()) {
    const r = this.reciprocalRadii(N), s = V.copy(r).multiply(t.origin), e = U.copy(r).multiply(t.direction), n = s.lengthSq(), a = e.lengthSq(), h = s.dot(e), u = h ** 2 - a * (n - 1);
    if (n === 1)
      return i.copy(t.origin);
    if (n > 1) {
      if (h >= 0 || u < 0)
        return;
      const d = Math.sqrt(u), y = (-h - d) / a, c = (-h + d) / a;
      return t.at(Math.min(y, c), i);
    }
    if (n < 1) {
      const d = h ** 2 - a * (n - 1), y = Math.sqrt(d), c = (-h + y) / a;
      return t.at(c, i);
    }
    if (h < 0)
      return t.at(-h / a, i);
  }
  getOsculatingSphereCenter(t, i, r = new o()) {
    R(this.radii.x === this.radii.y);
    const s = this.radii.x ** 2, e = this.radii.z ** 2, n = N.set(
      t.x / s,
      t.y / s,
      t.z / e
    ).normalize();
    return r.copy(n.multiplyScalar(-i).add(t));
  }
  getNormalAtHorizon(t, i, r = new o()) {
    R(this.radii.x === this.radii.y);
    const s = this.radii.x ** 2, e = this.radii.z ** 2, n = t, a = i;
    let h = (n.x * a.x + n.y * a.y) / s + n.z * a.z / e;
    h /= (n.x ** 2 + n.y ** 2) / s + n.z ** 2 / e;
    const u = N.copy(a).multiplyScalar(-h).add(t);
    return r.set(u.x / s, u.y / s, u.z / e).normalize();
  }
};
q.WGS84 = /* @__PURE__ */ new q(
  6378137,
  6378137,
  6356752314245179e-9
);
let b = q;
class X extends $ {
  constructor(t = new o(1, 1, 1), i = 32, r = 16) {
    super(), this.type = "EllipsoidGeometry", this.parameters = {
      radii: t,
      longitudeSegments: i,
      latitudeSegments: r
    }, i = Math.max(3, Math.floor(i)), r = Math.max(2, Math.floor(r));
    const s = (i + 1) * (r + 1), e = new o(), n = new o(), a = new Float32Array(s * 3), h = new Float32Array(s * 3), u = new Float32Array(s * 2), d = [], y = [];
    for (let c = 0, l = 0, p = 0, M = 0; c <= r; ++c) {
      const v = [], m = c / r, I = m * Math.PI;
      let x = 0;
      c === 0 ? x = 0.5 / i : c === r && (x = -0.5 / i);
      for (let w = 0; w <= i; ++w, l += 3, p += 2, ++M) {
        const z = w / i, E = z * Math.PI * 2;
        e.x = t.x * Math.cos(E) * Math.sin(I), e.y = t.y * Math.sin(E) * Math.sin(I), e.z = t.z * Math.cos(I), a[l] = e.x, a[l + 1] = e.y, a[l + 2] = e.z, n.copy(e).normalize(), h[l] = n.x, h[l + 1] = n.y, h[l + 2] = n.z, u[p] = z + x, u[p + 1] = 1 - m, v.push(M);
      }
      d.push(v);
    }
    for (let c = 0; c < r; ++c)
      for (let l = 0; l < i; ++l) {
        const p = d[c][l + 1], M = d[c][l], v = d[c + 1][l], m = d[c + 1][l + 1];
        c !== 0 && y.push(p, M, m), c !== r - 1 && y.push(M, v, m);
      }
    this.setIndex(y), this.setAttribute("position", new S(a, 3)), this.setAttribute("normal", new S(h, 3)), this.setAttribute("uv", new S(u, 2));
  }
  copy(t) {
    return super.copy(t), this.parameters = { ...t.parameters }, this;
  }
}
const A = /* @__PURE__ */ new o(), D = /* @__PURE__ */ new o(), g = class g {
  constructor(t = 0, i = 0, r = 0) {
    this.longitude = t, this.latitude = i, this.height = r;
  }
  set(t, i, r) {
    return this.longitude = t, this.latitude = i, r != null && (this.height = r), this;
  }
  clone() {
    return new g(this.longitude, this.latitude, this.height);
  }
  copy(t) {
    return this.longitude = t.longitude, this.latitude = t.latitude, this.height = t.height, this;
  }
  equals(t) {
    return t.longitude === this.longitude && t.latitude === this.latitude && t.height === this.height;
  }
  setLongitude(t) {
    return this.longitude = t, this;
  }
  setLatitude(t) {
    return this.latitude = t, this;
  }
  setHeight(t) {
    return this.height = t, this;
  }
  normalize() {
    return this.longitude < g.MIN_LONGITUDE && (this.longitude += Math.PI * 2), this;
  }
  // See: https://en.wikipedia.org/wiki/Geographic_coordinate_conversion
  // Reference: https://github.com/CesiumGS/cesium/blob/1.122/packages/engine/Source/Core/Geodetic.js#L119
  setFromECEF(t, i) {
    const s = ((i == null ? void 0 : i.ellipsoid) ?? b.WGS84).reciprocalRadiiSquared(A), e = G(
      t,
      s,
      D,
      i
    );
    if (e == null)
      throw new Error(
        `Could not project position to ellipsoid surface: ${t.toArray()}`
      );
    const n = A.multiplyVectors(e, s).normalize();
    this.longitude = Math.atan2(n.y, n.x), this.latitude = Math.asin(n.z);
    const a = A.subVectors(t, e);
    return this.height = Math.sign(a.dot(t)) * a.length(), this;
  }
  // See: https://en.wikipedia.org/wiki/Geographic_coordinate_conversion
  // Reference: https://github.com/CesiumGS/cesium/blob/1.122/packages/engine/Source/Core/Cartesian3.js#L916
  toECEF(t = new o(), i) {
    const r = (i == null ? void 0 : i.ellipsoid) ?? b.WGS84, s = A.multiplyVectors(
      r.radii,
      r.radii
    ), e = Math.cos(this.latitude), n = D.set(
      e * Math.cos(this.longitude),
      e * Math.sin(this.longitude),
      Math.sin(this.latitude)
    ).normalize();
    return t.multiplyVectors(s, n), t.divideScalar(Math.sqrt(n.dot(t))).add(n.multiplyScalar(this.height));
  }
  fromArray(t, i = 0) {
    return this.longitude = t[i], this.latitude = t[i + 1], this.height = t[i + 2], this;
  }
  toArray(t = [], i = 0) {
    return t[i] = this.longitude, t[i + 1] = this.latitude, t[i + 2] = this.height, t;
  }
  *[Symbol.iterator]() {
    yield this.longitude, yield this.latitude, yield this.height;
  }
};
g.MIN_LONGITUDE = -Math.PI, g.MAX_LONGITUDE = Math.PI, g.MIN_LATITUDE = -Math.PI / 2, g.MAX_LATITUDE = Math.PI / 2;
let C = g;
export {
  b as E,
  C as G,
  X as a,
  R as i
};
//# sourceMappingURL=shared.js.map
