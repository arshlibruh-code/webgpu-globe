import { Loader as gt, FileLoader as Ei, BufferGeometry as Ti, BufferAttribute as zr, Box3 as Ii, Vector3 as Re, Sphere as _i, LinearFilter as kt, RGBAFormat as cn, ByteType as bi, UnsignedByteType as kr, ShortType as Ni, UnsignedShortType as Oi, IntType as Ui, UnsignedIntType as mi, HalfFloatType as lt, FloatType as ft, MathUtils as ye, Material as Vt, REVISION as Ci, DataTextureLoader as Ri, RedFormat as ln, DataUtils as Zr, Data3DTexture as hn, DataTexture as xi, Quaternion as Fi, Matrix4 as Mi, Ray as Pi, RepeatWrapping as sr, NearestFilter as Hr, Vector2 as un } from "three";
import { i as fn, E as Gr, G as st } from "./shared.js";
import { a as jo } from "./shared.js";
class Bi extends gt {
  load(e, n, s, o) {
    const a = new Ei(this.manager);
    a.setResponseType("arraybuffer"), a.setRequestHeader(this.requestHeader), a.setPath(this.path), a.setWithCredentials(this.withCredentials), a.load(
      e,
      (l) => {
        fn(l instanceof ArrayBuffer);
        try {
          n(l);
        } catch (u) {
          o != null ? o(u) : console.error(u), this.manager.itemError(e);
        }
      },
      s,
      o
    );
  }
}
function uo(r) {
}
function fo(r) {
  var a;
  const { attributes: e, index: n, boundingBox: s, boundingSphere: o } = r;
  return [
    { attributes: e, index: n, boundingBox: s, boundingSphere: o },
    [
      ...Object.values(r.attributes).map(
        (l) => l.array.buffer
      ),
      (a = r.index) == null ? void 0 : a.array.buffer
    ].filter((l) => l != null)
  ];
}
function vo(r, e = new Ti()) {
  for (const [n, s] of Object.entries(r.attributes))
    e.setAttribute(
      n,
      new zr(
        s.array,
        s.itemSize,
        s.normalized
      )
    );
  if (e.index = r.index != null ? new zr(
    r.index.array,
    r.index.itemSize,
    r.index.normalized
  ) : null, r.boundingBox != null) {
    const { min: n, max: s } = r.boundingBox;
    e.boundingBox = new Ii(
      new Re(n.x, n.y, n.z),
      new Re(s.x, s.y, s.z)
    );
  }
  if (r.boundingSphere != null) {
    const { center: n, radius: s } = r.boundingSphere;
    e.boundingSphere = new _i(
      new Re(n.x, n.y, n.z),
      s
    );
  }
  return e;
}
function yo(r) {
  return r.getContext().getExtension("OES_texture_float_linear") != null;
}
const Di = 128, Li = 128, zi = 64, ki = "9627216cc50057994c98a2118f3c4a23765d43b9", po = `https://media.githubusercontent.com/media/takram-design-engineering/three-geospatial/${ki}/packages/core/assets/stbn.bin`, Zi = "This is not an object", Hi = "This is not a Float16Array object", Wr = "This constructor is not a subclass of Float16Array", vn = "The constructor property value is not an object", Gi = "Species constructor didn't return TypedArray object", Wi = "Derived constructor created TypedArray object which was too small length", vt = "Attempting to access detached ArrayBuffer", yr = "Cannot convert undefined or null to object", pr = "Cannot mix BigInt and other types, use explicit conversions", Xr = "@@iterator property is not callable", Yr = "Reduce of empty array with no initial value", Xi = "The comparison function must be either a function or undefined", or = "Offset is out of bounds";
function Z(r) {
  return (e, ...n) => ie(r, e, n);
}
function Je(r, e) {
  return Z(
    Ye(
      r,
      e
    ).get
  );
}
const {
  apply: ie,
  construct: ht,
  defineProperty: qr,
  get: ar,
  getOwnPropertyDescriptor: Ye,
  getPrototypeOf: At,
  has: wr,
  ownKeys: yn,
  set: Vr,
  setPrototypeOf: pn
} = Reflect, Yi = Proxy, {
  EPSILON: qi,
  MAX_SAFE_INTEGER: $r,
  isFinite: wn,
  isNaN: qe
} = Number, {
  iterator: Ie,
  species: Vi,
  toStringTag: Ir,
  for: $i
} = Symbol, Ve = Object, {
  create: $t,
  defineProperty: St,
  freeze: Ji,
  is: Jr
} = Ve, dr = Ve.prototype, Qi = (
  /** @type {any} */
  dr.__lookupGetter__ ? Z(
    /** @type {any} */
    dr.__lookupGetter__
  ) : (r, e) => {
    if (r == null)
      throw X(
        yr
      );
    let n = Ve(r);
    do {
      const s = Ye(n, e);
      if (s !== void 0)
        return Ce(s, "get") ? s.get : void 0;
    } while ((n = At(n)) !== null);
  }
), Ce = (
  /** @type {any} */
  Ve.hasOwn || Z(dr.hasOwnProperty)
), dn = Array, gn = dn.isArray, Jt = dn.prototype, ji = Z(Jt.join), Ki = Z(Jt.push), es = Z(
  Jt.toLocaleString
), _r = Jt[Ie], ts = Z(_r), {
  abs: rs,
  trunc: An
} = Math, Qt = ArrayBuffer, ns = Qt.isView, Sn = Qt.prototype, is = Z(Sn.slice), ss = Je(Sn, "byteLength"), gr = typeof SharedArrayBuffer < "u" ? SharedArrayBuffer : null, os = gr && Je(gr.prototype, "byteLength"), br = At(Uint8Array), as = br.from, Q = br.prototype, cs = Q[Ie], ls = Z(Q.keys), hs = Z(
  Q.values
), us = Z(
  Q.entries
), fs = Z(Q.set), Qr = Z(
  Q.reverse
), vs = Z(Q.fill), ys = Z(
  Q.copyWithin
), jr = Z(Q.sort), ot = Z(Q.slice), ps = Z(
  Q.subarray
), J = Je(
  Q,
  "buffer"
), Le = Je(
  Q,
  "byteOffset"
), x = Je(
  Q,
  "length"
), En = Je(
  Q,
  Ir
), ws = Uint8Array, ce = Uint16Array, Kr = (...r) => ie(as, ce, r), Nr = Uint32Array, ds = Float32Array, ze = At([][Ie]()), jt = Z(ze.next), gs = Z(function* () {
}().next), As = At(ze), Ss = DataView.prototype, Es = Z(
  Ss.getUint16
), X = TypeError, cr = RangeError, Tn = WeakSet, In = Tn.prototype, Ts = Z(In.add), Is = Z(In.has), Kt = WeakMap, Or = Kt.prototype, Zt = Z(Or.get), _s = Z(Or.has), Ur = Z(Or.set), _n = new Kt(), bs = $t(null, {
  next: {
    value: function() {
      const e = Zt(_n, this);
      return jt(e);
    }
  },
  [Ie]: {
    value: function() {
      return this;
    }
  }
});
function ut(r) {
  if (r[Ie] === _r && ze.next === jt)
    return r;
  const e = $t(bs);
  return Ur(_n, e, ts(r)), e;
}
const bn = new Kt(), Nn = $t(As, {
  next: {
    value: function() {
      const e = Zt(bn, this);
      return gs(e);
    },
    writable: !0,
    configurable: !0
  }
});
for (const r of yn(ze))
  r !== "next" && St(Nn, r, Ye(ze, r));
function en(r) {
  const e = $t(Nn);
  return Ur(bn, e, r), e;
}
function Ht(r) {
  return r !== null && typeof r == "object" || typeof r == "function";
}
function tn(r) {
  return r !== null && typeof r == "object";
}
function Gt(r) {
  return En(r) !== void 0;
}
function Ar(r) {
  const e = En(r);
  return e === "BigInt64Array" || e === "BigUint64Array";
}
function Ns(r) {
  try {
    return gn(r) ? !1 : (ss(
      /** @type {any} */
      r
    ), !0);
  } catch {
    return !1;
  }
}
function On(r) {
  if (gr === null)
    return !1;
  try {
    return os(
      /** @type {any} */
      r
    ), !0;
  } catch {
    return !1;
  }
}
function Os(r) {
  return Ns(r) || On(r);
}
function rn(r) {
  return gn(r) ? r[Ie] === _r && ze.next === jt : !1;
}
function Us(r) {
  return Gt(r) ? r[Ie] === cs && ze.next === jt : !1;
}
function Ft(r) {
  if (typeof r != "string")
    return !1;
  const e = +r;
  return r !== e + "" || !wn(e) ? !1 : e === An(e);
}
const Wt = $i("__Float16Array__");
function ms(r) {
  if (!tn(r))
    return !1;
  const e = At(r);
  if (!tn(e))
    return !1;
  const n = e.constructor;
  if (n === void 0)
    return !1;
  if (!Ht(n))
    throw X(vn);
  return wr(n, Wt);
}
const Sr = 1 / qi;
function Cs(r) {
  return r + Sr - Sr;
}
const Un = 6103515625e-14, Rs = 65504, mn = 9765625e-10, nn = mn * Un, xs = mn * Sr;
function Fs(r) {
  const e = +r;
  if (!wn(e) || e === 0)
    return e;
  const n = e > 0 ? 1 : -1, s = rs(e);
  if (s < Un)
    return n * Cs(s / nn) * nn;
  const o = (1 + xs) * s, a = o - (o - s);
  return a > Rs || qe(a) ? n * (1 / 0) : n * a;
}
const Cn = new Qt(4), Rn = new ds(Cn), xn = new Nr(Cn), de = new ce(512), ge = new ws(512);
for (let r = 0; r < 256; ++r) {
  const e = r - 127;
  e < -24 ? (de[r] = 0, de[r | 256] = 32768, ge[r] = 24, ge[r | 256] = 24) : e < -14 ? (de[r] = 1024 >> -e - 14, de[r | 256] = 1024 >> -e - 14 | 32768, ge[r] = -e - 1, ge[r | 256] = -e - 1) : e <= 15 ? (de[r] = e + 15 << 10, de[r | 256] = e + 15 << 10 | 32768, ge[r] = 13, ge[r | 256] = 13) : e < 128 ? (de[r] = 31744, de[r | 256] = 64512, ge[r] = 24, ge[r | 256] = 24) : (de[r] = 31744, de[r | 256] = 64512, ge[r] = 13, ge[r | 256] = 13);
}
function Te(r) {
  Rn[0] = Fs(r);
  const e = xn[0], n = e >> 23 & 511;
  return de[n] + ((e & 8388607) >> ge[n]);
}
const mr = new Nr(2048);
for (let r = 1; r < 1024; ++r) {
  let e = r << 13, n = 0;
  for (; (e & 8388608) === 0; )
    e <<= 1, n -= 8388608;
  e &= -8388609, n += 947912704, mr[r] = e | n;
}
for (let r = 1024; r < 2048; ++r)
  mr[r] = 939524096 + (r - 1024 << 13);
const Qe = new Nr(64);
for (let r = 1; r < 31; ++r)
  Qe[r] = r << 23;
Qe[31] = 1199570944;
Qe[32] = 2147483648;
for (let r = 33; r < 63; ++r)
  Qe[r] = 2147483648 + (r - 32 << 23);
Qe[63] = 3347054592;
const Fn = new ce(64);
for (let r = 1; r < 64; ++r)
  r !== 32 && (Fn[r] = 1024);
function M(r) {
  const e = r >> 10;
  return xn[0] = mr[Fn[e] + (r & 1023)] + Qe[e], Rn[0];
}
function me(r) {
  const e = +r;
  return qe(e) || e === 0 ? 0 : An(e);
}
function lr(r) {
  const e = me(r);
  return e < 0 ? 0 : e < $r ? e : $r;
}
function Mt(r, e) {
  if (!Ht(r))
    throw X(Zi);
  const n = r.constructor;
  if (n === void 0)
    return e;
  if (!Ht(n))
    throw X(vn);
  const s = n[Vi];
  return s ?? e;
}
function yt(r) {
  if (On(r))
    return !1;
  try {
    return is(r, 0, 0), !1;
  } catch {
  }
  return !0;
}
function sn(r, e) {
  const n = qe(r), s = qe(e);
  if (n && s)
    return 0;
  if (n)
    return 1;
  if (s || r < e)
    return -1;
  if (r > e)
    return 1;
  if (r === 0 && e === 0) {
    const o = Jr(r, 0), a = Jr(e, 0);
    if (!o && a)
      return -1;
    if (o && !a)
      return 1;
  }
  return 0;
}
const Cr = 2, Xt = new Kt();
function Xe(r) {
  return _s(Xt, r) || !ns(r) && ms(r);
}
function R(r) {
  if (!Xe(r))
    throw X(Hi);
}
function Pt(r, e) {
  const n = Xe(r), s = Gt(r);
  if (!n && !s)
    throw X(Gi);
  if (typeof e == "number") {
    let o;
    if (n) {
      const a = O(r);
      o = x(a);
    } else
      o = x(r);
    if (o < e)
      throw X(
        Wi
      );
  }
  if (Ar(r))
    throw X(pr);
}
function O(r) {
  const e = Zt(Xt, r);
  if (e !== void 0) {
    const o = J(e);
    if (yt(o))
      throw X(vt);
    return e;
  }
  const n = (
    /** @type {any} */
    r.buffer
  );
  if (yt(n))
    throw X(vt);
  const s = ht(L, [
    n,
    /** @type {any} */
    r.byteOffset,
    /** @type {any} */
    r.length
  ], r.constructor);
  return Zt(Xt, s);
}
function on(r) {
  const e = x(r), n = [];
  for (let s = 0; s < e; ++s)
    n[s] = M(r[s]);
  return n;
}
const Mn = new Tn();
for (const r of yn(Q)) {
  if (r === Ir)
    continue;
  const e = Ye(Q, r);
  Ce(e, "get") && typeof e.get == "function" && Ts(Mn, e.get);
}
const Ms = Ji(
  /** @type {ProxyHandler<Float16BitsArray>} */
  {
    get(r, e, n) {
      return Ft(e) && Ce(r, e) ? M(ar(r, e)) : Is(Mn, Qi(r, e)) ? ar(r, e) : ar(r, e, n);
    },
    set(r, e, n, s) {
      return Ft(e) && Ce(r, e) ? Vr(r, e, Te(n)) : Vr(r, e, n, s);
    },
    getOwnPropertyDescriptor(r, e) {
      if (Ft(e) && Ce(r, e)) {
        const n = Ye(r, e);
        return n.value = M(n.value), n;
      }
      return Ye(r, e);
    },
    defineProperty(r, e, n) {
      return Ft(e) && Ce(r, e) && Ce(n, "value") && (n.value = Te(n.value)), qr(r, e, n);
    }
  }
);
class L {
  /** @see https://tc39.es/ecma262/#sec-typedarray */
  constructor(e, n, s) {
    let o;
    if (Xe(e))
      o = ht(ce, [O(e)], new.target);
    else if (Ht(e) && !Os(e)) {
      let l, u;
      if (Gt(e)) {
        l = e, u = x(e);
        const y = J(e);
        if (yt(y))
          throw X(vt);
        if (Ar(e))
          throw X(pr);
        const E = new Qt(
          u * Cr
        );
        o = ht(ce, [E], new.target);
      } else {
        const y = e[Ie];
        if (y != null && typeof y != "function")
          throw X(Xr);
        y != null ? rn(e) ? (l = e, u = e.length) : (l = [.../** @type {Iterable<unknown>} */
        e], u = l.length) : (l = /** @type {ArrayLike<unknown>} */
        e, u = lr(l.length)), o = ht(ce, [u], new.target);
      }
      for (let y = 0; y < u; ++y)
        o[y] = Te(l[y]);
    } else
      o = ht(ce, arguments, new.target);
    const a = (
      /** @type {any} */
      new Yi(o, Ms)
    );
    return Ur(Xt, a, o), a;
  }
  /**
   * limitation: `Object.getOwnPropertyNames(Float16Array)` or `Reflect.ownKeys(Float16Array)` include this key
   * @see https://tc39.es/ecma262/#sec-%typedarray%.from
   */
  static from(e, ...n) {
    const s = this;
    if (!wr(s, Wt))
      throw X(
        Wr
      );
    if (s === L) {
      if (Xe(e) && n.length === 0) {
        const I = O(e), U = new ce(
          J(I),
          Le(I),
          x(I)
        );
        return new L(
          J(ot(U))
        );
      }
      if (n.length === 0)
        return new L(
          J(
            Kr(e, Te)
          )
        );
      const y = n[0], E = n[1];
      return new L(
        J(
          Kr(e, function(I, ...U) {
            return Te(
              ie(y, this, [I, ...ut(U)])
            );
          }, E)
        )
      );
    }
    let o, a;
    const l = e[Ie];
    if (l != null && typeof l != "function")
      throw X(Xr);
    if (l != null)
      rn(e) ? (o = e, a = e.length) : Us(e) ? (o = e, a = x(e)) : (o = [...e], a = o.length);
    else {
      if (e == null)
        throw X(
          yr
        );
      o = Ve(e), a = lr(o.length);
    }
    const u = new s(a);
    if (n.length === 0)
      for (let y = 0; y < a; ++y)
        u[y] = /** @type {number} */
        o[y];
    else {
      const y = n[0], E = n[1];
      for (let I = 0; I < a; ++I)
        u[I] = ie(y, E, [o[I], I]);
    }
    return u;
  }
  /**
   * limitation: `Object.getOwnPropertyNames(Float16Array)` or `Reflect.ownKeys(Float16Array)` include this key
   * @see https://tc39.es/ecma262/#sec-%typedarray%.of
   */
  static of(...e) {
    const n = this;
    if (!wr(n, Wt))
      throw X(
        Wr
      );
    const s = e.length;
    if (n === L) {
      const a = new L(s), l = O(a);
      for (let u = 0; u < s; ++u)
        l[u] = Te(e[u]);
      return a;
    }
    const o = new n(s);
    for (let a = 0; a < s; ++a)
      o[a] = e[a];
    return o;
  }
  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.keys */
  keys() {
    R(this);
    const e = O(this);
    return ls(e);
  }
  /**
   * limitation: returns a object whose prototype is not `%ArrayIteratorPrototype%`
   * @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.values
   */
  values() {
    R(this);
    const e = O(this);
    return en(function* () {
      for (const n of hs(e))
        yield M(n);
    }());
  }
  /**
   * limitation: returns a object whose prototype is not `%ArrayIteratorPrototype%`
   * @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.entries
   */
  entries() {
    R(this);
    const e = O(this);
    return en(function* () {
      for (const [n, s] of us(e))
        yield (
          /** @type {[number, number]} */
          [n, M(s)]
        );
    }());
  }
  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.at */
  at(e) {
    R(this);
    const n = O(this), s = x(n), o = me(e), a = o >= 0 ? o : s + o;
    if (!(a < 0 || a >= s))
      return M(n[a]);
  }
  /** @see https://tc39.es/proposal-change-array-by-copy/#sec-%typedarray%.prototype.with */
  with(e, n) {
    R(this);
    const s = O(this), o = x(s), a = me(e), l = a >= 0 ? a : o + a, u = +n;
    if (l < 0 || l >= o)
      throw cr(or);
    const y = new ce(
      J(s),
      Le(s),
      x(s)
    ), E = new L(
      J(
        ot(y)
      )
    ), I = O(E);
    return I[l] = Te(u), E;
  }
  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.map */
  map(e, ...n) {
    R(this);
    const s = O(this), o = x(s), a = n[0], l = Mt(s, L);
    if (l === L) {
      const y = new L(o), E = O(y);
      for (let I = 0; I < o; ++I) {
        const U = M(s[I]);
        E[I] = Te(
          ie(e, a, [U, I, this])
        );
      }
      return y;
    }
    const u = new l(o);
    Pt(u, o);
    for (let y = 0; y < o; ++y) {
      const E = M(s[y]);
      u[y] = ie(e, a, [E, y, this]);
    }
    return (
      /** @type {any} */
      u
    );
  }
  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.filter */
  filter(e, ...n) {
    R(this);
    const s = O(this), o = x(s), a = n[0], l = [];
    for (let E = 0; E < o; ++E) {
      const I = M(s[E]);
      ie(e, a, [I, E, this]) && Ki(l, I);
    }
    const u = Mt(s, L), y = new u(l);
    return Pt(y), /** @type {any} */
    y;
  }
  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.reduce */
  reduce(e, ...n) {
    R(this);
    const s = O(this), o = x(s);
    if (o === 0 && n.length === 0)
      throw X(Yr);
    let a, l;
    n.length === 0 ? (a = M(s[0]), l = 1) : (a = n[0], l = 0);
    for (let u = l; u < o; ++u)
      a = e(
        a,
        M(s[u]),
        u,
        this
      );
    return a;
  }
  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.reduceright */
  reduceRight(e, ...n) {
    R(this);
    const s = O(this), o = x(s);
    if (o === 0 && n.length === 0)
      throw X(Yr);
    let a, l;
    n.length === 0 ? (a = M(s[o - 1]), l = o - 2) : (a = n[0], l = o - 1);
    for (let u = l; u >= 0; --u)
      a = e(
        a,
        M(s[u]),
        u,
        this
      );
    return a;
  }
  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.foreach */
  forEach(e, ...n) {
    R(this);
    const s = O(this), o = x(s), a = n[0];
    for (let l = 0; l < o; ++l)
      ie(e, a, [
        M(s[l]),
        l,
        this
      ]);
  }
  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.find */
  find(e, ...n) {
    R(this);
    const s = O(this), o = x(s), a = n[0];
    for (let l = 0; l < o; ++l) {
      const u = M(s[l]);
      if (ie(e, a, [u, l, this]))
        return u;
    }
  }
  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.findindex */
  findIndex(e, ...n) {
    R(this);
    const s = O(this), o = x(s), a = n[0];
    for (let l = 0; l < o; ++l) {
      const u = M(s[l]);
      if (ie(e, a, [u, l, this]))
        return l;
    }
    return -1;
  }
  /** @see https://tc39.es/proposal-array-find-from-last/index.html#sec-%typedarray%.prototype.findlast */
  findLast(e, ...n) {
    R(this);
    const s = O(this), o = x(s), a = n[0];
    for (let l = o - 1; l >= 0; --l) {
      const u = M(s[l]);
      if (ie(e, a, [u, l, this]))
        return u;
    }
  }
  /** @see https://tc39.es/proposal-array-find-from-last/index.html#sec-%typedarray%.prototype.findlastindex */
  findLastIndex(e, ...n) {
    R(this);
    const s = O(this), o = x(s), a = n[0];
    for (let l = o - 1; l >= 0; --l) {
      const u = M(s[l]);
      if (ie(e, a, [u, l, this]))
        return l;
    }
    return -1;
  }
  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.every */
  every(e, ...n) {
    R(this);
    const s = O(this), o = x(s), a = n[0];
    for (let l = 0; l < o; ++l)
      if (!ie(e, a, [
        M(s[l]),
        l,
        this
      ]))
        return !1;
    return !0;
  }
  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.some */
  some(e, ...n) {
    R(this);
    const s = O(this), o = x(s), a = n[0];
    for (let l = 0; l < o; ++l)
      if (ie(e, a, [
        M(s[l]),
        l,
        this
      ]))
        return !0;
    return !1;
  }
  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.set */
  set(e, ...n) {
    R(this);
    const s = O(this), o = me(n[0]);
    if (o < 0)
      throw cr(or);
    if (e == null)
      throw X(
        yr
      );
    if (Ar(e))
      throw X(
        pr
      );
    if (Xe(e))
      return fs(
        O(this),
        O(e),
        o
      );
    if (Gt(e)) {
      const y = J(e);
      if (yt(y))
        throw X(vt);
    }
    const a = x(s), l = Ve(e), u = lr(l.length);
    if (o === 1 / 0 || u + o > a)
      throw cr(or);
    for (let y = 0; y < u; ++y)
      s[y + o] = Te(l[y]);
  }
  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.reverse */
  reverse() {
    R(this);
    const e = O(this);
    return Qr(e), this;
  }
  /** @see https://tc39.es/proposal-change-array-by-copy/#sec-%typedarray%.prototype.toReversed */
  toReversed() {
    R(this);
    const e = O(this), n = new ce(
      J(e),
      Le(e),
      x(e)
    ), s = new L(
      J(
        ot(n)
      )
    ), o = O(s);
    return Qr(o), s;
  }
  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.fill */
  fill(e, ...n) {
    R(this);
    const s = O(this);
    return vs(
      s,
      Te(e),
      ...ut(n)
    ), this;
  }
  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.copywithin */
  copyWithin(e, n, ...s) {
    R(this);
    const o = O(this);
    return ys(o, e, n, ...ut(s)), this;
  }
  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.sort */
  sort(e) {
    R(this);
    const n = O(this), s = e !== void 0 ? e : sn;
    return jr(n, (o, a) => s(M(o), M(a))), this;
  }
  /** @see https://tc39.es/proposal-change-array-by-copy/#sec-%typedarray%.prototype.toSorted */
  toSorted(e) {
    R(this);
    const n = O(this);
    if (e !== void 0 && typeof e != "function")
      throw new X(Xi);
    const s = e !== void 0 ? e : sn, o = new ce(
      J(n),
      Le(n),
      x(n)
    ), a = new L(
      J(
        ot(o)
      )
    ), l = O(a);
    return jr(l, (u, y) => s(M(u), M(y))), a;
  }
  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.slice */
  slice(e, n) {
    R(this);
    const s = O(this), o = Mt(s, L);
    if (o === L) {
      const Ze = new ce(
        J(s),
        Le(s),
        x(s)
      );
      return new L(
        J(
          ot(Ze, e, n)
        )
      );
    }
    const a = x(s), l = me(e), u = n === void 0 ? a : me(n);
    let y;
    l === -1 / 0 ? y = 0 : l < 0 ? y = a + l > 0 ? a + l : 0 : y = a < l ? a : l;
    let E;
    u === -1 / 0 ? E = 0 : u < 0 ? E = a + u > 0 ? a + u : 0 : E = a < u ? a : u;
    const I = E - y > 0 ? E - y : 0, U = new o(I);
    if (Pt(U, I), I === 0)
      return U;
    const q = J(s);
    if (yt(q))
      throw X(vt);
    let se = 0;
    for (; y < E; )
      U[se] = M(s[y]), ++y, ++se;
    return (
      /** @type {any} */
      U
    );
  }
  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.subarray */
  subarray(e, n) {
    R(this);
    const s = O(this), o = Mt(s, L), a = new ce(
      J(s),
      Le(s),
      x(s)
    ), l = ps(a, e, n), u = new o(
      J(l),
      Le(l),
      x(l)
    );
    return Pt(u), /** @type {any} */
    u;
  }
  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.indexof */
  indexOf(e, ...n) {
    R(this);
    const s = O(this), o = x(s);
    let a = me(n[0]);
    if (a === 1 / 0)
      return -1;
    a < 0 && (a += o, a < 0 && (a = 0));
    for (let l = a; l < o; ++l)
      if (Ce(s, l) && M(s[l]) === e)
        return l;
    return -1;
  }
  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.lastindexof */
  lastIndexOf(e, ...n) {
    R(this);
    const s = O(this), o = x(s);
    let a = n.length >= 1 ? me(n[0]) : o - 1;
    if (a === -1 / 0)
      return -1;
    a >= 0 ? a = a < o - 1 ? a : o - 1 : a += o;
    for (let l = a; l >= 0; --l)
      if (Ce(s, l) && M(s[l]) === e)
        return l;
    return -1;
  }
  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.includes */
  includes(e, ...n) {
    R(this);
    const s = O(this), o = x(s);
    let a = me(n[0]);
    if (a === 1 / 0)
      return !1;
    a < 0 && (a += o, a < 0 && (a = 0));
    const l = qe(e);
    for (let u = a; u < o; ++u) {
      const y = M(s[u]);
      if (l && qe(y) || y === e)
        return !0;
    }
    return !1;
  }
  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.join */
  join(e) {
    R(this);
    const n = O(this), s = on(n);
    return ji(s, e);
  }
  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.tolocalestring */
  toLocaleString(...e) {
    R(this);
    const n = O(this), s = on(n);
    return es(s, ...ut(e));
  }
  /** @see https://tc39.es/ecma262/#sec-get-%typedarray%.prototype-@@tostringtag */
  get [Ir]() {
    if (Xe(this))
      return (
        /** @type {any} */
        "Float16Array"
      );
  }
}
St(L, "BYTES_PER_ELEMENT", {
  value: Cr
});
St(L, Wt, {});
pn(L, br);
const Yt = L.prototype;
St(Yt, "BYTES_PER_ELEMENT", {
  value: Cr
});
St(Yt, Ie, {
  value: Yt.values,
  writable: !0,
  configurable: !0
});
pn(Yt, Q);
function Ps(r, e, ...n) {
  return M(
    Es(r, e, ...ut(n))
  );
}
function wo(r) {
  return r instanceof Int8Array || r instanceof Uint8Array || r instanceof Uint8ClampedArray || r instanceof Int16Array || r instanceof Uint16Array || r instanceof Int32Array || r instanceof Uint32Array || r instanceof L || r instanceof Float32Array || r instanceof Float64Array;
}
class Bs extends gt {
  constructor(e, n) {
    super(n), this.parser = e;
  }
  load(e, n, s, o) {
    const a = new Bi(this.manager);
    a.setRequestHeader(this.requestHeader), a.setPath(this.path), a.setWithCredentials(this.withCredentials), a.load(
      e,
      (l) => {
        try {
          n(this.parser(l));
        } catch (u) {
          o != null ? o(u) : console.error(u), this.manager.itemError(e);
        }
      },
      s,
      o
    );
  }
}
function Ds(r) {
  const e = r instanceof Int8Array ? bi : r instanceof Uint8Array ? kr : r instanceof Uint8ClampedArray ? kr : r instanceof Int16Array ? Ni : r instanceof Uint16Array ? Oi : r instanceof Int32Array ? Ui : r instanceof Uint32Array ? mi : r instanceof L ? lt : r instanceof Float32Array ? ft : r instanceof Float64Array ? ft : null;
  return fn(e != null), e;
}
class Ls extends gt {
  constructor(e, n, s = {}, o) {
    super(o), this.textureClass = e, this.parser = n, this.options = {
      format: cn,
      minFilter: kt,
      magFilter: kt,
      ...s
    };
  }
  load(e, n, s, o) {
    const a = new this.textureClass(), l = new Bs(this.parser, this.manager);
    return l.setRequestHeader(this.requestHeader), l.setPath(this.path), l.setWithCredentials(this.withCredentials), l.load(
      e,
      (u) => {
        a.image.data = u instanceof L ? new Uint16Array(u.buffer) : u;
        const { width: y, height: E, depth: I, ...U } = this.options;
        y != null && (a.image.width = y), E != null && (a.image.height = E), "depth" in a.image && I != null && (a.image.depth = I), a.type = Ds(u), Object.assign(a, U), a.needsUpdate = !0, n == null || n(a);
      },
      s,
      o
    ), a;
  }
}
const $e = ye.clamp, go = ye.euclideanModulo, Ao = ye.inverseLerp, So = ye.lerp, Eo = ye.degToRad, To = ye.radToDeg, Io = ye.isPowerOfTwo, _o = ye.ceilPowerOfTwo, bo = ye.floorPowerOfTwo, No = ye.normalize;
function Oo(r, e, n, s = 0, o = 1) {
  return ye.mapLinear(r, e, n, s, o);
}
function Uo(r, e, n, s = 0, o = 1) {
  return $e(ye.mapLinear(r, e, n, s, o), s, o);
}
function mo(r, e, n) {
  return n <= r ? 0 : n >= e ? 1 : (n = (n - r) / (e - r), n * n * (3 - 2 * n));
}
function Co(r) {
  return Math.min(Math.max(r, 0), 1);
}
function Ro(r, e, n, s = n) {
  const o = Math.abs(r - e);
  return o <= s || o <= n * Math.max(Math.abs(r), Math.abs(e));
}
function xo(r) {
  return (e, n) => {
    e instanceof Vt ? Object.defineProperty(e, n, {
      enumerable: !0,
      get() {
        var s;
        return ((s = this.defines) == null ? void 0 : s[r]) != null;
      },
      set(s) {
        var o;
        s !== this[n] && (s ? (this.defines ?? (this.defines = {}), this.defines[r] = "1") : (o = this.defines) == null || delete o[r], this.needsUpdate = !0);
      }
    }) : Object.defineProperty(e, n, {
      enumerable: !0,
      get() {
        return this.defines.has(r);
      },
      set(s) {
        s !== this[n] && (s ? this.defines.set(r, "1") : this.defines.delete(r), this.setChanged());
      }
    });
  };
}
function Fo(r, {
  min: e = Number.MIN_SAFE_INTEGER,
  max: n = Number.MAX_SAFE_INTEGER
} = {}) {
  return (s, o) => {
    s instanceof Vt ? Object.defineProperty(s, o, {
      enumerable: !0,
      get() {
        var l;
        const a = (l = this.defines) == null ? void 0 : l[r];
        return a != null ? parseInt(a) : 0;
      },
      set(a) {
        const l = this[o];
        a !== l && (this.defines ?? (this.defines = {}), this.defines[r] = $e(a, e, n).toFixed(0), this.needsUpdate = !0);
      }
    }) : Object.defineProperty(s, o, {
      enumerable: !0,
      get() {
        const a = this.defines.get(r);
        return a != null ? parseInt(a) : 0;
      },
      set(a) {
        const l = this[o];
        a !== l && (this.defines.set(r, $e(a, e, n).toFixed(0)), this.setChanged());
      }
    });
  };
}
function Mo(r, {
  min: e = -1 / 0,
  max: n = 1 / 0,
  precision: s = 7
} = {}) {
  return (o, a) => {
    o instanceof Vt ? Object.defineProperty(o, a, {
      enumerable: !0,
      get() {
        var u;
        const l = (u = this.defines) == null ? void 0 : u[r];
        return l != null ? parseFloat(l) : 0;
      },
      set(l) {
        const u = this[a];
        l !== u && (this.defines ?? (this.defines = {}), this.defines[r] = $e(l, e, n).toFixed(s), this.needsUpdate = !0);
      }
    }) : Object.defineProperty(o, a, {
      enumerable: !0,
      get() {
        const l = this.defines.get(r);
        return l != null ? parseFloat(l) : 0;
      },
      set(l) {
        const u = this[a];
        l !== u && (this.defines.set(r, $e(l, e, n).toFixed(s)), this.setChanged());
      }
    });
  };
}
function Po(r, { validate: e } = {}) {
  return (n, s) => {
    n instanceof Vt ? Object.defineProperty(n, s, {
      enumerable: !0,
      get() {
        var o;
        return ((o = this.defines) == null ? void 0 : o[r]) ?? "";
      },
      set(o) {
        if (o !== this[s]) {
          if ((e == null ? void 0 : e(o)) === !1) {
            console.error(`Expression validation failed: ${o}`);
            return;
          }
          this.defines ?? (this.defines = {}), this.defines[r] = o, this.needsUpdate = !0;
        }
      }
    }) : Object.defineProperty(n, s, {
      enumerable: !0,
      get() {
        return this.defines.get(r) ?? "";
      },
      set(o) {
        if (o !== this[s]) {
          if ((e == null ? void 0 : e(o)) === !1) {
            console.error(`Expression validation failed: ${o}`);
            return;
          }
          this.defines.set(r, o), this.setChanged();
        }
      }
    });
  };
}
function Bo(r, ...e) {
  const n = {};
  for (let s = 0; s < e.length; s += 2) {
    const o = e[s], a = e[s + 1];
    for (const l of a)
      n[l] = {
        enumerable: !0,
        get: () => o[l],
        set: (u) => {
          o[l] = u;
        }
      };
  }
  return Object.defineProperties(r, n), r;
}
function Do(r, e, n) {
  const s = {};
  for (const o of n)
    s[o] = {
      enumerable: !0,
      get: () => e.uniforms[o].value,
      set: (a) => {
        e.uniforms[o].value = a;
      }
    };
  return Object.defineProperties(r, s), r;
}
const zs = parseInt(Ci.replace(/\D+/g, ""));
var ve = Uint8Array, Me = Uint16Array, Er = Uint32Array, Pn = new ve([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  0,
  /* unused */
  0,
  0,
  /* impossible */
  0
]), Bn = new ve([
  0,
  0,
  0,
  0,
  1,
  1,
  2,
  2,
  3,
  3,
  4,
  4,
  5,
  5,
  6,
  6,
  7,
  7,
  8,
  8,
  9,
  9,
  10,
  10,
  11,
  11,
  12,
  12,
  13,
  13,
  /* unused */
  0,
  0
]), ks = new ve([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), Dn = function(r, e) {
  for (var n = new Me(31), s = 0; s < 31; ++s)
    n[s] = e += 1 << r[s - 1];
  for (var o = new Er(n[30]), s = 1; s < 30; ++s)
    for (var a = n[s]; a < n[s + 1]; ++a)
      o[a] = a - n[s] << 5 | s;
  return [n, o];
}, Ln = Dn(Pn, 2), zn = Ln[0], Zs = Ln[1];
zn[28] = 258, Zs[258] = 28;
var Hs = Dn(Bn, 0), Gs = Hs[0], Tr = new Me(32768);
for (var G = 0; G < 32768; ++G) {
  var Fe = (G & 43690) >>> 1 | (G & 21845) << 1;
  Fe = (Fe & 52428) >>> 2 | (Fe & 13107) << 2, Fe = (Fe & 61680) >>> 4 | (Fe & 3855) << 4, Tr[G] = ((Fe & 65280) >>> 8 | (Fe & 255) << 8) >>> 1;
}
var pt = function(r, e, n) {
  for (var s = r.length, o = 0, a = new Me(e); o < s; ++o)
    ++a[r[o] - 1];
  var l = new Me(e);
  for (o = 0; o < e; ++o)
    l[o] = l[o - 1] + a[o - 1] << 1;
  var u;
  if (n) {
    u = new Me(1 << e);
    var y = 15 - e;
    for (o = 0; o < s; ++o)
      if (r[o])
        for (var E = o << 4 | r[o], I = e - r[o], U = l[r[o] - 1]++ << I, q = U | (1 << I) - 1; U <= q; ++U)
          u[Tr[U] >>> y] = E;
  } else
    for (u = new Me(s), o = 0; o < s; ++o)
      r[o] && (u[o] = Tr[l[r[o] - 1]++] >>> 15 - r[o]);
  return u;
}, Et = new ve(288);
for (var G = 0; G < 144; ++G)
  Et[G] = 8;
for (var G = 144; G < 256; ++G)
  Et[G] = 9;
for (var G = 256; G < 280; ++G)
  Et[G] = 7;
for (var G = 280; G < 288; ++G)
  Et[G] = 8;
var kn = new ve(32);
for (var G = 0; G < 32; ++G)
  kn[G] = 5;
var Ws = /* @__PURE__ */ pt(Et, 9, 1), Xs = /* @__PURE__ */ pt(kn, 5, 1), hr = function(r) {
  for (var e = r[0], n = 1; n < r.length; ++n)
    r[n] > e && (e = r[n]);
  return e;
}, we = function(r, e, n) {
  var s = e / 8 | 0;
  return (r[s] | r[s + 1] << 8) >> (e & 7) & n;
}, ur = function(r, e) {
  var n = e / 8 | 0;
  return (r[n] | r[n + 1] << 8 | r[n + 2] << 16) >> (e & 7);
}, Ys = function(r) {
  return (r / 8 | 0) + (r & 7 && 1);
}, qs = function(r, e, n) {
  (n == null || n > r.length) && (n = r.length);
  var s = new (r instanceof Me ? Me : r instanceof Er ? Er : ve)(n - e);
  return s.set(r.subarray(e, n)), s;
}, Vs = function(r, e, n) {
  var s = r.length;
  if (!s || n && !n.l && s < 5)
    return e || new ve(0);
  var o = !e || n, a = !n || n.i;
  n || (n = {}), e || (e = new ve(s * 3));
  var l = function(P) {
    var be = e.length;
    if (P > be) {
      var Ne = new ve(Math.max(be * 2, P));
      Ne.set(e), e = Ne;
    }
  }, u = n.f || 0, y = n.p || 0, E = n.b || 0, I = n.l, U = n.d, q = n.m, se = n.n, Ze = s * 8;
  do {
    if (!I) {
      n.f = u = we(r, y, 1);
      var Tt = we(r, y + 1, 3);
      if (y += 3, Tt)
        if (Tt == 1)
          I = Ws, U = Xs, q = 9, se = 5;
        else if (Tt == 2) {
          var bt = we(r, y, 31) + 257, er = we(r, y + 10, 15) + 4, tr = bt + we(r, y + 5, 31) + 1;
          y += 14;
          for (var He = new ve(tr), Nt = new ve(19), oe = 0; oe < er; ++oe)
            Nt[ks[oe]] = we(r, y + oe * 3, 7);
          y += er * 3;
          for (var Ot = hr(Nt), rr = (1 << Ot) - 1, nr = pt(Nt, Ot, 1), oe = 0; oe < tr; ) {
            var le = nr[we(r, y, rr)];
            y += le & 15;
            var pe = le >>> 4;
            if (pe < 16)
              He[oe++] = pe;
            else {
              var _e = 0, Ae = 0;
              for (pe == 16 ? (Ae = 3 + we(r, y, 3), y += 2, _e = He[oe - 1]) : pe == 17 ? (Ae = 3 + we(r, y, 7), y += 3) : pe == 18 && (Ae = 11 + we(r, y, 127), y += 7); Ae--; )
                He[oe++] = _e;
            }
          }
          var Ut = He.subarray(0, bt), Se = He.subarray(bt);
          q = hr(Ut), se = hr(Se), I = pt(Ut, q, 1), U = pt(Se, se, 1);
        } else
          throw "invalid block type";
      else {
        var pe = Ys(y) + 4, It = r[pe - 4] | r[pe - 3] << 8, _t = pe + It;
        if (_t > s) {
          if (a)
            throw "unexpected EOF";
          break;
        }
        o && l(E + It), e.set(r.subarray(pe, _t), E), n.b = E += It, n.p = y = _t * 8;
        continue;
      }
      if (y > Ze) {
        if (a)
          throw "unexpected EOF";
        break;
      }
    }
    o && l(E + 131072);
    for (var mt = (1 << q) - 1, Ct = (1 << se) - 1, je = y; ; je = y) {
      var _e = I[ur(r, y) & mt], ee = _e >>> 4;
      if (y += _e & 15, y > Ze) {
        if (a)
          throw "unexpected EOF";
        break;
      }
      if (!_e)
        throw "invalid length/literal";
      if (ee < 256)
        e[E++] = ee;
      else if (ee == 256) {
        je = y, I = null;
        break;
      } else {
        var Ge = ee - 254;
        if (ee > 264) {
          var oe = ee - 257, re = Pn[oe];
          Ge = we(r, y, (1 << re) - 1) + zn[oe], y += re;
        }
        var Pe = U[ur(r, y) & Ct], Be = Pe >>> 4;
        if (!Pe)
          throw "invalid distance";
        y += Pe & 15;
        var Se = Gs[Be];
        if (Be > 3) {
          var re = Bn[Be];
          Se += ur(r, y) & (1 << re) - 1, y += re;
        }
        if (y > Ze) {
          if (a)
            throw "unexpected EOF";
          break;
        }
        o && l(E + 131072);
        for (var Ke = E + Ge; E < Ke; E += 4)
          e[E] = e[E - Se], e[E + 1] = e[E + 1 - Se], e[E + 2] = e[E + 2 - Se], e[E + 3] = e[E + 3 - Se];
        E = Ke;
      }
    }
    n.l = I, n.p = je, n.b = E, I && (u = 1, n.m = q, n.d = U, n.n = se);
  } while (!u);
  return E == e.length ? e : qs(e, 0, E);
}, $s = /* @__PURE__ */ new ve(0), Js = function(r) {
  if ((r[0] & 15) != 8 || r[0] >>> 4 > 7 || (r[0] << 8 | r[1]) % 31)
    throw "invalid zlib data";
  if (r[1] & 32)
    throw "invalid zlib data: preset dictionaries not supported";
};
function Bt(r, e) {
  return Vs((Js(r), r.subarray(2, -4)), e);
}
var Qs = typeof TextDecoder < "u" && /* @__PURE__ */ new TextDecoder(), js = 0;
try {
  Qs.decode($s, { stream: !0 }), js = 1;
} catch {
}
const at = zs >= 152;
class Zn extends Ri {
  constructor(e) {
    super(e), this.type = lt;
  }
  parse(e) {
    const Ot = Math.pow(2.7182818, 2.2);
    function rr(t, i) {
      for (var c = 0, h = 0; h < 65536; ++h)
        (h == 0 || t[h >> 3] & 1 << (h & 7)) && (i[c++] = h);
      for (var f = c - 1; c < 65536; )
        i[c++] = 0;
      return f;
    }
    function nr(t) {
      for (var i = 0; i < 16384; i++)
        t[i] = {}, t[i].len = 0, t[i].lit = 0, t[i].p = null;
    }
    const le = { l: 0, c: 0, lc: 0 };
    function _e(t, i, c, h, f) {
      for (; c < t; )
        i = i << 8 | Dr(h, f), c += 8;
      c -= t, le.l = i >> c & (1 << t) - 1, le.c = i, le.lc = c;
    }
    const Ae = new Array(59);
    function Ut(t) {
      for (var i = 0; i <= 58; ++i)
        Ae[i] = 0;
      for (var i = 0; i < 65537; ++i)
        Ae[t[i]] += 1;
      for (var c = 0, i = 58; i > 0; --i) {
        var h = c + Ae[i] >> 1;
        Ae[i] = c, c = h;
      }
      for (var i = 0; i < 65537; ++i) {
        var f = t[i];
        f > 0 && (t[i] = f | Ae[f]++ << 6);
      }
    }
    function Se(t, i, c, h, f, v, w) {
      for (var p = c, A = 0, g = 0; f <= v; f++) {
        if (p.value - c.value > h)
          return !1;
        _e(6, A, g, t, p);
        var S = le.l;
        if (A = le.c, g = le.lc, w[f] = S, S == 63) {
          if (p.value - c.value > h)
            throw "Something wrong with hufUnpackEncTable";
          _e(8, A, g, t, p);
          var d = le.l + 6;
          if (A = le.c, g = le.lc, f + d > v + 1)
            throw "Something wrong with hufUnpackEncTable";
          for (; d--; )
            w[f++] = 0;
          f--;
        } else if (S >= 59) {
          var d = S - 59 + 2;
          if (f + d > v + 1)
            throw "Something wrong with hufUnpackEncTable";
          for (; d--; )
            w[f++] = 0;
          f--;
        }
      }
      Ut(w);
    }
    function mt(t) {
      return t & 63;
    }
    function Ct(t) {
      return t >> 6;
    }
    function je(t, i, c, h) {
      for (; i <= c; i++) {
        var f = Ct(t[i]), v = mt(t[i]);
        if (f >> v)
          throw "Invalid table entry";
        if (v > 14) {
          var w = h[f >> v - 14];
          if (w.len)
            throw "Invalid table entry";
          if (w.lit++, w.p) {
            var p = w.p;
            w.p = new Array(w.lit);
            for (var A = 0; A < w.lit - 1; ++A)
              w.p[A] = p[A];
          } else
            w.p = new Array(1);
          w.p[w.lit - 1] = i;
        } else if (v)
          for (var g = 0, A = 1 << 14 - v; A > 0; A--) {
            var w = h[(f << 14 - v) + g];
            if (w.len || w.p)
              throw "Invalid table entry";
            w.len = v, w.lit = i, g++;
          }
      }
      return !0;
    }
    const ee = { c: 0, lc: 0 };
    function Ge(t, i, c, h) {
      t = t << 8 | Dr(c, h), i += 8, ee.c = t, ee.lc = i;
    }
    const re = { c: 0, lc: 0 };
    function Pe(t, i, c, h, f, v, w, p, A, g) {
      if (t == i) {
        h < 8 && (Ge(c, h, f, w), c = ee.c, h = ee.lc), h -= 8;
        var S = c >> h, S = new Uint8Array([S])[0];
        if (A.value + S > g)
          return !1;
        for (var d = p[A.value - 1]; S-- > 0; )
          p[A.value++] = d;
      } else if (A.value < g)
        p[A.value++] = t;
      else
        return !1;
      re.c = c, re.lc = h;
    }
    function Be(t) {
      return t & 65535;
    }
    function Ke(t) {
      var i = Be(t);
      return i > 32767 ? i - 65536 : i;
    }
    const P = { a: 0, b: 0 };
    function be(t, i) {
      var c = Ke(t), h = Ke(i), f = h, v = c + (f & 1) + (f >> 1), w = v, p = v - f;
      P.a = w, P.b = p;
    }
    function Ne(t, i) {
      var c = Be(t), h = Be(i), f = c - (h >> 1) & 65535, v = h + f - 32768 & 65535;
      P.a = v, P.b = f;
    }
    function Xn(t, i, c, h, f, v, w) {
      for (var p = w < 16384, A = c > f ? f : c, g = 1, S; g <= A; )
        g <<= 1;
      for (g >>= 1, S = g, g >>= 1; g >= 1; ) {
        for (var d = 0, Y = d + v * (f - S), _ = v * g, b = v * S, N = h * g, m = h * S, B, z, V, te; d <= Y; d += b) {
          for (var k = d, Ee = d + h * (c - S); k <= Ee; k += m) {
            var H = k + N, $ = k + _, Oe = $ + N;
            p ? (be(t[k + i], t[$ + i]), B = P.a, V = P.b, be(t[H + i], t[Oe + i]), z = P.a, te = P.b, be(B, z), t[k + i] = P.a, t[H + i] = P.b, be(V, te), t[$ + i] = P.a, t[Oe + i] = P.b) : (Ne(t[k + i], t[$ + i]), B = P.a, V = P.b, Ne(t[H + i], t[Oe + i]), z = P.a, te = P.b, Ne(B, z), t[k + i] = P.a, t[H + i] = P.b, Ne(V, te), t[$ + i] = P.a, t[Oe + i] = P.b);
          }
          if (c & g) {
            var $ = k + _;
            p ? be(t[k + i], t[$ + i]) : Ne(t[k + i], t[$ + i]), B = P.a, t[$ + i] = P.b, t[k + i] = B;
          }
        }
        if (f & g)
          for (var k = d, Ee = d + h * (c - S); k <= Ee; k += m) {
            var H = k + N;
            p ? be(t[k + i], t[H + i]) : Ne(t[k + i], t[H + i]), B = P.a, t[H + i] = P.b, t[k + i] = B;
          }
        S = g, g >>= 1;
      }
      return d;
    }
    function Yn(t, i, c, h, f, v, w, p, A, g) {
      for (var S = 0, d = 0, Y = p, _ = Math.trunc(f.value + (v + 7) / 8); f.value < _; )
        for (Ge(S, d, c, f), S = ee.c, d = ee.lc; d >= 14; ) {
          var b = S >> d - 14 & 16383, N = i[b];
          if (N.len)
            d -= N.len, Pe(N.lit, w, S, d, c, h, f, A, g, Y), S = re.c, d = re.lc;
          else {
            if (!N.p)
              throw "hufDecode issues";
            var m;
            for (m = 0; m < N.lit; m++) {
              for (var B = mt(t[N.p[m]]); d < B && f.value < _; )
                Ge(S, d, c, f), S = ee.c, d = ee.lc;
              if (d >= B && Ct(t[N.p[m]]) == (S >> d - B & (1 << B) - 1)) {
                d -= B, Pe(
                  N.p[m],
                  w,
                  S,
                  d,
                  c,
                  h,
                  f,
                  A,
                  g,
                  Y
                ), S = re.c, d = re.lc;
                break;
              }
            }
            if (m == N.lit)
              throw "hufDecode issues";
          }
        }
      var z = 8 - v & 7;
      for (S >>= z, d -= z; d > 0; ) {
        var N = i[S << 14 - d & 16383];
        if (N.len)
          d -= N.len, Pe(N.lit, w, S, d, c, h, f, A, g, Y), S = re.c, d = re.lc;
        else
          throw "hufDecode issues";
      }
      return !0;
    }
    function Rr(t, i, c, h, f, v) {
      var w = { value: 0 }, p = c.value, A = ne(i, c), g = ne(i, c);
      c.value += 4;
      var S = ne(i, c);
      if (c.value += 4, A < 0 || A >= 65537 || g < 0 || g >= 65537)
        throw "Something wrong with HUF_ENCSIZE";
      var d = new Array(65537), Y = new Array(16384);
      nr(Y);
      var _ = h - (c.value - p);
      if (Se(t, i, c, _, A, g, d), S > 8 * (h - (c.value - p)))
        throw "Something wrong with hufUncompress";
      je(d, A, g, Y), Yn(d, Y, t, i, c, S, g, v, f, w);
    }
    function qn(t, i, c) {
      for (var h = 0; h < c; ++h)
        i[h] = t[i[h]];
    }
    function xr(t) {
      for (var i = 1; i < t.length; i++) {
        var c = t[i - 1] + t[i] - 128;
        t[i] = c;
      }
    }
    function Fr(t, i) {
      for (var c = 0, h = Math.floor((t.length + 1) / 2), f = 0, v = t.length - 1; !(f > v || (i[f++] = t[c++], f > v)); )
        i[f++] = t[h++];
    }
    function Mr(t) {
      for (var i = t.byteLength, c = new Array(), h = 0, f = new DataView(t); i > 0; ) {
        var v = f.getInt8(h++);
        if (v < 0) {
          var w = -v;
          i -= w + 1;
          for (var p = 0; p < w; p++)
            c.push(f.getUint8(h++));
        } else {
          var w = v;
          i -= 2;
          for (var A = f.getUint8(h++), p = 0; p < w + 1; p++)
            c.push(A);
        }
      }
      return c;
    }
    function Vn(t, i, c, h, f, v) {
      var H = new DataView(v.buffer), w = c[t.idx[0]].width, p = c[t.idx[0]].height, A = 3, g = Math.floor(w / 8), S = Math.ceil(w / 8), d = Math.ceil(p / 8), Y = w - (S - 1) * 8, _ = p - (d - 1) * 8, b = { value: 0 }, N = new Array(A), m = new Array(A), B = new Array(A), z = new Array(A), V = new Array(A);
      for (let D = 0; D < A; ++D)
        V[D] = i[t.idx[D]], N[D] = D < 1 ? 0 : N[D - 1] + S * d, m[D] = new Float32Array(64), B[D] = new Uint16Array(64), z[D] = new Uint16Array(S * 64);
      for (let D = 0; D < d; ++D) {
        var te = 8;
        D == d - 1 && (te = _);
        var k = 8;
        for (let W = 0; W < S; ++W) {
          W == S - 1 && (k = Y);
          for (let F = 0; F < A; ++F)
            B[F].fill(0), B[F][0] = f[N[F]++], $n(b, h, B[F]), Jn(B[F], m[F]), Qn(m[F]);
          jn(m);
          for (let F = 0; F < A; ++F)
            Kn(m[F], z[F], W * 64);
        }
        let K = 0;
        for (let W = 0; W < A; ++W) {
          const F = c[t.idx[W]].type;
          for (let fe = 8 * D; fe < 8 * D + te; ++fe) {
            K = V[W][fe];
            for (let De = 0; De < g; ++De) {
              const ae = De * 64 + (fe & 7) * 8;
              H.setUint16(K + 0 * F, z[W][ae + 0], !0), H.setUint16(K + 2 * F, z[W][ae + 1], !0), H.setUint16(K + 4 * F, z[W][ae + 2], !0), H.setUint16(K + 6 * F, z[W][ae + 3], !0), H.setUint16(K + 8 * F, z[W][ae + 4], !0), H.setUint16(K + 10 * F, z[W][ae + 5], !0), H.setUint16(K + 12 * F, z[W][ae + 6], !0), H.setUint16(K + 14 * F, z[W][ae + 7], !0), K += 16 * F;
            }
          }
          if (g != S)
            for (let fe = 8 * D; fe < 8 * D + te; ++fe) {
              const De = V[W][fe] + 8 * g * 2 * F, ae = g * 64 + (fe & 7) * 8;
              for (let xe = 0; xe < k; ++xe)
                H.setUint16(De + xe * 2 * F, z[W][ae + xe], !0);
            }
        }
      }
      for (var Ee = new Uint16Array(w), H = new DataView(v.buffer), $ = 0; $ < A; ++$) {
        c[t.idx[$]].decoded = !0;
        var Oe = c[t.idx[$]].type;
        if (c[$].type == 2)
          for (var it = 0; it < p; ++it) {
            const D = V[$][it];
            for (var ue = 0; ue < w; ++ue)
              Ee[ue] = H.getUint16(D + ue * 2 * Oe, !0);
            for (var ue = 0; ue < w; ++ue)
              H.setFloat32(D + ue * 2 * Oe, T(Ee[ue]), !0);
          }
      }
    }
    function $n(t, i, c) {
      for (var h, f = 1; f < 64; )
        h = i[t.value], h == 65280 ? f = 64 : h >> 8 == 255 ? f += h & 255 : (c[f] = h, f++), t.value++;
    }
    function Jn(t, i) {
      i[0] = T(t[0]), i[1] = T(t[1]), i[2] = T(t[5]), i[3] = T(t[6]), i[4] = T(t[14]), i[5] = T(t[15]), i[6] = T(t[27]), i[7] = T(t[28]), i[8] = T(t[2]), i[9] = T(t[4]), i[10] = T(t[7]), i[11] = T(t[13]), i[12] = T(t[16]), i[13] = T(t[26]), i[14] = T(t[29]), i[15] = T(t[42]), i[16] = T(t[3]), i[17] = T(t[8]), i[18] = T(t[12]), i[19] = T(t[17]), i[20] = T(t[25]), i[21] = T(t[30]), i[22] = T(t[41]), i[23] = T(t[43]), i[24] = T(t[9]), i[25] = T(t[11]), i[26] = T(t[18]), i[27] = T(t[24]), i[28] = T(t[31]), i[29] = T(t[40]), i[30] = T(t[44]), i[31] = T(t[53]), i[32] = T(t[10]), i[33] = T(t[19]), i[34] = T(t[23]), i[35] = T(t[32]), i[36] = T(t[39]), i[37] = T(t[45]), i[38] = T(t[52]), i[39] = T(t[54]), i[40] = T(t[20]), i[41] = T(t[22]), i[42] = T(t[33]), i[43] = T(t[38]), i[44] = T(t[46]), i[45] = T(t[51]), i[46] = T(t[55]), i[47] = T(t[60]), i[48] = T(t[21]), i[49] = T(t[34]), i[50] = T(t[37]), i[51] = T(t[47]), i[52] = T(t[50]), i[53] = T(t[56]), i[54] = T(t[59]), i[55] = T(t[61]), i[56] = T(t[35]), i[57] = T(t[36]), i[58] = T(t[48]), i[59] = T(t[49]), i[60] = T(t[57]), i[61] = T(t[58]), i[62] = T(t[62]), i[63] = T(t[63]);
    }
    function Qn(t) {
      const i = 0.5 * Math.cos(0.7853975), c = 0.5 * Math.cos(3.14159 / 16), h = 0.5 * Math.cos(3.14159 / 8), f = 0.5 * Math.cos(3 * 3.14159 / 16), v = 0.5 * Math.cos(5 * 3.14159 / 16), w = 0.5 * Math.cos(3 * 3.14159 / 8), p = 0.5 * Math.cos(7 * 3.14159 / 16);
      for (var A = new Array(4), g = new Array(4), S = new Array(4), d = new Array(4), Y = 0; Y < 8; ++Y) {
        var _ = Y * 8;
        A[0] = h * t[_ + 2], A[1] = w * t[_ + 2], A[2] = h * t[_ + 6], A[3] = w * t[_ + 6], g[0] = c * t[_ + 1] + f * t[_ + 3] + v * t[_ + 5] + p * t[_ + 7], g[1] = f * t[_ + 1] - p * t[_ + 3] - c * t[_ + 5] - v * t[_ + 7], g[2] = v * t[_ + 1] - c * t[_ + 3] + p * t[_ + 5] + f * t[_ + 7], g[3] = p * t[_ + 1] - v * t[_ + 3] + f * t[_ + 5] - c * t[_ + 7], S[0] = i * (t[_ + 0] + t[_ + 4]), S[3] = i * (t[_ + 0] - t[_ + 4]), S[1] = A[0] + A[3], S[2] = A[1] - A[2], d[0] = S[0] + S[1], d[1] = S[3] + S[2], d[2] = S[3] - S[2], d[3] = S[0] - S[1], t[_ + 0] = d[0] + g[0], t[_ + 1] = d[1] + g[1], t[_ + 2] = d[2] + g[2], t[_ + 3] = d[3] + g[3], t[_ + 4] = d[3] - g[3], t[_ + 5] = d[2] - g[2], t[_ + 6] = d[1] - g[1], t[_ + 7] = d[0] - g[0];
      }
      for (var b = 0; b < 8; ++b)
        A[0] = h * t[16 + b], A[1] = w * t[16 + b], A[2] = h * t[48 + b], A[3] = w * t[48 + b], g[0] = c * t[8 + b] + f * t[24 + b] + v * t[40 + b] + p * t[56 + b], g[1] = f * t[8 + b] - p * t[24 + b] - c * t[40 + b] - v * t[56 + b], g[2] = v * t[8 + b] - c * t[24 + b] + p * t[40 + b] + f * t[56 + b], g[3] = p * t[8 + b] - v * t[24 + b] + f * t[40 + b] - c * t[56 + b], S[0] = i * (t[b] + t[32 + b]), S[3] = i * (t[b] - t[32 + b]), S[1] = A[0] + A[3], S[2] = A[1] - A[2], d[0] = S[0] + S[1], d[1] = S[3] + S[2], d[2] = S[3] - S[2], d[3] = S[0] - S[1], t[0 + b] = d[0] + g[0], t[8 + b] = d[1] + g[1], t[16 + b] = d[2] + g[2], t[24 + b] = d[3] + g[3], t[32 + b] = d[3] - g[3], t[40 + b] = d[2] - g[2], t[48 + b] = d[1] - g[1], t[56 + b] = d[0] - g[0];
    }
    function jn(t) {
      for (var i = 0; i < 64; ++i) {
        var c = t[0][i], h = t[1][i], f = t[2][i];
        t[0][i] = c + 1.5747 * f, t[1][i] = c - 0.1873 * h - 0.4682 * f, t[2][i] = c + 1.8556 * h;
      }
    }
    function Kn(t, i, c) {
      for (var h = 0; h < 64; ++h)
        i[c + h] = Zr.toHalfFloat(ei(t[h]));
    }
    function ei(t) {
      return t <= 1 ? Math.sign(t) * Math.pow(Math.abs(t), 2.2) : Math.sign(t) * Math.pow(Ot, Math.abs(t) - 1);
    }
    function Pr(t) {
      return new DataView(t.array.buffer, t.offset.value, t.size);
    }
    function ti(t) {
      var i = t.viewer.buffer.slice(t.offset.value, t.offset.value + t.size), c = new Uint8Array(Mr(i)), h = new Uint8Array(c.length);
      return xr(c), Fr(c, h), new DataView(h.buffer);
    }
    function ir(t) {
      var i = t.array.slice(t.offset.value, t.offset.value + t.size), c = Bt(i), h = new Uint8Array(c.length);
      return xr(c), Fr(c, h), new DataView(h.buffer);
    }
    function ri(t) {
      for (var i = t.viewer, c = { value: t.offset.value }, h = new Uint16Array(t.width * t.scanlineBlockSize * (t.channels * t.type)), f = new Uint8Array(8192), v = 0, w = new Array(t.channels), p = 0; p < t.channels; p++)
        w[p] = {}, w[p].start = v, w[p].end = w[p].start, w[p].nx = t.width, w[p].ny = t.lines, w[p].size = t.type, v += w[p].nx * w[p].ny * w[p].size;
      var A = tt(i, c), g = tt(i, c);
      if (g >= 8192)
        throw "Something is wrong with PIZ_COMPRESSION BITMAP_SIZE";
      if (A <= g)
        for (var p = 0; p < g - A + 1; p++)
          f[p + A] = We(i, c);
      var S = new Uint16Array(65536), d = rr(f, S), Y = ne(i, c);
      Rr(t.array, i, c, Y, h, v);
      for (var p = 0; p < t.channels; ++p)
        for (var _ = w[p], b = 0; b < w[p].size; ++b)
          Xn(h, _.start + b, _.nx, _.size, _.ny, _.nx * _.size, d);
      qn(S, h, v);
      for (var N = 0, m = new Uint8Array(h.buffer.byteLength), B = 0; B < t.lines; B++)
        for (var z = 0; z < t.channels; z++) {
          var _ = w[z], V = _.nx * _.size, te = new Uint8Array(h.buffer, _.end * 2, V * 2);
          m.set(te, N), N += V * 2, _.end += V;
        }
      return new DataView(m.buffer);
    }
    function ni(t) {
      var i = t.array.slice(t.offset.value, t.offset.value + t.size), c = Bt(i);
      const h = t.lines * t.channels * t.width, f = t.type == 1 ? new Uint16Array(h) : new Uint32Array(h);
      let v = 0, w = 0;
      const p = new Array(4);
      for (let A = 0; A < t.lines; A++)
        for (let g = 0; g < t.channels; g++) {
          let S = 0;
          switch (t.type) {
            case 1:
              p[0] = v, p[1] = p[0] + t.width, v = p[1] + t.width;
              for (let d = 0; d < t.width; ++d) {
                const Y = c[p[0]++] << 8 | c[p[1]++];
                S += Y, f[w] = S, w++;
              }
              break;
            case 2:
              p[0] = v, p[1] = p[0] + t.width, p[2] = p[1] + t.width, v = p[2] + t.width;
              for (let d = 0; d < t.width; ++d) {
                const Y = c[p[0]++] << 24 | c[p[1]++] << 16 | c[p[2]++] << 8;
                S += Y, f[w] = S, w++;
              }
              break;
          }
        }
      return new DataView(f.buffer);
    }
    function Br(t) {
      var i = t.viewer, c = { value: t.offset.value }, h = new Uint8Array(t.width * t.lines * (t.channels * t.type * 2)), f = {
        version: he(i, c),
        unknownUncompressedSize: he(i, c),
        unknownCompressedSize: he(i, c),
        acCompressedSize: he(i, c),
        dcCompressedSize: he(i, c),
        rleCompressedSize: he(i, c),
        rleUncompressedSize: he(i, c),
        rleRawSize: he(i, c),
        totalAcUncompressedCount: he(i, c),
        totalDcUncompressedCount: he(i, c),
        acCompression: he(i, c)
      };
      if (f.version < 2)
        throw "EXRLoader.parse: " + nt.compression + " version " + f.version + " is unsupported";
      for (var v = new Array(), w = tt(i, c) - 2; w > 0; ) {
        var p = Rt(i.buffer, c), A = We(i, c), g = A >> 2 & 3, S = (A >> 4) - 1, d = new Int8Array([S])[0], Y = We(i, c);
        v.push({
          name: p,
          index: d,
          type: Y,
          compression: g
        }), w -= p.length + 3;
      }
      for (var _ = nt.channels, b = new Array(t.channels), N = 0; N < t.channels; ++N) {
        var m = b[N] = {}, B = _[N];
        m.name = B.name, m.compression = 0, m.decoded = !1, m.type = B.pixelType, m.pLinear = B.pLinear, m.width = t.width, m.height = t.lines;
      }
      for (var z = {
        idx: new Array(3)
      }, V = 0; V < t.channels; ++V)
        for (var m = b[V], N = 0; N < v.length; ++N) {
          var te = v[N];
          m.name == te.name && (m.compression = te.compression, te.index >= 0 && (z.idx[te.index] = V), m.offset = V);
        }
      if (f.acCompressedSize > 0)
        switch (f.acCompression) {
          case 0:
            var H = new Uint16Array(f.totalAcUncompressedCount);
            Rr(
              t.array,
              i,
              c,
              f.acCompressedSize,
              H,
              f.totalAcUncompressedCount
            );
            break;
          case 1:
            var k = t.array.slice(c.value, c.value + f.totalAcUncompressedCount), Ee = Bt(k), H = new Uint16Array(Ee.buffer);
            c.value += f.totalAcUncompressedCount;
            break;
        }
      if (f.dcCompressedSize > 0) {
        var $ = {
          array: t.array,
          offset: c,
          size: f.dcCompressedSize
        }, Oe = new Uint16Array(ir($).buffer);
        c.value += f.dcCompressedSize;
      }
      if (f.rleRawSize > 0) {
        var k = t.array.slice(c.value, c.value + f.rleCompressedSize), Ee = Bt(k), it = Mr(Ee.buffer);
        c.value += f.rleCompressedSize;
      }
      for (var ue = 0, D = new Array(b.length), N = 0; N < D.length; ++N)
        D[N] = new Array();
      for (var K = 0; K < t.lines; ++K)
        for (var W = 0; W < b.length; ++W)
          D[W].push(ue), ue += b[W].width * t.type * 2;
      Vn(z, D, b, H, Oe, h);
      for (var N = 0; N < b.length; ++N) {
        var m = b[N];
        if (!m.decoded)
          switch (m.compression) {
            case 2:
              for (var F = 0, fe = 0, K = 0; K < t.lines; ++K) {
                for (var De = D[N][F], ae = 0; ae < m.width; ++ae) {
                  for (var xe = 0; xe < 2 * m.type; ++xe)
                    h[De++] = it[fe + xe * m.width * m.height];
                  fe++;
                }
                F++;
              }
              break;
            case 1:
            default:
              throw "EXRLoader.parse: unsupported channel compression";
          }
      }
      return new DataView(h.buffer);
    }
    function Rt(t, i) {
      for (var c = new Uint8Array(t), h = 0; c[i.value + h] != 0; )
        h += 1;
      var f = new TextDecoder().decode(c.slice(i.value, i.value + h));
      return i.value = i.value + h + 1, f;
    }
    function ii(t, i, c) {
      var h = new TextDecoder().decode(new Uint8Array(t).slice(i.value, i.value + c));
      return i.value = i.value + c, h;
    }
    function si(t, i) {
      var c = et(t, i), h = ne(t, i);
      return [c, h];
    }
    function oi(t, i) {
      var c = ne(t, i), h = ne(t, i);
      return [c, h];
    }
    function et(t, i) {
      var c = t.getInt32(i.value, !0);
      return i.value = i.value + 4, c;
    }
    function ne(t, i) {
      var c = t.getUint32(i.value, !0);
      return i.value = i.value + 4, c;
    }
    function Dr(t, i) {
      var c = t[i.value];
      return i.value = i.value + 1, c;
    }
    function We(t, i) {
      var c = t.getUint8(i.value);
      return i.value = i.value + 1, c;
    }
    const he = function(t, i) {
      let c;
      return "getBigInt64" in DataView.prototype ? c = Number(t.getBigInt64(i.value, !0)) : c = t.getUint32(i.value + 4, !0) + Number(t.getUint32(i.value, !0) << 32), i.value += 8, c;
    };
    function j(t, i) {
      var c = t.getFloat32(i.value, !0);
      return i.value += 4, c;
    }
    function ai(t, i) {
      return Zr.toHalfFloat(j(t, i));
    }
    function T(t) {
      var i = (t & 31744) >> 10, c = t & 1023;
      return (t >> 15 ? -1 : 1) * (i ? i === 31 ? c ? NaN : 1 / 0 : Math.pow(2, i - 15) * (1 + c / 1024) : 6103515625e-14 * (c / 1024));
    }
    function tt(t, i) {
      var c = t.getUint16(i.value, !0);
      return i.value += 2, c;
    }
    function ci(t, i) {
      return T(tt(t, i));
    }
    function li(t, i, c, h) {
      for (var f = c.value, v = []; c.value < f + h - 1; ) {
        var w = Rt(i, c), p = et(t, c), A = We(t, c);
        c.value += 3;
        var g = et(t, c), S = et(t, c);
        v.push({
          name: w,
          pixelType: p,
          pLinear: A,
          xSampling: g,
          ySampling: S
        });
      }
      return c.value += 1, v;
    }
    function hi(t, i) {
      var c = j(t, i), h = j(t, i), f = j(t, i), v = j(t, i), w = j(t, i), p = j(t, i), A = j(t, i), g = j(t, i);
      return {
        redX: c,
        redY: h,
        greenX: f,
        greenY: v,
        blueX: w,
        blueY: p,
        whiteX: A,
        whiteY: g
      };
    }
    function ui(t, i) {
      var c = [
        "NO_COMPRESSION",
        "RLE_COMPRESSION",
        "ZIPS_COMPRESSION",
        "ZIP_COMPRESSION",
        "PIZ_COMPRESSION",
        "PXR24_COMPRESSION",
        "B44_COMPRESSION",
        "B44A_COMPRESSION",
        "DWAA_COMPRESSION",
        "DWAB_COMPRESSION"
      ], h = We(t, i);
      return c[h];
    }
    function fi(t, i) {
      var c = ne(t, i), h = ne(t, i), f = ne(t, i), v = ne(t, i);
      return { xMin: c, yMin: h, xMax: f, yMax: v };
    }
    function vi(t, i) {
      var c = ["INCREASING_Y"], h = We(t, i);
      return c[h];
    }
    function yi(t, i) {
      var c = j(t, i), h = j(t, i);
      return [c, h];
    }
    function pi(t, i) {
      var c = j(t, i), h = j(t, i), f = j(t, i);
      return [c, h, f];
    }
    function wi(t, i, c, h, f) {
      if (h === "string" || h === "stringvector" || h === "iccProfile")
        return ii(i, c, f);
      if (h === "chlist")
        return li(t, i, c, f);
      if (h === "chromaticities")
        return hi(t, c);
      if (h === "compression")
        return ui(t, c);
      if (h === "box2i")
        return fi(t, c);
      if (h === "lineOrder")
        return vi(t, c);
      if (h === "float")
        return j(t, c);
      if (h === "v2f")
        return yi(t, c);
      if (h === "v3f")
        return pi(t, c);
      if (h === "int")
        return et(t, c);
      if (h === "rational")
        return si(t, c);
      if (h === "timecode")
        return oi(t, c);
      if (h === "preview")
        return c.value += f, "skipped";
      c.value += f;
    }
    function di(t, i, c) {
      const h = {};
      if (t.getUint32(0, !0) != 20000630)
        throw "THREE.EXRLoader: provided file doesn't appear to be in OpenEXR format.";
      h.version = t.getUint8(4);
      const f = t.getUint8(5);
      h.spec = {
        singleTile: !!(f & 2),
        longName: !!(f & 4),
        deepFormat: !!(f & 8),
        multiPart: !!(f & 16)
      }, c.value = 8;
      for (var v = !0; v; ) {
        var w = Rt(i, c);
        if (w == 0)
          v = !1;
        else {
          var p = Rt(i, c), A = ne(t, c), g = wi(t, i, c, p, A);
          g === void 0 ? console.warn(`EXRLoader.parse: skipped unknown header attribute type '${p}'.`) : h[w] = g;
        }
      }
      if ((f & -5) != 0)
        throw console.error("EXRHeader:", h), "THREE.EXRLoader: provided file is currently unsupported.";
      return h;
    }
    function gi(t, i, c, h, f) {
      const v = {
        size: 0,
        viewer: i,
        array: c,
        offset: h,
        width: t.dataWindow.xMax - t.dataWindow.xMin + 1,
        height: t.dataWindow.yMax - t.dataWindow.yMin + 1,
        channels: t.channels.length,
        bytesPerLine: null,
        lines: null,
        inputSize: null,
        type: t.channels[0].pixelType,
        uncompress: null,
        getter: null,
        format: null,
        [at ? "colorSpace" : "encoding"]: null
      };
      switch (t.compression) {
        case "NO_COMPRESSION":
          v.lines = 1, v.uncompress = Pr;
          break;
        case "RLE_COMPRESSION":
          v.lines = 1, v.uncompress = ti;
          break;
        case "ZIPS_COMPRESSION":
          v.lines = 1, v.uncompress = ir;
          break;
        case "ZIP_COMPRESSION":
          v.lines = 16, v.uncompress = ir;
          break;
        case "PIZ_COMPRESSION":
          v.lines = 32, v.uncompress = ri;
          break;
        case "PXR24_COMPRESSION":
          v.lines = 16, v.uncompress = ni;
          break;
        case "DWAA_COMPRESSION":
          v.lines = 32, v.uncompress = Br;
          break;
        case "DWAB_COMPRESSION":
          v.lines = 256, v.uncompress = Br;
          break;
        default:
          throw "EXRLoader.parse: " + t.compression + " is unsupported";
      }
      if (v.scanlineBlockSize = v.lines, v.type == 1)
        switch (f) {
          case ft:
            v.getter = ci, v.inputSize = 2;
            break;
          case lt:
            v.getter = tt, v.inputSize = 2;
            break;
        }
      else if (v.type == 2)
        switch (f) {
          case ft:
            v.getter = j, v.inputSize = 4;
            break;
          case lt:
            v.getter = ai, v.inputSize = 4;
        }
      else
        throw "EXRLoader.parse: unsupported pixelType " + v.type + " for " + t.compression + ".";
      v.blockCount = (t.dataWindow.yMax + 1) / v.scanlineBlockSize;
      for (var w = 0; w < v.blockCount; w++)
        he(i, h);
      v.outputChannels = v.channels == 3 ? 4 : v.channels;
      const p = v.width * v.height * v.outputChannels;
      switch (f) {
        case ft:
          v.byteArray = new Float32Array(p), v.channels < v.outputChannels && v.byteArray.fill(1, 0, p);
          break;
        case lt:
          v.byteArray = new Uint16Array(p), v.channels < v.outputChannels && v.byteArray.fill(15360, 0, p);
          break;
        default:
          console.error("THREE.EXRLoader: unsupported type: ", f);
          break;
      }
      return v.bytesPerLine = v.width * v.inputSize * v.channels, v.outputChannels == 4 ? v.format = cn : v.format = ln, at ? v.colorSpace = "srgb-linear" : v.encoding = 3e3, v;
    }
    const xt = new DataView(e), Ai = new Uint8Array(e), rt = { value: 0 }, nt = di(xt, e, rt), C = gi(nt, xt, Ai, rt, this.type), Lr = { value: 0 }, Si = { R: 0, G: 1, B: 2, A: 3, Y: 0 };
    for (let t = 0; t < C.height / C.scanlineBlockSize; t++) {
      const i = ne(xt, rt);
      C.size = ne(xt, rt), C.lines = i + C.scanlineBlockSize > C.height ? C.height - i : C.scanlineBlockSize;
      const h = C.size < C.lines * C.bytesPerLine ? C.uncompress(C) : Pr(C);
      rt.value += C.size;
      for (let f = 0; f < C.scanlineBlockSize; f++) {
        const v = f + t * C.scanlineBlockSize;
        if (v >= C.height)
          break;
        for (let w = 0; w < C.channels; w++) {
          const p = Si[nt.channels[w].name];
          for (let A = 0; A < C.width; A++) {
            Lr.value = (f * (C.channels * C.width) + w * C.width + A) * C.inputSize;
            const g = (C.height - 1 - v) * (C.width * C.outputChannels) + A * C.outputChannels + p;
            C.byteArray[g] = C.getter(h, Lr);
          }
        }
      }
    }
    return {
      header: nt,
      width: C.width,
      height: C.height,
      data: C.byteArray,
      format: C.format,
      [at ? "colorSpace" : "encoding"]: C[at ? "colorSpace" : "encoding"],
      type: this.type
    };
  }
  setDataType(e) {
    return this.type = e, this;
  }
  load(e, n, s, o) {
    function a(l, u) {
      at ? l.colorSpace = u.colorSpace : l.encoding = u.encoding, l.minFilter = kt, l.magFilter = kt, l.generateMipmaps = !1, l.flipY = !1, n && n(l, u);
    }
    return super.load(e, a, s, o);
  }
}
class Lo extends gt {
  constructor(e = {}, n) {
    super(n), this.options = e;
  }
  load(e, n, s, o) {
    const { width: a, height: l, depth: u } = this.options, y = new hn(null, a, l, u), E = new Zn(this.manager);
    return E.setRequestHeader(this.requestHeader), E.setPath(this.path), E.setWithCredentials(this.withCredentials), E.load(
      e,
      (I) => {
        const { image: U } = I;
        y.image = {
          data: U.data,
          width: a ?? U.width,
          height: l ?? U.height,
          depth: u ?? Math.sqrt(U.height)
        }, y.type = I.type, y.format = I.format, y.colorSpace = I.colorSpace, y.needsUpdate = !0;
        try {
          n == null || n(y);
        } catch (q) {
          o != null ? o(q) : console.error(q), this.manager.itemError(e);
        }
      },
      s,
      o
    ), y;
  }
}
class zo extends gt {
  constructor(e = {}, n) {
    super(n), this.options = e;
  }
  load(e, n, s, o) {
    const { width: a, height: l } = this.options, u = new xi(null, a, l), y = new Zn(this.manager);
    return y.setRequestHeader(this.requestHeader), y.setPath(this.path), y.setWithCredentials(this.withCredentials), y.load(
      e,
      (E) => {
        const { image: I } = E;
        u.image = {
          data: I.data,
          width: a ?? I.width,
          height: l ?? I.height
        }, u.type = E.type, u.format = E.format, u.colorSpace = E.colorSpace, u.needsUpdate = !0;
        try {
          n == null || n(u);
        } catch (U) {
          o != null ? o(U) : console.error(U), this.manager.itemError(e);
        }
      },
      s,
      o
    ), u;
  }
}
const fr = 1e-6, Dt = /* @__PURE__ */ new Re(), Lt = /* @__PURE__ */ new Re(), Ue = /* @__PURE__ */ new Re(), ct = /* @__PURE__ */ new Re(), vr = /* @__PURE__ */ new Re(), Ks = /* @__PURE__ */ new Re(), eo = /* @__PURE__ */ new Mi(), to = /* @__PURE__ */ new Fi(), ro = /* @__PURE__ */ new Pi();
class Hn {
  constructor(e = 0, n = 0, s = 0, o = 0) {
    this.distance = e, this.heading = n, this.pitch = s, this.roll = o;
  }
  get distance() {
    return this._distance;
  }
  set distance(e) {
    this._distance = Math.max(e, fr);
  }
  get pitch() {
    return this._pitch;
  }
  set pitch(e) {
    this._pitch = $e(e, -Math.PI / 2 + fr, Math.PI / 2 - fr);
  }
  set(e, n, s, o) {
    return this.distance = e, this.heading = n, this.pitch = s, o != null && (this.roll = o), this;
  }
  clone() {
    return new Hn(this.distance, this.heading, this.pitch, this.roll);
  }
  copy(e) {
    return this.distance = e.distance, this.heading = e.heading, this.pitch = e.pitch, this.roll = e.roll, this;
  }
  equals(e) {
    return e.distance === this.distance && e.heading === this.heading && e.pitch === this.pitch && e.roll === this.roll;
  }
  decompose(e, n, s, o, a = Gr.WGS84) {
    a.getEastNorthUpVectors(
      e,
      Dt,
      Lt,
      Ue
    ), o == null || o.copy(Ue);
    const l = ct.copy(Dt).multiplyScalar(Math.cos(this.heading)).add(
      vr.copy(Lt).multiplyScalar(Math.sin(this.heading))
    ).multiplyScalar(Math.cos(this.pitch)).add(vr.copy(Ue).multiplyScalar(Math.sin(this.pitch))).normalize().multiplyScalar(this.distance);
    if (n.copy(e).sub(l), this.roll !== 0) {
      const u = ct.copy(e).sub(n).normalize();
      Ue.applyQuaternion(
        to.setFromAxisAngle(u, this.roll)
      );
    }
    s.setFromRotationMatrix(
      eo.lookAt(n, e, Ue)
    );
  }
  setFromCamera(e, n = Gr.WGS84) {
    const s = ct.setFromMatrixPosition(e.matrixWorld), o = vr.set(0, 0, 0.5).unproject(e).sub(s).normalize(), a = n.getIntersection(ro.set(s, o));
    if (a == null)
      return;
    this.distance = s.distanceTo(a), n.getEastNorthUpVectors(
      a,
      Dt,
      Lt,
      Ue
    ), this.heading = Math.atan2(
      Lt.dot(o),
      Dt.dot(o)
    ), this.pitch = Math.asin(Ue.dot(o));
    const l = ct.copy(e.up).applyQuaternion(e.quaternion), u = Ks.copy(o).multiplyScalar(-l.dot(o)).add(l).normalize(), y = ct.copy(o).multiplyScalar(-Ue.dot(o)).add(Ue).normalize(), E = y.dot(u), I = o.dot(y.cross(u));
    return this.roll = Math.atan2(I, E), this;
  }
}
const wt = class wt {
  constructor(e = 0, n = 0, s = 0, o = 0) {
    this.west = e, this.south = n, this.east = s, this.north = o;
  }
  get width() {
    let e = this.east;
    return e < this.west && (e += Math.PI * 2), e - this.west;
  }
  get height() {
    return this.north - this.south;
  }
  set(e, n, s, o) {
    return this.west = e, this.south = n, this.east = s, this.north = o, this;
  }
  clone() {
    return new wt(this.west, this.south, this.east, this.north);
  }
  copy(e) {
    return this.west = e.west, this.south = e.south, this.east = e.east, this.north = e.north, this;
  }
  equals(e) {
    return e.west === this.west && e.south === this.south && e.east === this.east && e.north === this.north;
  }
  at(e, n, s = new st()) {
    return s.set(
      this.west + (this.east - this.west) * e,
      this.north + (this.south - this.north) * n
    );
  }
  fromArray(e, n = 0) {
    return this.west = e[n], this.south = e[n + 1], this.east = e[n + 2], this.north = e[n + 3], this;
  }
  toArray(e = [], n = 0) {
    return e[n] = this.west, e[n + 1] = this.south, e[n + 2] = this.east, e[n + 3] = this.north, e;
  }
  *[Symbol.iterator]() {
    yield this.west, yield this.south, yield this.east, yield this.north;
  }
};
wt.MAX = /* @__PURE__ */ new wt(
  st.MIN_LONGITUDE,
  st.MIN_LATITUDE,
  st.MAX_LONGITUDE,
  st.MAX_LATITUDE
);
let qt = wt;
const no = /^[ \t]*#include +"([\w\d./]+)"/gm;
function io(r, e) {
  return r.replace(no, (n, s) => {
    const a = s.split("/").reduce(
      (l, u) => typeof l != "string" && l != null ? l[u] : void 0,
      e
    );
    if (typeof a != "string")
      throw new Error(`Could not find include for ${s}.`);
    return io(a, e);
  });
}
let zt;
function so() {
  if (zt != null)
    return zt;
  const r = new Uint32Array([268435456]);
  return zt = new Uint8Array(r.buffer, r.byteOffset, r.byteLength)[0] === 0, zt;
}
function ke(r, e, n, s = !0) {
  if (s === so())
    return new e(r);
  const o = Object.assign(new DataView(r), {
    getFloat16(l, u) {
      return Ps(this, l, u);
    }
  }), a = new e(o.byteLength / e.BYTES_PER_ELEMENT);
  for (let l = 0, u = 0; l < a.length; ++l, u += e.BYTES_PER_ELEMENT)
    a[l] = o[n](u, s);
  return a;
}
const oo = (r) => new Uint8Array(r), ko = (r) => new Int8Array(r), Zo = (r, e) => ke(r, Uint16Array, "getUint16", e), Ho = (r, e) => ke(r, Int16Array, "getInt16", e), Go = (r, e) => ke(r, Int32Array, "getInt32", e), Wo = (r, e) => ke(r, Uint32Array, "getUint32", e), Xo = (r, e) => ke(r, L, "getFloat16", e), Yo = (r, e) => ke(r, Float32Array, "getFloat32", e), qo = (r, e) => ke(r, Float64Array, "getFloat64", e);
class Vo extends Ls {
  constructor(e) {
    super(
      hn,
      oo,
      {
        format: ln,
        minFilter: Hr,
        magFilter: Hr,
        wrapS: sr,
        wrapT: sr,
        wrapR: sr,
        width: Di,
        height: Li,
        depth: zi
      },
      e
    );
  }
}
function* Gn(r, e, n, s, o) {
  if (n >= s)
    return;
  const a = 2 ** n, l = n + 1, u = 2 ** l, y = Math.floor(r / a * u), E = Math.floor(e / a * u), I = [
    [y, E, l],
    [y + 1, E, l],
    [y, E + 1, l],
    [y + 1, E + 1, l]
  ];
  if (l < s)
    for (const U of I)
      for (const q of Gn(...U, s, o))
        yield q;
  else
    for (const U of I)
      yield (o ?? new dt()).set(...U);
}
class dt {
  constructor(e = 0, n = 0, s = 0) {
    this.x = e, this.y = n, this.z = s;
  }
  set(e, n, s) {
    return this.x = e, this.y = n, s != null && (this.z = s), this;
  }
  clone() {
    return new dt(this.x, this.y, this.z);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z;
  }
  getParent(e = new dt()) {
    const n = 2 ** this.z, s = this.x / n, o = this.y / n, a = this.z - 1, l = 2 ** a;
    return e.set(Math.floor(s * l), Math.floor(o * l), a);
  }
  *traverseChildren(e, n) {
    const { x: s, y: o, z: a } = this;
    for (const l of Gn(s, o, a, a + e, n))
      yield l;
  }
  fromArray(e, n = 0) {
    return this.x = e[n], this.y = e[n + 1], this.z = e[n + 2], this;
  }
  toArray(e = [], n = 0) {
    return e[n] = this.x, e[n + 1] = this.y, e[n + 2] = this.z, e;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z;
  }
}
const an = /* @__PURE__ */ new un();
class Wn {
  constructor(e = 2, n = 1, s = qt.MAX) {
    this.width = e, this.height = n, this.rectangle = s;
  }
  clone() {
    return new Wn(this.width, this.height, this.rectangle.clone());
  }
  copy(e) {
    return this.width = e.width, this.height = e.height, this.rectangle.copy(e.rectangle), this;
  }
  getSize(e, n = new un()) {
    return n.set(this.width << e, this.height << e);
  }
  // Reference: https://github.com/CesiumGS/cesium/blob/1.122/packages/engine/Source/Core/GeographicTilingScheme.js#L210
  getTile(e, n, s = new dt()) {
    const o = this.getSize(n, an), { rectangle: a } = this, l = a.width / o.x, u = a.height / o.y, { west: y, south: E, east: I } = a;
    let U = e.longitude;
    I < y && (U += Math.PI * 2);
    let q = Math.floor((U - y) / l);
    q >= o.x && (q = o.x - 1);
    let se = Math.floor((e.latitude - E) / u);
    return se >= o.y && (se = o.y - 1), s.x = q, s.y = se, s.z = n, s;
  }
  // Reference: https://github.com/CesiumGS/cesium/blob/1.122/packages/engine/Source/Core/GeographicTilingScheme.js#L169
  getRectangle(e, n = new qt()) {
    const s = this.getSize(e.z, an), { rectangle: o } = this, a = o.width / s.x, l = o.height / s.y, { west: u, north: y } = o;
    return n.west = e.x * a + u, n.east = (e.x + 1) * a + u, n.north = y - (s.y - e.y - 1) * l, n.south = y - (s.y - e.y) * l, n;
  }
}
const ao = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*(?:i\s*\+\+|\+\+\s*i)\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function co(r, e, n, s) {
  let o = "";
  for (let a = parseInt(e); a < parseInt(n); ++a)
    o += s.replace(/\[\s*i\s*\]/g, "[" + a + "]").replace(/UNROLLED_LOOP_INDEX/g, `${a}`);
  return o;
}
function $o(r) {
  return r.replace(ao, co);
}
export {
  Bi as ArrayBufferLoader,
  po as DEFAULT_STBN_URL,
  Ls as DataTextureLoader,
  Lo as EXR3DTextureLoader,
  zo as EXRTextureLoader,
  Gr as Ellipsoid,
  jo as EllipsoidGeometry,
  L as Float16Array,
  st as Geodetic,
  Hn as PointOfView,
  qt as Rectangle,
  Vo as STBNLoader,
  zi as STBN_TEXTURE_DEPTH,
  Li as STBN_TEXTURE_HEIGHT,
  Di as STBN_TEXTURE_WIDTH,
  dt as TileCoordinate,
  Wn as TilingScheme,
  Bs as TypedArrayLoader,
  uo as assertType,
  _o as ceilPowerOfTwo,
  $e as clamp,
  Ro as closeTo,
  xo as define,
  Po as defineExpression,
  Mo as defineFloat,
  Fo as defineInt,
  Bo as definePropertyShorthand,
  Do as defineUniformShorthand,
  To as degrees,
  go as euclideanModulo,
  bo as floorPowerOfTwo,
  vo as fromBufferGeometryLike,
  Ao as inverseLerp,
  yo as isFloatLinearSupported,
  Io as isPowerOfTwo,
  wo as isTypedArray,
  So as lerp,
  No as normalize,
  Xo as parseFloat16Array,
  Yo as parseFloat32Array,
  qo as parseFloat64Array,
  Ho as parseInt16Array,
  Go as parseInt32Array,
  ko as parseInt8Array,
  Zo as parseUint16Array,
  Wo as parseUint32Array,
  oo as parseUint8Array,
  Eo as radians,
  Oo as remap,
  Uo as remapClamped,
  io as resolveIncludes,
  Co as saturate,
  mo as smoothstep,
  fo as toBufferGeometryLike,
  $o as unrollLoops
};
//# sourceMappingURL=index.js.map
