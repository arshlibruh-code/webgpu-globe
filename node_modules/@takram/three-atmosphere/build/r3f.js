import { jsx as h, jsxs as j, Fragment as U } from "react/jsx-runtime";
import { useThree as R, useFrame as S, extend as F, useLoader as I } from "@react-three/fiber";
import { EffectComposerContext as N } from "@react-three/postprocessing";
import { RenderPass as G } from "postprocessing";
import { createContext as z, useRef as v, useMemo as x, useEffect as E, useImperativeHandle as H, useContext as y, useState as _, version as W, useCallback as J } from "react";
import { Matrix4 as b, Vector3 as A, Texture as K, Object3D as Q } from "three";
import { Ellipsoid as V, DEFAULT_STBN_URL as X, STBNLoader as Y, ArrayBufferLoader as q } from "@takram/three-geospatial";
import { x as B, P as Z, g as $, e as ee, f as te, a as re, A as ne, L as oe, B as se, C as ie, t as O, z as ae, y as ce, F as ue, k as le, E as fe, G as de, J as me, H as pe, j as ge } from "./shared.js";
import { ScreenQuad as xe } from "@react-three/drei";
const D = /* @__PURE__ */ z({}), ke = ({
  ref: t,
  textures: e,
  ellipsoid: s = V.WGS84,
  correctAltitude: n = !0,
  ground: r = !0,
  date: i,
  children: a
}) => {
  const d = v({
    sunDirection: new A(),
    moonDirection: new A(),
    worldToECEFMatrix: new b(),
    inertialToECEFMatrix: new b(),
    overlay: null,
    shadow: null,
    shadowLength: null,
    lightingMask: null
  }), c = R(({ gl: f }) => f), u = x(
    () => typeof e == "string" ? new B().setType(c).load(e) : void 0,
    [e, c]
  );
  E(() => {
    if (u != null)
      return () => {
        for (const f of Object.values(u))
          f == null || f.dispose();
      };
  }, [u]);
  const l = x(
    () => e == null ? new Z(c) : void 0,
    [e, c]
  );
  E(() => {
    if (l != null)
      return l.update().catch((f) => {
        console.error(f);
      }), () => {
        l.dispose();
      };
  }, [l]);
  const p = (l == null ? void 0 : l.textures) ?? (typeof e == "string" ? u : e), g = x(
    () => ({
      textures: p,
      ellipsoid: s,
      correctAltitude: n,
      ground: r,
      transientStates: d.current
    }),
    [p, s, n, r]
  ), o = x(() => {
    const { sunDirection: f, moonDirection: M, inertialToECEFMatrix: w } = d.current;
    return (T) => {
      $(T, w), ee(T, f).applyMatrix4(w), te(T, M).applyMatrix4(
        w
      );
    };
  }, []), m = i != null && !isNaN(+i) ? +i : void 0;
  return E(() => {
    m != null && o(m);
  }, [m, o]), H(
    t,
    () => ({
      ...d.current,
      textures: p,
      updateByDate: o
    }),
    [p, o]
  ), /* @__PURE__ */ h(D.Provider, { value: g, children: a });
};
function k(t) {
  const {
    irradianceTexture: e,
    scatteringTexture: s,
    transmittanceTexture: n,
    singleMieScatteringTexture: r,
    higherOrderScatteringTexture: i,
    ellipsoid: a,
    correctAltitude: d,
    sunDirection: c,
    sunAngularRadius: u,
    ground: l,
    renderTargetCount: p,
    ...g
  } = t;
  return [
    {
      irradianceTexture: e,
      scatteringTexture: s,
      transmittanceTexture: n,
      singleMieScatteringTexture: r,
      higherOrderScatteringTexture: i,
      ellipsoid: a,
      correctAltitude: d,
      sunDirection: c,
      sunAngularRadius: u,
      ground: l,
      renderTargetCount: p
    },
    g
  ];
}
function he(t) {
  const e = x(
    () => typeof t == "string" ? new Y().load(t) : void 0,
    [t]
  );
  return E(() => {
    if (e != null)
      return () => {
        e.dispose();
      };
  }, [e]), (typeof t == "string" ? e : t) ?? null;
}
const be = ({
  ref: t,
  stbnTexture: e = X,
  ...s
}) => {
  const { textures: n, transientStates: r, ...i } = y(D), [a, { blendFunction: d, ...c }] = k({
    ...re,
    ...i,
    ...n,
    ...s
  }), u = y(N), { normalPass: l, camera: p } = u, g = "geometryPass" in u && u.geometryPass instanceof G && "geometryTexture" in u.geometryPass && u.geometryPass.geometryTexture instanceof K ? u.geometryPass.geometryTexture : void 0, o = x(
    () => new ne(void 0, { blendFunction: d }),
    [d]
  );
  E(() => () => {
    o.dispose();
  }, [o]);
  const [m, f] = _(!1);
  S(() => {
    r != null && (o.sunDirection.copy(r.sunDirection), o.moonDirection.copy(r.moonDirection), o.worldToECEFMatrix.copy(r.worldToECEFMatrix), o.overlay = r.overlay, o.shadow = r.shadow, o.shadowLength = r.shadowLength, o.lightingMask = r.lightingMask, !m && o.shadow != null && f(!0));
  });
  const M = he(
    m ? e : void 0
  );
  return /* @__PURE__ */ h(
    "primitive",
    {
      ref: t,
      object: o,
      mainCamera: p,
      normalBuffer: g ?? (l == null ? void 0 : l.texture) ?? null,
      ...a,
      ...c,
      stbnTexture: M,
      octEncodedNormal: g != null
    }
  );
};
function Te(t) {
  return (e) => {
    for (const s of t) P(s, e);
  };
}
function Ee(t) {
  return (e) => {
    const s = [];
    for (const n of t) {
      const r = P(n, e), i = typeof r == "function";
      s.push(i ? r : () => P(n, null));
    }
    return () => {
      for (const n of s) n();
    };
  };
}
function P(t, e) {
  if (typeof t == "function")
    return t(e);
  t && (t.current = e);
}
var L = parseInt(W.split(".")[0], 10) >= 19 ? Ee : Te;
const ye = ({
  ref: t,
  ...e
}) => {
  const { transientStates: s } = y(D), n = J(
    (a) => {
      if (a != null && s != null)
        return s.lightingMask = {
          map: a.texture,
          channel: "r"
        }, () => {
          s.lightingMask = null;
        };
    },
    [s]
  ), { scene: r, camera: i } = y(N);
  return F({ LightingMaskPass: oe }), /* @__PURE__ */ h(
    "lightingMaskPass",
    {
      ref: L([n, t]),
      ...e,
      args: [r, i]
    }
  );
}, Ae = ye, je = ({ ref: t, ...e }) => {
  const { textures: s, transientStates: n, ...r } = y(D), [
    i,
    {
      sun: a,
      moon: d,
      moonDirection: c,
      moonAngularRadius: u,
      lunarRadianceScale: l,
      groundAlbedo: p,
      ...g
    }
  ] = k({
    ...se,
    ...r,
    ...s,
    ...e
  }), o = x(() => new ie(), []);
  return E(() => () => {
    o.dispose();
  }, [o]), S(() => {
    n != null && (o.sunDirection.copy(n.sunDirection), o.moonDirection.copy(n.moonDirection), o.worldToECEFMatrix.copy(n.worldToECEFMatrix), o.shadowLength = n.shadowLength);
  }), /* @__PURE__ */ h(
    xe,
    {
      renderOrder: O,
      ...g,
      ref: t,
      children: /* @__PURE__ */ h(
        "primitive",
        {
          object: o,
          ...i,
          sun: a,
          moon: d,
          moonDirection: c,
          moonAngularRadius: u,
          lunarRadianceScale: l,
          groundAlbedo: p
        }
      )
    }
  );
}, Ne = ({
  ref: t,
  ...e
}) => {
  const { textures: s, transientStates: n, ...r } = y(D), i = v(null);
  return S(() => {
    const a = i.current;
    a != null && n != null && (a.sunDirection.copy(n.sunDirection), a.worldToECEFMatrix.copy(n.worldToECEFMatrix), a.update());
  }), F({ SkyLightProbe: ae }), /* @__PURE__ */ h(
    "skyLightProbe",
    {
      ref: L([i, t]),
      ...ce,
      ...r,
      ...s,
      ...e
    }
  );
}, _e = ({
  ref: t,
  data: e = le,
  ...s
}) => {
  const { textures: n, transientStates: r, ...i } = y(D), [
    a,
    { pointSize: d, radianceScale: c, intensity: u, background: l, ...p }
  ] = k({
    ...ue,
    ...i,
    ...n,
    ...s
  }), [g, o] = _(
    typeof e != "string" ? e : void 0
  );
  E(() => {
    if (typeof e == "string") {
      const T = new q();
      (async () => {
        o(await T.loadAsync(e));
      })().catch((C) => {
        console.error(C);
      });
    } else
      o(e);
  }, [e]);
  const m = x(
    () => g != null ? new fe(g) : void 0,
    [g]
  );
  E(() => () => {
    m == null || m.dispose();
  }, [m]);
  const f = x(() => new de(), []);
  E(() => () => {
    f.dispose();
  }, [f]);
  const M = v(null);
  S(({ camera: T }) => {
    var C;
    r != null && T.isPerspectiveCamera === !0 && (f.sunDirection.copy(r.sunDirection), (C = M.current) == null || C.setRotationFromMatrix(r.inertialToECEFMatrix), f.worldToECEFMatrix.copy(r.worldToECEFMatrix));
  });
  const w = R(({ camera: T }) => T);
  return m == null || w.isPerspectiveCamera !== !0 ? null : /* @__PURE__ */ j(
    "points",
    {
      ref: L([M, t]),
      frustumCulled: !1,
      renderOrder: O + 1,
      ...p,
      children: [
        /* @__PURE__ */ h("primitive", { object: m }),
        /* @__PURE__ */ h(
          "primitive",
          {
            object: f,
            ...a,
            pointSize: d,
            radianceScale: c,
            intensity: u,
            background: l,
            depthTest: !0,
            depthWrite: !1
          }
        )
      ]
    }
  );
}, Be = ({
  ref: t,
  position: e,
  ...s
}) => {
  const { textures: n, transientStates: r, ...i } = y(D), a = v(null);
  S(() => {
    const c = a.current;
    c != null && r != null && (c.sunDirection.copy(r.sunDirection), c.worldToECEFMatrix.copy(r.worldToECEFMatrix), c.update());
  });
  const d = x(() => new Q(), []);
  return F({ SunDirectionalLight: me }), /* @__PURE__ */ j(U, { children: [
    /* @__PURE__ */ h(
      "sunDirectionalLight",
      {
        ref: L([a, t]),
        ...pe,
        ...i,
        ...n,
        ...s,
        target: d
      }
    ),
    /* @__PURE__ */ h("primitive", { object: d, position: e })
  ] });
}, De = new B();
function Oe(t = ge) {
  const e = R(({ gl: n }) => n);
  return { textures: I(De.setType(e), t) };
}
export {
  be as AerialPerspective,
  ke as Atmosphere,
  D as AtmosphereContext,
  Ae as IrradianceMask,
  ye as LightingMask,
  je as Sky,
  Ne as SkyLight,
  _e as Stars,
  Be as SunLight,
  k as separateProps,
  Oe as useAtmosphereTextureProps
};
//# sourceMappingURL=r3f.js.map
